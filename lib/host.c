#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 700
#endif

#include "host.h"
#include <libssh/libssh.h>
#include <libssh/server.h>
#include "client.h"
#include "webssh_client.h"
#include "matrix_client.h"
#include "translator.h"
#include "translation_helpers.h"

#include <curl/curl.h>
#include <gc/gc.h>
#include <iconv.h>
#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <math.h>
#include <libgen.h>
#include <limits.h>
#include <signal.h>
#include <wchar.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <poll.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include "humanized/humanized.h"

static void session_dispatch_command(session_ctx_t *ctx, const char *line);
static void session_handle_mode(session_ctx_t *ctx, const char *arguments);
static void session_handle_nick(session_ctx_t *ctx, const char *arguments);
static void session_handle_exit(session_ctx_t *ctx);

static const session_ops_t ssh_session_ops = {
    .dispatch_command = session_dispatch_command,
    .handle_mode = session_handle_mode,
    .handle_nick = session_handle_nick,
    .handle_exit = session_handle_exit,
};

static const session_ops_t telnet_session_ops = {
    .dispatch_command = session_dispatch_command,
    .handle_mode = session_handle_mode,
    .handle_nick = session_handle_nick,
    .handle_exit = session_handle_exit,
};



#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif

#ifndef RTLD_LOCAL
#define RTLD_LOCAL 0
#endif

#define ANSI_CLEAR_LINE "\033[2K"
#define ANSI_INSERT_LINE "\033[1L"

#define SSH_CHATTER_MESSAGE_BOX_MAX_LINES 32U
#define SSH_CHATTER_MESSAGE_BOX_PADDING 2U
#define SSH_CHATTER_IMAGE_PREVIEW_WIDTH 48U
#define SSH_CHATTER_IMAGE_PREVIEW_HEIGHT 48U
#define SSH_CHATTER_IMAGE_PREVIEW_LINE_LEN 128U
#define SSH_CHATTER_BBS_DEFAULT_TAG "general"
#define SSH_CHATTER_ASCIIART_TERMINATOR_EN ">/__ARTWORK_END>"
#define SSH_CHATTER_BBS_TERMINATOR_EN ">/__BBS_END>"
#define SSH_CHATTER_BBS_EDITOR_BODY_DIVIDER "----------Body---------------"
#define SSH_CHATTER_BBS_EDITOR_END_DIVIDER "----------End-----------------"
#define SSH_CHATTER_RSS_REFRESH_SECONDS 180U
#define SSH_CHATTER_RSS_SLEEP_CHUNK_SECONDS 5U
#define SSH_CHATTER_RSS_USER_AGENT "ssh-chatter/rss"
#define SSH_CHATTER_RSS_BREAKING_PREFIX "[BREAKING NEWS]"
#define SSH_CHATTER_TETROMINO_SIZE 4
#define SSH_CHATTER_HANDSHAKE_RETRY_LIMIT ((unsigned int)INT_MAX)
#define SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS_DISPLAY \
  "rsa-sha2-512, rsa-sha2-256, ssh-rsa, ssh-ed25519, ecdsa-sha2-nistp256"
#define SSH_CHATTER_SUPPORTED_KEX_ALGORITHMS                                                     \
  "curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,"       \
  "ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,"      \
  "diffie-hellman-group14-sha1"
#define SSH_CHATTER_STRONG_CIPHERS "chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes256-ctr"
#define SSH_CHATTER_STRONG_MACS "hmac-sha2-512,hmac-sha2-256"
#define SSH_CHATTER_SECURE_COMPRESSION "none"
#define SSH_CHATTER_BIRTHDAY_WINDOW_SECONDS (7 * 24 * 60 * 60)

#define ALPHA_LANDERS_MAX_RECORDS 256U
#define ALPHA_LANDERS_DISPLAY_LIMIT 10U

typedef struct alpha_lander_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  uint32_t flag_count;
  uint64_t last_flag_timestamp;
} alpha_lander_entry_t;

void * GC_CALLOC(size_t len, size_t t_len) {
  if (len == 0U || t_len == 0U) {
    return GC_MALLOC(0U);
  }

  if (len > SIZE_MAX / t_len) {
    errno = ENOMEM;
    return NULL;
  }

  size_t total = len * t_len;
  void *calloc_mem = GC_MALLOC(total);
  if (calloc_mem == NULL) {
    errno = ENOMEM;
    return NULL;
  }

  memset(calloc_mem, 0, total);
  return calloc_mem;
}

static int alpha_lander_entry_compare(const void *lhs, const void *rhs) {
  const alpha_lander_entry_t *left = (const alpha_lander_entry_t *)lhs;
  const alpha_lander_entry_t *right = (const alpha_lander_entry_t *)rhs;

  if (left->flag_count < right->flag_count) {
    return 1;
  }
  if (left->flag_count > right->flag_count) {
    return -1;
  }
  if (left->last_flag_timestamp < right->last_flag_timestamp) {
    return 1;
  }
  if (left->last_flag_timestamp > right->last_flag_timestamp) {
    return -1;
  }
  return strcasecmp(left->username, right->username);
}

static const char *const SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS[] = {
    "rsa-sha2-512",
    "rsa-sha2-256",
    "ssh-rsa",
    "ssh-ed25519",
    "ecdsa-sha2-nistp256",
};

typedef struct host_key_definition {
  const char *algorithm;
  const char *filename;
  ssh_bind_options_e option;
  bool requires_import;
} host_key_definition_t;

static const size_t SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS_COUNT =
    sizeof(SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS) /
    sizeof(SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS[0]);
#define SESSION_CHANNEL_TIMEOUT (-2)

typedef struct lan_operator_env_pair {
  const char *name_var;
  const char *password_var;
} lan_operator_env_pair_t;

static const lan_operator_env_pair_t LAN_OPERATOR_ENV_PAIRS[] = {
    {"ADMIN1", "ADMIN1PW"},
    {"ADMIN2", "ADMIN2PW"},
    {"ADMIN3", "ADMIN3PW"},
    {"ADMIN4", "ADMIN4PW"},
    {"BACKUP", "BACKUPPW"},
};

static const size_t LAN_OPERATOR_ENV_PAIR_COUNT =
    sizeof(LAN_OPERATOR_ENV_PAIRS) / sizeof(LAN_OPERATOR_ENV_PAIRS[0]);

static bool host_address_is_wildcard(const char *address) {
  if (address == NULL) {
    return true;
  }

  if (address[0] == '\0') {
    return true;
  }

  if (strcmp(address, "*") == 0 || strcmp(address, "0.0.0.0") == 0 || strcmp(address, "::") == 0 ||
      strcmp(address, "::0") == 0) {
    return true;
  }

  bool all_zero = true;
  for (const char *cursor = address; *cursor != '\0'; ++cursor) {
    if (*cursor == ':' || *cursor == '.') {
      continue;
    }
    if (*cursor != '0') {
      all_zero = false;
      break;
    }
  }

  return all_zero;
}

static bool host_is_protected_ip_unlocked(const host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0; idx < host->protected_ip_count && idx < SSH_CHATTER_MAX_PROTECTED_IPS; ++idx) {
    if (strncmp(host->protected_ips[idx], ip, SSH_CHATTER_IP_LEN) == 0) {
      return true;
    }
  }

  return false;
}

static bool host_protected_ip_add_unlocked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL) {
    return false;
  }

  char normalized[SSH_CHATTER_IP_LEN];
  size_t length = strnlen(ip, sizeof(normalized));
  size_t start = 0U;
  while (start < length && isspace((unsigned char)ip[start]) != 0) {
    ++start;
  }
  size_t end = length;
  while (end > start && isspace((unsigned char)ip[end - 1U]) != 0) {
    --end;
  }

  if (end <= start) {
    return false;
  }

  size_t normalized_length = end - start;
  if (normalized_length >= sizeof(normalized)) {
    normalized_length = sizeof(normalized) - 1U;
  }
  memcpy(normalized, ip + start, normalized_length);
  normalized[normalized_length] = '\0';

  if (host_address_is_wildcard(normalized)) {
    return false;
  }

  if (host_is_protected_ip_unlocked(host, normalized)) {
    return true;
  }

  if (host->protected_ip_count >= SSH_CHATTER_MAX_PROTECTED_IPS) {
    return false;
  }

  snprintf(host->protected_ips[host->protected_ip_count], SSH_CHATTER_IP_LEN, "%s", normalized);
  ++host->protected_ip_count;
  return true;
}

static bool host_protected_ip_add(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL) {
    return false;
  }

  bool added = false;
  pthread_mutex_lock(&host->lock);
  added = host_protected_ip_add_unlocked(host, ip);
  pthread_mutex_unlock(&host->lock);
  return added;
}

static void host_protected_ips_load_from_env(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *env = getenv("CHATTER_PROTECTED_IPS");
  if (env == NULL || env[0] == '\0') {
    return;
  }

  size_t env_length = strlen(env);
  char *copy = (char *)malloc(env_length + 1U);
  if (copy == NULL) {
    humanized_log_error("host", "failed to allocate protected ip buffer", errno != 0 ? errno : ENOMEM);
    return;
  }
  memcpy(copy, env, env_length + 1U);

  char *save_ptr = NULL;
  for (char *token = strtok_r(copy, ",", &save_ptr); token != NULL; token = strtok_r(NULL, ",", &save_ptr)) {
    char working[SSH_CHATTER_IP_LEN];
    size_t token_length = strnlen(token, sizeof(working));
    if (token_length >= sizeof(working)) {
      token_length = sizeof(working) - 1U;
    }
    memcpy(working, token, token_length);
    working[token_length] = '\0';

    // Trim leading and trailing whitespace inside the buffer before adding it.
    size_t local_length = strnlen(working, sizeof(working));
    size_t local_start = 0U;
    while (local_start < local_length && isspace((unsigned char)working[local_start]) != 0) {
      ++local_start;
    }
    size_t local_end = local_length;
    while (local_end > local_start && isspace((unsigned char)working[local_end - 1U]) != 0) {
      --local_end;
    }
    if (local_end <= local_start) {
      continue;
    }
    size_t trimmed_length = local_end - local_start;
    if (trimmed_length >= sizeof(working)) {
      trimmed_length = sizeof(working) - 1U;
    }
    memmove(working, working + local_start, trimmed_length);
    working[trimmed_length] = '\0';

    if (working[0] == '\0') {
      continue;
    }

    (void)host_protected_ip_add(host, working);
  }

  free(copy);
}

static void host_protected_ips_bootstrap(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *defaults[] = {"127.0.0.1", "::1", "192.168.0.1"};

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0; idx < sizeof(defaults) / sizeof(defaults[0]); ++idx) {
    (void)host_protected_ip_add_unlocked(host, defaults[idx]);
  }
  pthread_mutex_unlock(&host->lock);

  host_protected_ips_load_from_env(host);
}

static void host_register_protected_bind_address(host_t *host, const char *address) {
  if (host == NULL || address == NULL || address[0] == '\0') {
    return;
  }

  if (host_address_is_wildcard(address)) {
    return;
  }

  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  struct addrinfo *result = NULL;
  int rc = getaddrinfo(address, NULL, &hints, &result);
  if (rc != 0 || result == NULL) {
    (void)host_protected_ip_add(host, address);
    if (result != NULL) {
      freeaddrinfo(result);
    }
    return;
  }

  for (struct addrinfo *entry = result; entry != NULL; entry = entry->ai_next) {
    char ip_buffer[SSH_CHATTER_IP_LEN];
    void *addr_ptr = NULL;
    int family = entry->ai_family;
    if (family == AF_INET) {
      struct sockaddr_in *in4 = (struct sockaddr_in *)entry->ai_addr;
      addr_ptr = &in4->sin_addr;
    } else if (family == AF_INET6) {
      struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)entry->ai_addr;
      addr_ptr = &in6->sin6_addr;
    } else {
      continue;
    }

    if (inet_ntop(family, addr_ptr, ip_buffer, sizeof(ip_buffer)) == NULL) {
      continue;
    }

    (void)host_protected_ip_add(host, ip_buffer);
  }

  freeaddrinfo(result);
}

static void host_clear_lan_operator_credentials(host_t *host) {
  if (host == NULL) {
    return;
  }

  host->lan_ops.count = 0U;
  memset(host->lan_ops.entries, 0, sizeof(host->lan_ops.entries));
}

static lan_operator_credential_t *host_find_lan_operator_credential(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return NULL;
  }

  size_t limit = host->lan_ops.count;
  if (limit > SSH_CHATTER_MAX_LAN_OPERATORS) {
    limit = SSH_CHATTER_MAX_LAN_OPERATORS;
  }

  for (size_t idx = 0U; idx < limit; ++idx) {
    lan_operator_credential_t *credential = &host->lan_ops.entries[idx];
    if (!credential->active) {
      continue;
    }
    if (strcasecmp(credential->nickname, username) == 0) {
      return credential;
    }
  }

  return NULL;
}

static bool host_is_lan_operator_username(host_t *host, const char *username) {
  return host_find_lan_operator_credential(host, username) != NULL;
}

static void host_load_lan_operator_credentials(host_t *host) {
  host_clear_lan_operator_credentials(host);
  if (host == NULL) {
    return;
  }

  for (size_t idx = 0U; idx < LAN_OPERATOR_ENV_PAIR_COUNT; ++idx) {
    const lan_operator_env_pair_t *pair = &LAN_OPERATOR_ENV_PAIRS[idx];
    const char *username = getenv(pair->name_var);
    const char *password = getenv(pair->password_var);
    if (username == NULL || username[0] == '\0') {
      continue;
    }
    if (password == NULL || password[0] == '\0') {
      continue;
    }

    lan_operator_credential_t *existing = host_find_lan_operator_credential(host, username);
    if (existing != NULL) {
      existing->active = true;
      snprintf(existing->nickname, sizeof(existing->nickname), "%s", username);
      snprintf(existing->password, sizeof(existing->password), "%s", password);
      continue;
    }

    if (host->lan_ops.count >= SSH_CHATTER_MAX_LAN_OPERATORS) {
      continue;
    }

    lan_operator_credential_t *credential = &host->lan_ops.entries[host->lan_ops.count++];
    memset(credential, 0, sizeof(*credential));
    credential->active = true;
    snprintf(credential->nickname, sizeof(credential->nickname), "%s", username);
    snprintf(credential->password, sizeof(credential->password), "%s", password);
  }
}

typedef enum host_join_attempt_result {
  HOST_JOIN_ATTEMPT_OK = 0,
  HOST_JOIN_ATTEMPT_KICK,
  HOST_JOIN_ATTEMPT_BAN,
} host_join_attempt_result_t;
#define HOST_MODERATION_CATEGORY_LEN 64U
#define HOST_MODERATION_SNIPPET_LEN 1024U
#define HOST_MODERATION_WORKER_EXIT_CODE 0
#define HOST_MODERATION_WORKER_STABLE_SECONDS 30.0
#define HOST_MODERATION_MAX_RESTART_ATTEMPTS 5U

typedef struct host_moderation_task {
  struct host_moderation_task *next;
  uint64_t task_id;
  char username[SSH_CHATTER_USERNAME_LEN];
  char client_ip[SSH_CHATTER_IP_LEN];
  char category[HOST_MODERATION_CATEGORY_LEN];
  char snippet[HOST_MODERATION_SNIPPET_LEN];
  size_t snippet_length;
  char message[SSH_CHATTER_MESSAGE_LIMIT];
  bool post_send;
} host_moderation_task_t;

typedef struct {
  uint64_t task_id;
  uint32_t category_length;
  uint32_t content_length;
} host_moderation_ipc_request_t;

typedef struct {
  uint64_t task_id;
  int32_t result;
  uint32_t message_length;
  uint32_t disable_filter;
} host_moderation_ipc_response_t;
#define SSH_CHATTER_CHANNEL_RECOVERY_LIMIT ((unsigned int)INT_MAX)
#define SSH_CHATTER_CHANNEL_RECOVERY_DELAY_NS 200000000L
#define SSH_CHATTER_CHANNEL_WRITE_TIMEOUT_MS 200
#define SSH_CHATTER_CHANNEL_WRITE_MAX_STALLS 30U
#define SSH_CHATTER_CHANNEL_WRITE_CHUNK 1024U
#define SSH_CHATTER_CHANNEL_WRITE_BACKOFF_NS 20000000L
#define SSH_CHATTER_TRANSLATION_SEGMENT_GUARD 32U
#define SSH_CHATTER_TRANSLATION_BATCH_DELAY_NS 150000000L
#define SSH_CHATTER_JOIN_RAPID_WINDOW_NS 60000000000LL
#define SSH_CHATTER_JOIN_IP_THRESHOLD 6U
#define SSH_CHATTER_JOIN_NAME_THRESHOLD 6U
#define SSH_CHATTER_JOIN_KICK_WINDOW_NS 60000000000LL
#define SSH_CHATTER_JOIN_KICK_THRESHOLD 20U
#define SSH_CHATTER_SUSPICIOUS_EVENT_WINDOW_NS 300000000000LL
#define SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD 2U
#define SSH_CHATTER_CLAMAV_SCAN_INTERVAL_SECONDS (5 * 60 * 60)
#define SSH_CHATTER_CLAMAV_SLEEP_CHUNK_SECONDS 30U
#define SSH_CHATTER_BBS_WATCHDOG_SLEEP_SECONDS 5U
#define SSH_CHATTER_CLAMAV_OUTPUT_LIMIT 512U
#define SSH_CHATTER_BBS_REVIEW_INTERVAL_SECONDS 120U
#define ELIZA_MEMORY_MAGIC 0x454C5A41U
#define ELIZA_MEMORY_VERSION 1U
#define SSH_CHATTER_ELIZA_CONTEXT_LIMIT 3U
#define SSH_CHATTER_ELIZA_CONTEXT_BUFFER (SSH_CHATTER_MESSAGE_LIMIT * 4U)
#define SSH_CHATTER_ELIZA_HISTORY_LIMIT 6U
#define SSH_CHATTER_ELIZA_HISTORY_WINDOW 12U
#define SSH_CHATTER_ELIZA_BBS_CONTEXT_LIMIT 3U
#define SSH_CHATTER_ELIZA_BBS_PREVIEW_LEN 160U
#define SSH_CHATTER_ELIZA_PROMPT_BUFFER ((SSH_CHATTER_ELIZA_CONTEXT_BUFFER * 2U) + (SSH_CHATTER_MESSAGE_LIMIT * 3U))
#define SSH_CHATTER_ELIZA_TOKEN_LIMIT 16U

static size_t host_column_reset_sequence_length(const char *text);
static bool host_contains_column_reset(const char *text);
static void host_strip_column_reset(char *text);

#define ALPHA_TOTAL_DISTANCE_LY 4.24
#define ALPHA_LY_TO_KM 9460730472580.8
#define ALPHA_LY_TO_AU 63241.077
#define ALPHA_SPEED_OF_LIGHT_MPS 299792458.0
#define ALPHA_NAV_WIDTH 60
#define ALPHA_NAV_HEIGHT 60
#define ALPHA_NAV_MARGIN 6
#define ALPHA_THRUST_DELTA 0.45
#define ALPHA_THRUST_POSITION_STEP 0.5
#define ALPHA_GRAVITY_DAMPING 0.97
#define ALPHA_GRAVITY_MIN_DISTANCE 2.5
#define ALPHA_GRAVITY_MAX_ACCEL 0.30
#define ALPHA_NAV_MAX_SPEED 1.20
#define ALPHA_BLACK_HOLE_MU 1800.0
#define ALPHA_STAR_MU 360.0
#define ALPHA_PLANET_MU 65.0
#define ALPHA_DEBRIS_MU 12.0
#define ALPHA_MIN_WAYPOINTS 3U

static const char *const kAlphaWaystationNames[] = {
    "Relay Lyra",
    "Depot Carina",
    "Refuel Vesper",
    "Outpost Helion",
};

#define TELNET_IAC 255
#define TELNET_CMD_SE 240
#define TELNET_CMD_NOP 241
#define TELNET_CMD_DM 242
#define TELNET_CMD_BREAK 243
#define TELNET_CMD_WILL 251
#define TELNET_CMD_WONT 252
#define TELNET_CMD_DO 253
#define TELNET_CMD_DONT 254
#define TELNET_CMD_SB 250
#define TELNET_OPT_ECHO 1
#define TELNET_OPT_SUPPRESS_GO_AHEAD 3
#define TELNET_OPT_STATUS 5
#define TELNET_OPT_TERMINAL_TYPE 24
#define TELNET_OPT_NAWS 31
#define TELNET_OPT_TERMINAL_SPEED 32
#define TELNET_OPT_LINEMODE 34

#ifndef MSG_NOSIGNAL
#define MSG_NOSIGNAL 0
#endif

#ifndef O_NOFOLLOW
#define O_NOFOLLOW 0
#endif

#define VERSION_IP_RULE_SEPARATOR ",;\n"

typedef struct version_ip_ban_seed {
  const char *pattern;
  const char *cidr;
  const char *note;
} version_ip_ban_seed_t;

static const version_ip_ban_seed_t kVersionIpBanSeeds[] = {
    {"SSH-2.0-Go*", "34.80.0.0/12", "GCP Go spam cluster"},
    {"SSH-2.0-Go*", "34.96.0.0/14", "GCP Go spam cluster (secondary)"},
    {"SSH-2.0-paramiko_*", "52.78.0.0/15", "AWS Seoul paramiko automation"},
    {"SSH-2.0-AsyncSSH_*", "20.214.0.0/15", "Azure AsyncSSH automation"},
};

static char *host_trim_whitespace(char *text) {
  if (text == NULL) {
    return NULL;
  }

  while (*text != '\0' && isspace((unsigned char)*text)) {
    ++text;
  }

  if (*text == '\0') {
    return text;
  }

  char *end = text + strlen(text) - 1U;
  while (end > text && isspace((unsigned char)*end)) {
    *end = '\0';
    --end;
  }

  return text;
}

static bool host_version_ip_parse_pattern(const char *pattern, char *normalized, size_t normalized_len,
                                          char *original, size_t original_len, version_pattern_match_t *mode) {
  if (normalized == NULL || original == NULL || mode == NULL) {
    return false;
  }

  char working[SSH_CHATTER_VERSION_PATTERN_LEN];
  int written = snprintf(working, sizeof(working), "%s", pattern != NULL ? pattern : "");
  if (written < 0 || (size_t)written >= sizeof(working)) {
    return false;
  }

  char *trimmed = host_trim_whitespace(working);
  if (trimmed == NULL) {
    return false;
  }

  char trimmed_copy[SSH_CHATTER_VERSION_PATTERN_LEN];
  int copy_written = snprintf(trimmed_copy, sizeof(trimmed_copy), "%s", trimmed);
  if (copy_written < 0 || (size_t)copy_written >= sizeof(trimmed_copy)) {
    return false;
  }

  if (trimmed[0] == '\0') {
    return false;
  }

  size_t length = strlen(trimmed);
  bool leading_star = trimmed[0] == '*';
  bool trailing_star = (length > 0U && trimmed[length - 1U] == '*');

  if (leading_star && trailing_star && length == 1U) {
    if (original_len > 0U) {
      size_t orig_len = (size_t)copy_written;
      if (orig_len >= original_len) {
        orig_len = original_len - 1U;
      }
      memcpy(original, trimmed_copy, orig_len);
      original[orig_len] = '\0';
    }
    if (normalized_len > 0U) {
      normalized[0] = '\0';
    }
    *mode = VERSION_PATTERN_MATCH_ANY;
    return true;
  }

  if (trailing_star) {
    trimmed[length - 1U] = '\0';
    --length;
  }

  if (leading_star) {
    ++trimmed;
    length = strlen(trimmed);
  }

  if (length == 0U) {
    if (original_len > 0U) {
      size_t orig_len = (size_t)copy_written;
      if (orig_len >= original_len) {
        orig_len = original_len - 1U;
      }
      memcpy(original, trimmed_copy, orig_len);
      original[orig_len] = '\0';
    }
    if (normalized_len > 0U) {
      normalized[0] = '\0';
    }
    *mode = VERSION_PATTERN_MATCH_ANY;
    return true;
  }

  for (size_t idx = 0U; idx < length; ++idx) {
    if (trimmed[idx] == '*') {
      return false;
    }
  }

  if (normalized_len == 0U) {
    return false;
  }

  size_t normalized_length = length;
  if (normalized_length >= normalized_len) {
    normalized_length = normalized_len - 1U;
  }
  memcpy(normalized, trimmed, normalized_length);
  normalized[normalized_length] = '\0';

  if (original_len > 0U) {
    size_t orig_len = (size_t)copy_written;
    if (orig_len >= original_len) {
      orig_len = original_len - 1U;
    }
    memcpy(original, trimmed_copy, orig_len);
    original[orig_len] = '\0';
  }

  if (leading_star && trailing_star) {
    *mode = VERSION_PATTERN_MATCH_SUBSTRING;
  } else if (leading_star) {
    *mode = VERSION_PATTERN_MATCH_SUFFIX;
  } else if (trailing_star) {
    *mode = VERSION_PATTERN_MATCH_PREFIX;
  } else {
    *mode = VERSION_PATTERN_MATCH_EXACT;
  }

  return true;
}

static bool host_parse_ipv4_cidr(const char *cidr, uint32_t *network_out, uint32_t *mask_out) {
  if (cidr == NULL) {
    return false;
  }

  char buffer[SSH_CHATTER_CIDR_TEXT_LEN];
  int written = snprintf(buffer, sizeof(buffer), "%s", cidr);
  if (written < 0 || (size_t)written >= sizeof(buffer)) {
    return false;
  }

  char *slash = strchr(buffer, '/');
  if (slash == NULL) {
    return false;
  }
  *slash = '\0';

  char *prefix_str = slash + 1;
  char *prefix_end = NULL;
  long prefix_long = strtol(prefix_str, &prefix_end, 10);
  if (prefix_str == prefix_end || prefix_long < 0L || prefix_long > 32L) {
    return false;
  }

  struct in_addr address = {0};
  if (inet_pton(AF_INET, buffer, &address) != 1) {
    return false;
  }

  uint32_t prefix = (uint32_t)prefix_long;
  uint32_t mask = prefix == 0U ? 0U : (uint32_t)(0xFFFFFFFFu << (32U - prefix));
  uint32_t network = ntohl(address.s_addr) & mask;

  if (network_out != NULL) {
    *network_out = network;
  }
  if (mask_out != NULL) {
    *mask_out = mask;
  }

  return true;
}

static bool host_parse_ipv6_cidr(const char *cidr, struct in6_addr *network_out, struct in6_addr *mask_out) {
  if (cidr == NULL) {
    return false;
  }

  char buffer[SSH_CHATTER_CIDR_TEXT_LEN];
  int written = snprintf(buffer, sizeof(buffer), "%s", cidr);
  if (written < 0 || (size_t)written >= sizeof(buffer)) {
    return false;
  }

  char *slash = strchr(buffer, '/');
  if (slash == NULL) {
    return false;
  }
  *slash = '\0';

  char *prefix_str = slash + 1;
  char *prefix_end = NULL;
  long prefix_long = strtol(prefix_str, &prefix_end, 10);
  if (prefix_str == prefix_end || prefix_long < 0L || prefix_long > 128L) {
    return false;
  }

  struct in6_addr address;
  memset(&address, 0, sizeof(address));
  if (inet_pton(AF_INET6, buffer, &address) != 1) {
    return false;
  }

  struct in6_addr mask;
  memset(&mask, 0, sizeof(mask));
  int remaining = (int)prefix_long;
  for (size_t idx = 0U; idx < sizeof(mask.s6_addr); ++idx) {
    uint8_t value = 0U;
    if (remaining >= 8) {
      value = 0xFFU;
      remaining -= 8;
    } else if (remaining > 0) {
      value = (uint8_t)((uint32_t)0xFFU << (unsigned int)(8 - remaining));
      remaining = 0;
    }
    mask.s6_addr[idx] = value;
  }

  struct in6_addr network;
  memset(&network, 0, sizeof(network));
  for (size_t idx = 0U; idx < sizeof(network.s6_addr); ++idx) {
    network.s6_addr[idx] = address.s6_addr[idx] & mask.s6_addr[idx];
  }

  if (network_out != NULL) {
    *network_out = network;
  }
  if (mask_out != NULL) {
    *mask_out = mask;
  }

  return true;
}

static bool host_cidr_contains_ip(const char *cidr_text, const char *ip) {
  if (cidr_text == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  uint32_t ipv4_network = 0U;
  uint32_t ipv4_mask = 0U;
  if (host_parse_ipv4_cidr(cidr_text, &ipv4_network, &ipv4_mask)) {
    struct in_addr address = {0};
    if (inet_pton(AF_INET, ip, &address) != 1) {
      return false;
    }

    uint32_t ip_value = ntohl(address.s_addr);
    return (ip_value & ipv4_mask) == ipv4_network;
  }

  struct in6_addr ipv6_network;
  struct in6_addr ipv6_mask;
  memset(&ipv6_network, 0, sizeof(ipv6_network));
  memset(&ipv6_mask, 0, sizeof(ipv6_mask));

  if (host_parse_ipv6_cidr(cidr_text, &ipv6_network, &ipv6_mask)) {
    struct in6_addr address6;
    memset(&address6, 0, sizeof(address6));
    if (inet_pton(AF_INET6, ip, &address6) != 1) {
      return false;
    }

    for (size_t idx = 0U; idx < sizeof(address6.s6_addr); ++idx) {
      if ((address6.s6_addr[idx] & ipv6_mask.s6_addr[idx]) != ipv6_network.s6_addr[idx]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

static bool host_version_ip_rule_matches(const version_ip_ban_rule_t *rule, const char *version, const char *ip) {
  if (rule == NULL || !rule->in_use || ip == NULL || ip[0] == '\0') {
    return false;
  }

  bool version_match = false;
  switch (rule->match_mode) {
    case VERSION_PATTERN_MATCH_ANY:
      version_match = true;
      break;
    case VERSION_PATTERN_MATCH_EXACT:
      if (version != NULL) {
        version_match = strcmp(version, rule->normalized_pattern) == 0;
      }
      break;
    case VERSION_PATTERN_MATCH_PREFIX:
      if (version != NULL) {
        size_t prefix_len = strnlen(rule->normalized_pattern, sizeof(rule->normalized_pattern));
        version_match = (prefix_len > 0U && strncmp(version, rule->normalized_pattern, prefix_len) == 0);
      }
      break;
    case VERSION_PATTERN_MATCH_SUFFIX:
      if (version != NULL) {
        size_t suffix_len = strnlen(rule->normalized_pattern, sizeof(rule->normalized_pattern));
        size_t version_len = strlen(version);
        if (suffix_len > 0U && version_len >= suffix_len) {
          version_match = strncmp(version + (version_len - suffix_len), rule->normalized_pattern, suffix_len) == 0;
        }
      }
      break;
    case VERSION_PATTERN_MATCH_SUBSTRING:
      if (version != NULL && rule->normalized_pattern[0] != '\0') {
        version_match = strstr(version, rule->normalized_pattern) != NULL;
      }
      break;
    default:
      version_match = false;
      break;
  }

  if (!version_match) {
    return false;
  }

  if (!rule->is_ipv6) {
    struct in_addr address = {0};
    if (inet_pton(AF_INET, ip, &address) != 1) {
      return false;
    }
    uint32_t ip_value = ntohl(address.s_addr);
    return (ip_value & rule->ipv4_mask) == rule->ipv4_network;
  }

  struct in6_addr address6;
  memset(&address6, 0, sizeof(address6));
  if (inet_pton(AF_INET6, ip, &address6) != 1) {
    return false;
  }

  for (size_t idx = 0U; idx < sizeof(address6.s6_addr); ++idx) {
    if ((address6.s6_addr[idx] & rule->ipv6_mask.s6_addr[idx]) != rule->ipv6_network.s6_addr[idx]) {
      return false;
    }
  }

  return true;
}

static bool host_version_ip_rule_add(host_t *host, const char *pattern, const char *cidr, const char *note) {
  if (host == NULL || pattern == NULL || cidr == NULL) {
    return false;
  }

  if (host->version_ip_ban_rule_count >= SSH_CHATTER_MAX_VERSION_IP_BANS) {
    printf("[security] version/IP rule capacity reached; skipping %s @ %s\n", pattern, cidr);
    return false;
  }

  char normalized[SSH_CHATTER_VERSION_PATTERN_LEN];
  char original[SSH_CHATTER_VERSION_PATTERN_LEN];
  version_pattern_match_t match_mode = VERSION_PATTERN_MATCH_EXACT;
  if (!host_version_ip_parse_pattern(pattern, normalized, sizeof(normalized), original, sizeof(original), &match_mode)) {
    printf("[security] invalid version pattern '%s'\n", pattern);
    return false;
  }

  char cidr_copy[SSH_CHATTER_CIDR_TEXT_LEN];
  int cidr_written = snprintf(cidr_copy, sizeof(cidr_copy), "%s", cidr);
  if (cidr_written < 0 || (size_t)cidr_written >= sizeof(cidr_copy)) {
    printf("[security] invalid CIDR '%s'\n", cidr);
    return false;
  }

  char *cidr_trimmed = host_trim_whitespace(cidr_copy);
  if (cidr_trimmed == NULL || cidr_trimmed[0] == '\0') {
    printf("[security] CIDR '%s' empty after trimming\n", cidr);
    return false;
  }

  uint32_t ipv4_network = 0U;
  uint32_t ipv4_mask = 0U;
  struct in6_addr ipv6_network;
  struct in6_addr ipv6_mask;
  memset(&ipv6_network, 0, sizeof(ipv6_network));
  memset(&ipv6_mask, 0, sizeof(ipv6_mask));
  bool is_ipv6 = false;

  if (host_parse_ipv4_cidr(cidr_trimmed, &ipv4_network, &ipv4_mask)) {
    is_ipv6 = false;
  } else if (host_parse_ipv6_cidr(cidr_trimmed, &ipv6_network, &ipv6_mask)) {
    is_ipv6 = true;
  } else {
    printf("[security] failed to parse CIDR '%s'\n", cidr_trimmed);
    return false;
  }

  for (size_t idx = 0U; idx < host->version_ip_ban_rule_count; ++idx) {
    version_ip_ban_rule_t *existing = &host->version_ip_ban_rules[idx];
    if (!existing->in_use) {
      continue;
    }
    if (existing->match_mode != match_mode) {
      continue;
    }
    if (strncmp(existing->normalized_pattern, normalized, sizeof(existing->normalized_pattern)) != 0) {
      continue;
    }
    if (existing->is_ipv6 != is_ipv6) {
      continue;
    }
    bool network_match = false;
    if (!is_ipv6) {
      network_match = (existing->ipv4_network == ipv4_network && existing->ipv4_mask == ipv4_mask);
    } else {
      network_match = (memcmp(existing->ipv6_network.s6_addr, ipv6_network.s6_addr, sizeof(ipv6_network.s6_addr)) == 0) &&
                      (memcmp(existing->ipv6_mask.s6_addr, ipv6_mask.s6_addr, sizeof(ipv6_mask.s6_addr)) == 0);
    }
    if (network_match) {
      if (note != NULL && note[0] != '\0') {
        size_t note_len = strnlen(note, SSH_CHATTER_VERSION_NOTE_LEN - 1U);
        memcpy(existing->note, note, note_len);
        existing->note[note_len] = '\0';
      }
      return true;
    }
  }

  version_ip_ban_rule_t *rule = &host->version_ip_ban_rules[host->version_ip_ban_rule_count];
  memset(rule, 0, sizeof(*rule));
  rule->in_use = true;
  rule->match_mode = match_mode;
  snprintf(rule->original_pattern, sizeof(rule->original_pattern), "%s", original);
  snprintf(rule->normalized_pattern, sizeof(rule->normalized_pattern), "%s", normalized);
  snprintf(rule->cidr_text, sizeof(rule->cidr_text), "%s", cidr_trimmed);
  rule->is_ipv6 = is_ipv6;
  if (!is_ipv6) {
    rule->ipv4_network = ipv4_network;
    rule->ipv4_mask = ipv4_mask;
  } else {
    rule->ipv6_network = ipv6_network;
    rule->ipv6_mask = ipv6_mask;
  }

  if (note != NULL && note[0] != '\0') {
    size_t note_len = strnlen(note, SSH_CHATTER_VERSION_NOTE_LEN - 1U);
    memcpy(rule->note, note, note_len);
    rule->note[note_len] = '\0';
  } else {
    rule->note[0] = '\0';
  }

  host->version_ip_ban_rule_count += 1U;

  const char *note_display = rule->note[0] != '\0' ? rule->note : "version/IP policy";
  const char *pattern_display = rule->original_pattern[0] != '\0' ? rule->original_pattern : "*";
  printf("[security] loaded version/IP ban rule: %s @ %s (%s)\n", pattern_display, rule->cidr_text, note_display);

  return true;
}

static void host_version_ip_rules_load_env(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *env = getenv("CHATTER_VERSION_IP_BANS");
  if (env == NULL || env[0] == '\0') {
    return;
  }

  char *copy = strdup(env);
  if (copy == NULL) {
    return;
  }

  char *context = NULL;
  for (char *token = strtok_r(copy, VERSION_IP_RULE_SEPARATOR, &context); token != NULL;
       token = strtok_r(NULL, VERSION_IP_RULE_SEPARATOR, &context)) {
    char *trimmed = host_trim_whitespace(token);
    if (trimmed == NULL || trimmed[0] == '\0') {
      continue;
    }

    char *note_part = NULL;
    char *hash = strchr(trimmed, '#');
    if (hash != NULL) {
      *hash = '\0';
      note_part = host_trim_whitespace(hash + 1);
    }

    char *separator = strchr(trimmed, '@');
    if (separator == NULL) {
      printf("[security] ignoring malformed version/IP rule '%s'\n", trimmed);
      continue;
    }

    *separator = '\0';
    char *pattern = host_trim_whitespace(trimmed);
    char *cidr = host_trim_whitespace(separator + 1);
    if (pattern == NULL || cidr == NULL || pattern[0] == '\0' || cidr[0] == '\0') {
      printf("[security] ignoring malformed version/IP rule entry\n");
      continue;
    }

    const char *note = (note_part != NULL && note_part[0] != '\0') ? note_part : "custom rule";
    if (!host_version_ip_rule_add(host, pattern, cidr, note)) {
      printf("[security] failed to register version/IP rule from environment: %s @ %s\n", pattern, cidr);
    }
  }

}

static bool host_version_ip_should_ban(host_t *host, const char *version, const char *ip,
                                       const version_ip_ban_rule_t **matched_rule) {
  if (matched_rule != NULL) {
    *matched_rule = NULL;
  }

  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < host->version_ip_ban_rule_count; ++idx) {
    const version_ip_ban_rule_t *rule = &host->version_ip_ban_rules[idx];
    if (!rule->in_use) {
      continue;
    }
    if (host_version_ip_rule_matches(rule, version, ip)) {
      if (matched_rule != NULL) {
        *matched_rule = rule;
      }
      return true;
    }
  }

  return false;
}

static void host_version_ip_rules_init(host_t *host) {
  if (host == NULL) {
    return;
  }

  host->version_ip_ban_rule_count = 0U;
  memset(host->version_ip_ban_rules, 0, sizeof(host->version_ip_ban_rules));

  for (size_t idx = 0U; idx < (sizeof(kVersionIpBanSeeds) / sizeof(kVersionIpBanSeeds[0])); ++idx) {
    const version_ip_ban_seed_t *seed = &kVersionIpBanSeeds[idx];
    (void)host_version_ip_rule_add(host, seed->pattern, seed->cidr, seed->note);
  }

  host_version_ip_rules_load_env(host);
}

#ifndef O_NOFOLLOW
#define O_NOFOLLOW 0
#endif

static const char kTranslationQuotaNotice[] =
    "⚠️ Translation quota exhausted. Translation features are temporarily disabled.";
static const char kTranslationQuotaSystemMessage[] =
    "Translation quota exhausted. Translation has been disabled. Try again later.";

static const char *const kSessionCommandNames[] = {
    "asciiart",      "audio",       "ban",          "banlist",     "bbs",
    "birthday",      "block",       "captcha",      "chat",         "chat-spacing",
    "color",         "connected",   "date",         "delete-msg",   "elect",
    "eliza",         "eliza-chat",  "exit",         "files",        "game",
    "gemini",        "gemini-unfreeze","getos",      "grant",        "help",
    "history",
    "advanced",      "image",       "kick",        "mode",         "motd",
    "nick",          "os",          "pair",        "palette",     "pardon",
    "pm",
    "poke",          "poll",        "reply",       "revoke",       "rss",
    "search",        "set-target-lang","set-trans-lang","set-ui-lang","showstatus",
    "soulmate",      "status",      "suspend!",    "systemcolor",  "today",
    "translate",
    "translate-scope","unblock",    "users",        "video",        "vote",
    "vote-single",   "weather",
};
#define SSH_CHATTER_COMMAND_COUNT (sizeof(kSessionCommandNames) / sizeof(kSessionCommandNames[0]))

typedef enum session_help_entry_kind {
  SESSION_HELP_ENTRY_COMMAND = 0,
  SESSION_HELP_ENTRY_FORMATTED,
  SESSION_HELP_ENTRY_TEXT,
} session_help_entry_kind_t;

#define SESSION_HELP_TEMPLATE_ARG_LIMIT 8U

typedef enum session_help_template_arg_kind {
  SESSION_HELP_TEMPLATE_ARG_PREFIX = 0,
  SESSION_HELP_TEMPLATE_ARG_ASCIIART_TERMINATOR,
  SESSION_HELP_TEMPLATE_ARG_BBS_TERMINATOR,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_REPLY,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_GOOD,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_SAD,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_WTF,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_COOL,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_ANGRY,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_CHECKED,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_LOVE,
  SESSION_HELP_TEMPLATE_ARG_COMMAND_BBS,
} session_help_template_arg_kind_t;

typedef struct session_help_entry {
  session_help_entry_kind_t kind;
  const char *label;
  const char *description[SESSION_UI_LANGUAGE_COUNT];
  const char *label_translations[SESSION_UI_LANGUAGE_COUNT];
  size_t label_arg_count;
  session_help_template_arg_kind_t label_args[SESSION_HELP_TEMPLATE_ARG_LIMIT];
  size_t description_arg_count;
  session_help_template_arg_kind_t description_args[SESSION_HELP_TEMPLATE_ARG_LIMIT];
} session_help_entry_t;

typedef struct session_command_alias {
  const char *canonical;
  const char *localized[SESSION_UI_LANGUAGE_COUNT];
} session_command_alias_t;

typedef struct session_ui_locale {
  session_ui_language_t language;
  const char *code;
  const char *help_title;
  const char *help_hint_extra;
  const char *help_scroll_hint;
  const char *help_regular_hint;
  const char *help_extra_title;
  const char *help_extra_hint;
  const char *help_operator_title;
  const char *welcome_help_hint;
  const char *welcome_motd_hint;
  const char *chat_spacing_usage;
  const char *chat_spacing_immediate;
  const char *chat_spacing_single;
  const char *chat_spacing_multiple;
  const char *set_ui_lang_usage;
  const char *set_ui_lang_success;
  const char *set_ui_lang_invalid;
  const char *mode_status_format;
  const char *mode_label_chat;
  const char *mode_label_command;
  const char *mode_explain_chat;
  const char *mode_explain_command;
  const char *mode_already_chat;
  const char *mode_already_command;
  const char *mode_enabled_chat;
  const char *mode_enabled_command;
  const char *mode_usage;
  const char *unknown_command;
} session_ui_locale_t;

static const char *const kSessionUiLanguageCodes[SESSION_UI_LANGUAGE_COUNT] = {
    "en",
    "ko",
    "jp",
    "zh",
    "ru",
};

static const char *const kSessionUiLanguageNames[SESSION_UI_LANGUAGE_COUNT][SESSION_UI_LANGUAGE_COUNT] = {
    [SESSION_UI_LANGUAGE_EN] = {"English", "Korean", "Japanese", "Chinese", "Russian"},
    [SESSION_UI_LANGUAGE_KO] = {"영어", "한국어", "일본어", "중국어", "러시아어"},
    [SESSION_UI_LANGUAGE_JP] = {"英語", "韓国語", "日本語", "中国語", "ロシア語"},
    [SESSION_UI_LANGUAGE_ZH] = {"英语", "韩语", "日语", "中文", "俄语"},
    [SESSION_UI_LANGUAGE_RU] = {"английский", "корейский", "японский", "китайский", "русский"},
};

static const session_ui_locale_t kSessionUiLocales[SESSION_UI_LANGUAGE_COUNT] = {
    {
        .language = SESSION_UI_LANGUAGE_EN,
        .code = "en",
        .help_title = "Essential commands:",
        .help_hint_extra = "See %sadvanced for optional commands.",
        .help_scroll_hint = "Use Up/Down arrows to scroll chat or command history.",
        .help_regular_hint = "Regular messages are shared with everyone.",
        .help_extra_title = "Extended commands:",
        .help_extra_hint = "Return to %shelp for essentials.",
        .help_operator_title = "Operator commands:",
        .welcome_help_hint = "Use %shelp to view the manual.",
        .welcome_motd_hint = "Use %smotd to read the information.",
        .chat_spacing_usage = "Usage: %schat-spacing <0-5>",
        .chat_spacing_immediate =
            "Translation captions will appear immediately without reserving extra blank lines.",
        .chat_spacing_single =
            "Translation captions will reserve 1 blank line before appearing in chat threads.",
        .chat_spacing_multiple =
            "Translation captions will reserve %s blank lines before appearing in chat threads.",
        .set_ui_lang_usage = "Usage: %sset-ui-lang <ko|en|jp|zh|ru>",
        .set_ui_lang_success = "UI language set to %s. Use %shelp to review commands.",
        .set_ui_lang_invalid = "Unsupported language. Use one of: ko, en, jp, zh, ru.",
        .mode_status_format = "Current input mode: %s.",
        .mode_label_chat = "chat",
        .mode_label_command = "command",
        .mode_explain_chat = "Chat mode: send messages normally. Prefix commands with %s.",
        .mode_explain_command =
            "Command mode: type commands without a prefix, use UpArrow/DownArrow for history, Tab for completion.",
        .mode_already_chat = "Already in chat mode. Commands require the %s prefix.",
        .mode_already_command =
            "Command mode already active. Enter commands without a prefix, use UpArrow/DownArrow for history, Tab to autocomplete.",
        .mode_enabled_chat = "Chat mode enabled. Commands once again require the %s prefix.",
        .mode_enabled_command =
            "Command mode enabled. Enter commands without a prefix; use UpArrow/DownArrow for history and Tab for completion.",
        .mode_usage = "Usage: %smode <chat|command|toggle>",
        .unknown_command = "Unknown command. Type %shelp for help.",
    },
    {
        .language = SESSION_UI_LANGUAGE_KO,
        .code = "ko",
        .help_title = "필수 명령:",
        .help_hint_extra = "%sadvanced에서 선택 및 운영자 명령을 확인합니다.",
        .help_scroll_hint = "위/아래 화살표로 채팅이나 명령 기록을 살펴볼 수 있습니다.",
        .help_regular_hint = "일반 메시지는 모두에게 공유됩니다.",
        .help_extra_title = "확장 명령:",
        .help_extra_hint = "핵심 목록은 %shelp에서 다시 볼 수 있습니다.",
        .help_operator_title = "운영자 명령:",
        .welcome_help_hint = "%shelp 명령으로 도움말을 확인하세요.",
        .welcome_motd_hint = "%smotd 명령으로 안내를 읽을 수 있습니다.",
        .chat_spacing_usage = "사용법: %schat-spacing <0-5>",
        .chat_spacing_immediate = "번역 자막이 빈 줄을 예약하지 않고 즉시 표시됩니다.",
        .chat_spacing_single = "번역 자막이 표시되기 전에 빈 줄 1줄을 예약합니다.",
        .chat_spacing_multiple = "번역 자막이 표시되기 전에 빈 줄 %s줄을 예약합니다.",
        .set_ui_lang_usage = "사용법: %sset-ui-lang <ko|en|jp|zh|ru>",
        .set_ui_lang_success = "UI 언어를 %s로 설정했습니다. %shelp 명령으로 목록을 다시 확인하세요.",
        .set_ui_lang_invalid = "지원하지 않는 언어입니다. ko, en, jp, zh, ru 중에서 선택하세요.",
        .mode_status_format = "현재 입력 모드: %s.",
        .mode_label_chat = "채팅",
        .mode_label_command = "명령",
        .mode_explain_chat = "채팅 모드: 일반 메시지를 보내고, 명령은 %s 접두사를 붙여 입력하세요.",
        .mode_explain_command =
            "명령 모드: 접두사 없이 명령을 입력하고, 위/아래 화살표로 기록을 탐색하며 Tab으로 자동완성하세요.",
        .mode_already_chat = "이미 채팅 모드입니다. 명령은 %s 접두사가 필요합니다.",
        .mode_already_command = "이미 명령 모드입니다. 접두사 없이 입력하고, 위/아래 화살표와 Tab을 활용하세요.",
        .mode_enabled_chat = "채팅 모드가 활성화되었습니다. 명령은 다시 %s 접두사가 필요합니다.",
        .mode_enabled_command = "명령 모드가 활성화되었습니다. 접두사 없이 입력하고, 위/아래 화살표와 Tab을 사용하세요.",
        .mode_usage = "사용법: %smode <chat|command|toggle>",
        .unknown_command = "알 수 없는 명령입니다. 도움말은 %shelp에서 확인하세요.",
    },
    {
        .language = SESSION_UI_LANGUAGE_JP,
        .code = "jp",
        .help_title = "基本コマンド:",
        .help_hint_extra = "追加コマンドは %sadvanced で確認できます。",
        .help_scroll_hint = "上下の矢印でチャットやコマンド履歴をたどれます。",
        .help_regular_hint = "通常のメッセージは全員に共有されます。",
        .help_extra_title = "拡張コマンド:",
        .help_extra_hint = "基本一覧に戻るには %shelp を実行してください。",
        .help_operator_title = "オペレーター用コマンド:",
        .welcome_help_hint = "%shelp でヘルプを表示できます。",
        .welcome_motd_hint = "%smotd でお知らせを確認できます。",
        .chat_spacing_usage = "使い方: %schat-spacing <0-5>",
        .chat_spacing_immediate = "翻訳字幕は空行を確保せずすぐに表示されます。",
        .chat_spacing_single = "翻訳字幕は表示前に空行を 1 行確保します。",
        .chat_spacing_multiple = "翻訳字幕は表示前に空行を %s 行確保します。",
        .set_ui_lang_usage = "使い方: %sset-ui-lang <ko|en|jp|zh|ru>",
        .set_ui_lang_success = "UI 言語を %s に設定しました。%shelp でコマンドを再確認してください。",
        .set_ui_lang_invalid = "対応していない言語です。ko, en, jp, zh, ru から選んでください。",
        .mode_status_format = "現在の入力モード: %s。",
        .mode_label_chat = "チャット",
        .mode_label_command = "コマンド",
        .mode_explain_chat = "チャットモード: 通常通りメッセージを送り、コマンドは %s を付けて入力します。",
        .mode_explain_command =
            "コマンドモード: 接頭辞なしで入力し、上下矢印で履歴を、Tab で補完を利用できます。",
        .mode_already_chat = "すでにチャットモードです。コマンドには %s を付けてください。",
        .mode_already_command = "すでにコマンドモードです。接頭辞なしで入力し、上下矢印と Tab を使ってください。",
        .mode_enabled_chat = "チャットモードを有効にしました。コマンドには再び %s が必要です。",
        .mode_enabled_command = "コマンドモードを有効にしました。接頭辞なしで入力し、上下矢印と Tab を使ってください。",
        .mode_usage = "使い方: %smode <chat|command|toggle>",
        .unknown_command = "不明なコマンドです。%shelp で確認してください。",
    },
    {
        .language = SESSION_UI_LANGUAGE_ZH,
        .code = "zh",
        .help_title = "核心命令：",
        .help_hint_extra = "更多命令请查看 %sadvanced。",
        .help_scroll_hint = "使用上下方向键查看聊天或命令历史。",
        .help_regular_hint = "普通消息会分享给所有人。",
        .help_extra_title = "扩展命令：",
        .help_extra_hint = "返回核心列表请使用 %shelp。",
        .help_operator_title = "管理员命令：",
        .welcome_help_hint = "使用 %shelp 查看帮助。",
        .welcome_motd_hint = "使用 %smotd 阅读公告。",
        .chat_spacing_usage = "用法：%schat-spacing <0-5>",
        .chat_spacing_immediate = "翻译字幕会立即显示，不再预留空行。",
        .chat_spacing_single = "翻译字幕在显示前会预留 1 行空白。",
        .chat_spacing_multiple = "翻译字幕在显示前会预留 %s 行空白。",
        .set_ui_lang_usage = "用法：%sset-ui-lang <ko|en|jp|zh|ru>",
        .set_ui_lang_success = "界面语言已切换为 %s。可用 %shelp 重新查看命令。",
        .set_ui_lang_invalid = "不支持的语言，请选择 ko、en、jp、zh、ru。",
        .mode_status_format = "当前输入模式：%s。",
        .mode_label_chat = "聊天",
        .mode_label_command = "命令",
        .mode_explain_chat = "聊天模式：正常发送消息，命令需加上 %s 前缀。",
        .mode_explain_command =
            "命令模式：直接输入命令，不需要前缀；用上下方向键查看历史，Tab 自动补全。",
        .mode_already_chat = "已经是聊天模式。命令需要 %s 前缀。",
        .mode_already_command = "已经是命令模式。无需前缀，使用上下方向键和 Tab。",
        .mode_enabled_chat = "聊天模式已启用。命令重新需要 %s 前缀。",
        .mode_enabled_command = "命令模式已启用。无需前缀，可用上下方向键和 Tab。",
        .mode_usage = "用法：%smode <chat|command|toggle>",
        .unknown_command = "未知命令。请使用 %shelp 查看帮助。",
    },
    {
        .language = SESSION_UI_LANGUAGE_RU,
        .code = "ru",
        .help_title = "Основные команды:",
        .help_hint_extra = "Дополнительные команды смотрите в %sadvanced.",
        .help_scroll_hint = "Стрелки вверх/вниз листают чат или историю команд.",
        .help_regular_hint = "Обычные сообщения видны всем.",
        .help_extra_title = "Дополнительные команды:",
        .help_extra_hint = "К основному списку вернёт %shelp.",
        .help_operator_title = "Команды оператора:",
        .welcome_help_hint = "Команду %shelp используйте для справки.",
        .welcome_motd_hint = "%smotd покажет объявление.",
        .chat_spacing_usage = "Использование: %schat-spacing <0-5>",
        .chat_spacing_immediate = "Подписи перевода будут появляться сразу, без запасных пустых строк.",
        .chat_spacing_single = "Подписи перевода перед выводом резервируют 1 пустую строку.",
        .chat_spacing_multiple = "Подписи перевода перед выводом резервируют %s пустых строк.",
        .set_ui_lang_usage = "Использование: %sset-ui-lang <ko|en|jp|zh|ru>",
        .set_ui_lang_success = "Язык интерфейса переключён на %s. Команды можно пересмотреть через %shelp.",
        .set_ui_lang_invalid = "Этот язык не поддерживается. Выберите один из: ko, en, jp, zh, ru.",
        .mode_status_format = "Текущий режим ввода: %s.",
        .mode_label_chat = "чат",
        .mode_label_command = "команды",
        .mode_explain_chat = "Режим чата: отправляйте сообщения, а команды вводите с префиксом %s.",
        .mode_explain_command =
            "Режим команд: вводите без префикса, используйте стрелки вверх/вниз для истории и Tab для автодополнения.",
        .mode_already_chat = "Вы уже в режиме чата. Командам нужен префикс %s.",
        .mode_already_command = "Режим команд уже активен. Вводите без префикса, пользуйтесь стрелками и Tab.",
        .mode_enabled_chat = "Включён режим чата. Командам снова требуется префикс %s.",
        .mode_enabled_command = "Включён режим команд. Вводите без префикса, применяйте стрелки и Tab.",
        .mode_usage = "Использование: %smode <chat|command|toggle>",
        .unknown_command = "Неизвестная команда. Подсказка — %shelp.",
    },
};

static const char *const kSessionAsciiartTerminators[SESSION_UI_LANGUAGE_COUNT] = {
    [SESSION_UI_LANGUAGE_EN] = SSH_CHATTER_ASCIIART_TERMINATOR_EN,
    [SESSION_UI_LANGUAGE_KO] = ">/__그림_끝>",
    [SESSION_UI_LANGUAGE_JP] = ">/__アート_終了>",
    [SESSION_UI_LANGUAGE_ZH] = ">/__图像_结束>",
    [SESSION_UI_LANGUAGE_RU] = ">/__АРТ_КОНЕЦ>",
};

static const char *const kSessionBbsTerminators[SESSION_UI_LANGUAGE_COUNT] = {
    [SESSION_UI_LANGUAGE_EN] = SSH_CHATTER_BBS_TERMINATOR_EN,
    [SESSION_UI_LANGUAGE_KO] = ">/__게시판_끝>",
    [SESSION_UI_LANGUAGE_JP] = ">/__掲示板_終了>",
    [SESSION_UI_LANGUAGE_ZH] = ">/__公告板_结束>",
    [SESSION_UI_LANGUAGE_RU] = ">/__ДОСКА_КОНЕЦ>",
};

static const session_command_alias_t kSessionCommandAliases[] = {
    {
        .canonical = "/reply",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/답장",
            [SESSION_UI_LANGUAGE_JP] = "/返信",
            [SESSION_UI_LANGUAGE_ZH] = "/回复",
            [SESSION_UI_LANGUAGE_RU] = "/ответ",
        },
    },
    {
        .canonical = "/good",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/좋아요",
            [SESSION_UI_LANGUAGE_JP] = "/いいね",
            [SESSION_UI_LANGUAGE_ZH] = "/点赞",
            [SESSION_UI_LANGUAGE_RU] = "/класс",
        },
    },
    {
        .canonical = "/sad",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/슬퍼요",
            [SESSION_UI_LANGUAGE_JP] = "/かなしい",
            [SESSION_UI_LANGUAGE_ZH] = "/难过",
            [SESSION_UI_LANGUAGE_RU] = "/грусть",
        },
    },
    {
        .canonical = "/wtf",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/어쩌라고",
            [SESSION_UI_LANGUAGE_JP] = "/なんだと",
            [SESSION_UI_LANGUAGE_ZH] = "/搞什么",
            [SESSION_UI_LANGUAGE_RU] = "/чтоэто",
        },
    },
    {
        .canonical = "/cool",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/멋져요",
            [SESSION_UI_LANGUAGE_JP] = "/クール",
            [SESSION_UI_LANGUAGE_ZH] = "/酷",
            [SESSION_UI_LANGUAGE_RU] = "/круто",
        },
    },
    {
        .canonical = "/angry",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/화나요",
            [SESSION_UI_LANGUAGE_JP] = "/怒り",
            [SESSION_UI_LANGUAGE_ZH] = "/生气",
            [SESSION_UI_LANGUAGE_RU] = "/злой",
        },
    },
    {
        .canonical = "/checked",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/확인",
            [SESSION_UI_LANGUAGE_JP] = "/確認済み",
            [SESSION_UI_LANGUAGE_ZH] = "/已检查",
            [SESSION_UI_LANGUAGE_RU] = "/проверено",
        },
    },
    {
        .canonical = "/love",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/사랑해요",
            [SESSION_UI_LANGUAGE_JP] = "/愛",
            [SESSION_UI_LANGUAGE_ZH] = "/爱",
            [SESSION_UI_LANGUAGE_RU] = "/любовь",
        },
    },
    {
        .canonical = "/bbs",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/게시판",
            [SESSION_UI_LANGUAGE_JP] = "/掲示板",
            [SESSION_UI_LANGUAGE_ZH] = "/公告板",
            [SESSION_UI_LANGUAGE_RU] = "/доска",
        },
    },
    {
        .canonical = "/vote",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/투표",
        },
    },
    {
        .canonical = "/poll",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/전역투표",
        },
    },
    {
        .canonical = "/vote-single",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/단일투표",
        },
    },
    {
        .canonical = "/elect",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/선택",
        },
    },
    {
        .canonical = "/eliza-chat",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/엘리자채팅",
        },
    },
    {
        .canonical = "/banname",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/이름차단",
        },
    },
    {
        .canonical = "/delete-msg",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/메시지삭제",
        },
    },
    {
        .canonical = "/search",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/검색",
            [SESSION_UI_LANGUAGE_JP] = "/検索",
            [SESSION_UI_LANGUAGE_ZH] = "/搜索",
            [SESSION_UI_LANGUAGE_RU] = "/поиск",
        },
    },
    {
        .canonical = "/image",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/이미지",
            [SESSION_UI_LANGUAGE_JP] = "/画像",
            [SESSION_UI_LANGUAGE_ZH] = "/图片",
            [SESSION_UI_LANGUAGE_RU] = "/изображение",
        },
    },
    {
        .canonical = "/video",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/영상",
            [SESSION_UI_LANGUAGE_JP] = "/動画",
            [SESSION_UI_LANGUAGE_ZH] = "/视频",
            [SESSION_UI_LANGUAGE_RU] = "/видео",
        },
    },
    {
        .canonical = "/audio",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/오디오",
            [SESSION_UI_LANGUAGE_JP] = "/音声",
            [SESSION_UI_LANGUAGE_ZH] = "/音频",
            [SESSION_UI_LANGUAGE_RU] = "/аудио",
        },
    },
    {
        .canonical = "/files",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/파일",
            [SESSION_UI_LANGUAGE_JP] = "/ファイル",
            [SESSION_UI_LANGUAGE_ZH] = "/文件",
            [SESSION_UI_LANGUAGE_RU] = "/файлы",
        },
    },
    {
        .canonical = "/mail",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/메일",
            [SESSION_UI_LANGUAGE_JP] = "/メール",
            [SESSION_UI_LANGUAGE_ZH] = "/邮件",
            [SESSION_UI_LANGUAGE_RU] = "/почта",
        },
    },
    {
        .canonical = "/profilepic",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/프로필사진",
            [SESSION_UI_LANGUAGE_JP] = "/プロフィール写真",
            [SESSION_UI_LANGUAGE_ZH] = "/头像",
            [SESSION_UI_LANGUAGE_RU] = "/аватар",
        },
    },
    {
        .canonical = "/asciiart",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/아스키아트",
            [SESSION_UI_LANGUAGE_JP] = "/アスキーアート",
            [SESSION_UI_LANGUAGE_ZH] = "/艺术",
            [SESSION_UI_LANGUAGE_RU] = "/ASCIIарт",
        },
    },
    {
        .canonical = "/game",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/게임",
            [SESSION_UI_LANGUAGE_JP] = "/ゲーム",
            [SESSION_UI_LANGUAGE_ZH] = "/游戏",
            [SESSION_UI_LANGUAGE_RU] = "/игра",
        },
    },
    {
        .canonical = "/color",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/색상",
            [SESSION_UI_LANGUAGE_JP] = "/色",
            [SESSION_UI_LANGUAGE_ZH] = "/颜色",
            [SESSION_UI_LANGUAGE_RU] = "/цвет",
        },
    },
    {
        .canonical = "/systemcolor",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/시스템색상",
            [SESSION_UI_LANGUAGE_JP] = "/システムカラー",
            [SESSION_UI_LANGUAGE_ZH] = "/系统颜色",
            [SESSION_UI_LANGUAGE_RU] = "/системныйцвет",
        },
    },
    {
        .canonical = "/set-trans-lang",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/번역언어설정",
            [SESSION_UI_LANGUAGE_JP] = "/翻訳言語設定",
            [SESSION_UI_LANGUAGE_ZH] = "/设置翻译语言",
            [SESSION_UI_LANGUAGE_RU] = "/установить-язык-перевода",
        },
    },
    {
        .canonical = "/set-target-lang",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/대상언어설정",
            [SESSION_UI_LANGUAGE_JP] = "/ターゲット言語設定",
            [SESSION_UI_LANGUAGE_ZH] = "/设置目标语言",
            [SESSION_UI_LANGUAGE_RU] = "/установить-целевой-язык",
        },
    },
    {
        .canonical = "/set-ui-lang",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/UI언어설정",
            [SESSION_UI_LANGUAGE_JP] = "/UI言語設定",
            [SESSION_UI_LANGUAGE_ZH] = "/界面语言设置",
            [SESSION_UI_LANGUAGE_RU] = "/язык-интерфейса",
        },
    },
    {
        .canonical = "/grant",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/권한부여",
        },
    },
    {
        .canonical = "/revoke",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/권한해제",
        },
    },
    {
        .canonical = "/poke",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/호출",
            [SESSION_UI_LANGUAGE_JP] = "/つつく",
            [SESSION_UI_LANGUAGE_ZH] = "/戳",
            [SESSION_UI_LANGUAGE_RU] = "/пинг",
        },
    },
    {
        .canonical = "/weather",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/날씨",
            [SESSION_UI_LANGUAGE_JP] = "/天気",
            [SESSION_UI_LANGUAGE_ZH] = "/天气",
            [SESSION_UI_LANGUAGE_RU] = "/погода",
        },
    },
    {
        .canonical = "/translate",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/번역",
            [SESSION_UI_LANGUAGE_JP] = "/翻訳",
            [SESSION_UI_LANGUAGE_ZH] = "/翻译",
            [SESSION_UI_LANGUAGE_RU] = "/перевод",
        },
    },
    {
        .canonical = "/translate-scope",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/번역범위",
            [SESSION_UI_LANGUAGE_JP] = "/翻訳範囲",
            [SESSION_UI_LANGUAGE_ZH] = "/翻译范围",
            [SESSION_UI_LANGUAGE_RU] = "/область-перевода",
        },
    },
    {
        .canonical = "/chat-spacing",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/채팅간격",
            [SESSION_UI_LANGUAGE_JP] = "/チャット間隔",
            [SESSION_UI_LANGUAGE_ZH] = "/聊天间距",
            [SESSION_UI_LANGUAGE_RU] = "/интервал-чата",
        },
    },
    {
        .canonical = "/palette",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/팔레트",
            [SESSION_UI_LANGUAGE_JP] = "/パレット",
            [SESSION_UI_LANGUAGE_ZH] = "/调色板",
            [SESSION_UI_LANGUAGE_RU] = "/палитра",
        },
    },
    {
        .canonical = "/today",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/오늘",
            [SESSION_UI_LANGUAGE_JP] = "/今日",
            [SESSION_UI_LANGUAGE_ZH] = "/今日",
            [SESSION_UI_LANGUAGE_RU] = "/сегодня",
        },
    },
    {
        .canonical = "/date",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/날짜",
            [SESSION_UI_LANGUAGE_JP] = "/日付",
            [SESSION_UI_LANGUAGE_ZH] = "/日期",
            [SESSION_UI_LANGUAGE_RU] = "/дата",
        },
    },
    {
        .canonical = "/os",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/운영체제",
            [SESSION_UI_LANGUAGE_JP] = "/OS",
            [SESSION_UI_LANGUAGE_ZH] = "/操作系统",
            [SESSION_UI_LANGUAGE_RU] = "/ОС",
        },
    },
    {
        .canonical = "/getos",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/운영체제확인",
            [SESSION_UI_LANGUAGE_JP] = "/OS取得",
            [SESSION_UI_LANGUAGE_ZH] = "/获取操作系统",
            [SESSION_UI_LANGUAGE_RU] = "/получить-ОС",
        },
    },
    {
        .canonical = "/birthday",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/생일",
            [SESSION_UI_LANGUAGE_JP] = "/誕生日",
            [SESSION_UI_LANGUAGE_ZH] = "/生日",
            [SESSION_UI_LANGUAGE_RU] = "/деньрождения",
        },
    },
    {
        .canonical = "/soulmate",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/영혼의단짝",
            [SESSION_UI_LANGUAGE_JP] = "/ソウルメイト",
            [SESSION_UI_LANGUAGE_ZH] = "/灵魂伴侣",
            [SESSION_UI_LANGUAGE_RU] = "/родственнаядуша",
        },
    },
    {
        .canonical = "/pair",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/짝",
            [SESSION_UI_LANGUAGE_JP] = "/ペア",
            [SESSION_UI_LANGUAGE_ZH] = "/配对",
            [SESSION_UI_LANGUAGE_RU] = "/пара",
        },
    },
    {
        .canonical = "/connected",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/접속자",
            [SESSION_UI_LANGUAGE_JP] = "/接続中",
            [SESSION_UI_LANGUAGE_ZH] = "/在线",
            [SESSION_UI_LANGUAGE_RU] = "/подключенные",
        },
    },
    {
        .canonical = "/users",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/접속자수",
        },
    },
    {
        .canonical = "/alpha-centauri-landers",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/알파센타우리착륙자",
        },
    },
    {
        .canonical = "/block",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/차단",
        },
    },
    {
        .canonical = "/unblock",
        .localized = {
            [SESSION_UI_LANGUAGE_KO] = "/차단해제",
        },
    },
};

static const size_t kSessionCommandAliasCount =
    sizeof(kSessionCommandAliases) / sizeof(kSessionCommandAliases[0]);

typedef struct session_bbs_subcommand_alias {
  const char *canonical;
  const char *localized[SESSION_UI_LANGUAGE_COUNT];
} session_bbs_subcommand_alias_t;

static const session_bbs_subcommand_alias_t kSessionBbsSubcommands[] = {
    {
        .canonical = "list",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "list",
            [SESSION_UI_LANGUAGE_KO] = "목록",
            [SESSION_UI_LANGUAGE_JP] = "一覧",
            [SESSION_UI_LANGUAGE_ZH] = "列表",
            [SESSION_UI_LANGUAGE_RU] = "список",
        },
    },
    {
        .canonical = "read",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "read",
            [SESSION_UI_LANGUAGE_KO] = "읽기",
            [SESSION_UI_LANGUAGE_JP] = "閲覧",
            [SESSION_UI_LANGUAGE_ZH] = "阅读",
            [SESSION_UI_LANGUAGE_RU] = "читать",
        },
    },
    {
        .canonical = "topic",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "topic",
            [SESSION_UI_LANGUAGE_KO] = "주제",
            [SESSION_UI_LANGUAGE_JP] = "トピック",
            [SESSION_UI_LANGUAGE_ZH] = "主题",
            [SESSION_UI_LANGUAGE_RU] = "тема",
        },
    },
    {
        .canonical = "post",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "post",
            [SESSION_UI_LANGUAGE_KO] = "게시",
            [SESSION_UI_LANGUAGE_JP] = "投稿",
            [SESSION_UI_LANGUAGE_ZH] = "发布",
            [SESSION_UI_LANGUAGE_RU] = "пост",
        },
    },
    {
        .canonical = "edit",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "edit",
            [SESSION_UI_LANGUAGE_KO] = "수정",
            [SESSION_UI_LANGUAGE_JP] = "編集",
            [SESSION_UI_LANGUAGE_ZH] = "编辑",
            [SESSION_UI_LANGUAGE_RU] = "редакт",
        },
    },
    {
        .canonical = "comment",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "comment",
            [SESSION_UI_LANGUAGE_KO] = "댓글",
            [SESSION_UI_LANGUAGE_JP] = "コメント",
            [SESSION_UI_LANGUAGE_ZH] = "评论",
            [SESSION_UI_LANGUAGE_RU] = "коммент",
        },
    },
    {
        .canonical = "regen",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "regen",
            [SESSION_UI_LANGUAGE_KO] = "갱신",
            [SESSION_UI_LANGUAGE_JP] = "再掲",
            [SESSION_UI_LANGUAGE_ZH] = "置顶",
            [SESSION_UI_LANGUAGE_RU] = "поднять",
        },
    },
    {
        .canonical = "delete",
        .localized = {
            [SESSION_UI_LANGUAGE_EN] = "delete",
            [SESSION_UI_LANGUAGE_KO] = "삭제",
            [SESSION_UI_LANGUAGE_JP] = "削除",
            [SESSION_UI_LANGUAGE_ZH] = "删除",
            [SESSION_UI_LANGUAGE_RU] = "удалить",
        },
    },
};

static const size_t kSessionBbsSubcommandCount =
    sizeof(kSessionBbsSubcommands) / sizeof(kSessionBbsSubcommands[0]);

static const session_help_entry_t kSessionHelpEssential[] = {
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "help",
        .description = {
            "Show essential chat and BBS commands.",
            "채팅과 게시판에 필요한 핵심 명령을 보여줍니다.",
            "チャットと掲示板で必要な基本コマンドを表示します。",
            "显示聊天与公告板所需的核心命令。",
            "Показать основные команды для чата и доски объявлений.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "advanced",
        .description = {
            "List optional and operator commands.",
            "선택 및 운영자 명령을 확인합니다.",
            "補助および運営向けコマンドを一覧表示します。",
            "列出可选命令和管理员命令。",
            "Показать дополнительные и операторские команды.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "exit",
        .description = {
            "Leave the chat.",
            "채팅방을 나갑니다.",
            "チャットを退出します。",
            "离开聊天。",
            "Выйти из чата.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "nick <name>",
        .description = {
            "Change your display name.",
            "표시 이름을 변경합니다.",
            "表示名を変更します。",
            "更改显示名称。",
            "Изменить отображаемое имя.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "닉네임 <이름>",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "pm <username> <message>",
        .description = {
            "Send a private message.",
            "개인 메시지를 보냅니다.",
            "プライベートメッセージを送信します。",
            "发送私信。",
            "Отправить личное сообщение.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "motd",
        .description = {
            "View the message of the day.",
            "공지(MOTD)를 확인합니다.",
            "MOTD（お知らせ）を表示します。",
            "查看每日公告 (MOTD)。",
            "Показать сообщение дня.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "history [count]",
        .description = {
            "Review your recent commands.",
            "최근 실행한 명령을 확인합니다.",
            "最近実行したコマンドを確認します。",
            "查看最近执行的命令。",
            "Просмотреть недавно выполненные команды.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "status <message|clear>",
        .description = {
            "Set your profile status.",
            "프로필 상태를 설정합니다.",
            "プロフィールステータスを設定します。",
            "设置个人状态。",
            "Установить статус профиля.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "showstatus <username>",
        .description = {
            "View someone else's status.",
            "다른 사용자의 상태를 봅니다.",
            "他のユーザーのステータスを確認します。",
            "查看他人的状态。",
            "Посмотреть статус другого пользователя.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "users",
        .description = {
            "Announce the number of connected users.",
            "현재 접속자 수를 알려줍니다.",
            "接続中のユーザー数を知らせます。",
            "公布当前在线人数。",
            "Сообщить количество подключённых пользователей.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "접속자수",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "chat <message-id>",
        .description = {
            "Show a past message by ID.",
            "ID로 이전 메시지를 보여줍니다.",
            "ID を指定して過去のメッセージを表示します。",
            "按编号查看历史消息。",
            "Показать прошлое сообщение по идентификатору.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "reply <message-id|r<reply-id>> <text>",
        .description = {
            "Reply to a message or reply.",
            "메시지 또는 답글에 답장합니다.",
            "メッセージまたは返信に返信します。",
            "回复消息或回复链。",
            "Ответить на сообщение или ответ.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "답장 <메시지ID|r<답글ID>> <내용>",
            [SESSION_UI_LANGUAGE_JP] = "返信 <メッセージID|r<返信ID>> <本文>",
            [SESSION_UI_LANGUAGE_ZH] = "回复 <消息ID|r<回复ID>> <内容>",
            [SESSION_UI_LANGUAGE_RU] = "ответ <id сообщения|r<id ответа>> <текст>",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "bbs [list|read|post|comment|regen|delete]",
        .description = {
            "Open the bulletin board system (finish %s to post).",
            "게시판을 엽니다 (%s 로 입력을 마칩니다).",
            "掲示板を開きます（投稿は %s で終了）。",
            "打开公告板系统（以 %s 结束提交）。",
            "Открыть доску объявлений (завершайте ввод строкой %s).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "게시판 [목록|읽기|게시|댓글|갱신|삭제]",
            [SESSION_UI_LANGUAGE_JP] = "掲示板 [一覧|閲覧|投稿|コメント|再掲|削除]",
            [SESSION_UI_LANGUAGE_ZH] = "公告板 [列表|阅读|发布|评论|置顶|删除]",
            [SESSION_UI_LANGUAGE_RU] = "доска [список|читать|пост|коммент|поднять|удалить]",
        },
        .description_arg_count = 1,
        .description_args = {SESSION_HELP_TEMPLATE_ARG_BBS_TERMINATOR},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "bbs topic read <tag>",
        .description = {
            "Show posts under a specific topic.",
            "특정 주제의 게시물을 확인합니다.",
            "特定のトピックに属する投稿を表示します。",
            "查看特定主题下的帖子。",
            "Показать записи выбранной темы.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "게시판 주제 읽기 <태그>",
            [SESSION_UI_LANGUAGE_JP] = "掲示板 トピック 閲覧 <タグ>",
            [SESSION_UI_LANGUAGE_ZH] = "公告板 主题 阅读 <标签>",
            [SESSION_UI_LANGUAGE_RU] = "доска тема читать <тег>",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "mode <chat|command|toggle>",
        .description = {
            "Switch between chat mode and command mode.",
            "채팅 모드와 명령 모드를 전환합니다.",
            "チャットモードとコマンドモードを切り替えます。",
            "在聊天模式和命令模式之间切换。",
            "Переключить режим чата и режим команд.",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "set-ui-lang <ko|en|jp|zh|ru>",
        .description = {
            "Change the interface language.",
            "인터페이스 언어를 변경합니다.",
            "インターフェース言語を変更します。",
            "更改界面语言。",
            "Изменить язык интерфейса.",
        },
    },
};

static const session_help_entry_t kSessionHelpExtended[] = {
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "search <text>",
        .description = {
            "Search for users whose name matches the text.",
            "이름에 텍스트가 포함된 사용자를 찾습니다.",
            "名前にテキストが含まれるユーザーを検索します。",
            "按名称中包含的文字搜索用户。",
            "Найти пользователей, чьи имена содержат указанный текст.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "검색 <텍스트>",
            [SESSION_UI_LANGUAGE_JP] = "検索 <テキスト>",
            [SESSION_UI_LANGUAGE_ZH] = "搜索 <文本>",
            [SESSION_UI_LANGUAGE_RU] = "поиск <текст>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "image <url> [caption]",
        .description = {
            "Share an image link.",
            "이미지 링크를 공유합니다.",
            "画像リンクを共有します。",
            "分享图片链接。",
            "Поделиться ссылкой на изображение.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "이미지 <url> [캡션]",
            [SESSION_UI_LANGUAGE_JP] = "画像 <url> [キャプション]",
            [SESSION_UI_LANGUAGE_ZH] = "图片 <url> [标题]",
            [SESSION_UI_LANGUAGE_RU] = "изображение <url> [подпись]",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "video <url> [caption]",
        .description = {
            "Share a video link.",
            "영상 링크를 공유합니다.",
            "動画リンクを共有します。",
            "分享视频链接。",
            "Поделиться ссылкой на видео.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "영상 <url> [캡션]",
            [SESSION_UI_LANGUAGE_JP] = "動画 <url> [キャプション]",
            [SESSION_UI_LANGUAGE_ZH] = "视频 <url> [标题]",
            [SESSION_UI_LANGUAGE_RU] = "видео <url> [подпись]",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "audio <url> [caption]",
        .description = {
            "Share an audio clip link.",
            "오디오 링크를 공유합니다.",
            "音声クリップのリンクを共有します。",
            "分享音频链接。",
            "Поделиться ссылкой на аудио.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "오디오 <url> [캡션]",
            [SESSION_UI_LANGUAGE_JP] = "音声 <url> [キャプション]",
            [SESSION_UI_LANGUAGE_ZH] = "音频 <url> [标题]",
            [SESSION_UI_LANGUAGE_RU] = "аудио <url> [подпись]",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "files <url> [caption]",
        .description = {
            "Share a downloadable file.",
            "다운로드 가능한 파일을 공유합니다.",
            "ダウンロード可能なファイルを共有します。",
            "分享可下载的文件。",
            "Поделиться загружаемым файлом.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "파일 <url> [캡션]",
            [SESSION_UI_LANGUAGE_JP] = "ファイル <url> [キャプション]",
            [SESSION_UI_LANGUAGE_ZH] = "文件 <url> [标题]",
            [SESSION_UI_LANGUAGE_RU] = "файлы <url> [подпись]",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "mail [inbox|send <user> <message>|clear]",
        .description = {
            "Manage your mailbox.",
            "사서함을 관리합니다.",
            "メールボックスを管理します。",
            "管理你的邮箱。",
            "Управлять почтовым ящиком.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "메일 [받은편지함|보내기 <사용자> <메시지>|지우기]",
            [SESSION_UI_LANGUAGE_JP] = "メール [受信箱|送信 <ユーザー> <メッセージ>|クリア]",
            [SESSION_UI_LANGUAGE_ZH] = "邮件 [收件箱|发送 <用户> <消息>|清除]",
            [SESSION_UI_LANGUAGE_RU] = "почта [входящие|отправить <пользователь> <сообщение>|очистить]",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "profilepic",
        .description = {
            "Open the ASCII art profile picture composer.",
            "ASCII 아트 프로필 편집기를 엽니다.",
            "ASCII アートのプロフィール作成ツールを開きます。",
            "打开 ASCII 头像编辑器。",
            "Открыть редактор ASCII-аватаров.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "프로필사진",
            [SESSION_UI_LANGUAGE_JP] = "プロフィール写真",
            [SESSION_UI_LANGUAGE_ZH] = "头像",
            [SESSION_UI_LANGUAGE_RU] = "аватар",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "asciiart",
        .description = {
            "Open the ASCII art composer (max 128 lines, 1/10 min per IP).",
            "ASCII 아트 작성기를 엽니다 (최대 128줄, IP당 10분에 1회).",
            "ASCII アート作成ツールを開きます（最大128行、IPごと10分に1回）。",
            "打开 ASCII 艺术编辑器（最多128行，每个 IP 10 分钟一次）。",
            "Открыть редактор ASCII-арта (до 128 строк, раз в 10 минут на IP).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "아스키아트",
            [SESSION_UI_LANGUAGE_JP] = "アスキーアート",
            [SESSION_UI_LANGUAGE_ZH] = "艺术",
            [SESSION_UI_LANGUAGE_RU] = "ASCIIарт",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "game <tetris|liargame|alpha>",
        .description = {
            "Start a minigame in chat (use %ssuspend! or Ctrl+Z to exit).",
            "채팅에서 미니게임을 시작합니다 (%ssuspend! 또는 Ctrl+Z로 종료).",
            "チャットでミニゲームを開始します（終了は %ssuspend! か Ctrl+Z）。",
            "在聊天中启动小游戏（使用 %ssuspend! 或 Ctrl+Z 退出）。",
            "Запустить мини-игру в чате (выход — %ssuspend! или Ctrl+Z).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "게임 <테트리스|라이어게임|알파>",
            [SESSION_UI_LANGUAGE_JP] = "ゲーム <テトリス|ライアーゲーム|アルファ>",
            [SESSION_UI_LANGUAGE_ZH] = "游戏 <俄罗斯方块|谎言游戏|阿尔法>",
            [SESSION_UI_LANGUAGE_RU] = "игра <тетрис|лжец|альфа>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "color (text;highlight[;bold])",
        .description = {
            "Style your handle.",
            "사용자 이름 색상을 꾸밉니다.",
            "ハンドル名の配色を設定します。",
            "设置昵称的配色。",
            "Настроить оформление вашего ника.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "색상 (텍스트;하이라이트[;굵게])",
            [SESSION_UI_LANGUAGE_JP] = "色 (テキスト;ハイライト[;太字])",
            [SESSION_UI_LANGUAGE_ZH] = "颜色 (文本;高亮[;粗体])",
            [SESSION_UI_LANGUAGE_RU] = "цвет (текст;выделение[;жирный])",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "systemcolor (fg;background[;highlight][;bold])",
        .description = {
            "Customize interface colors (reset with %ssystemcolor reset).",
            "인터페이스 색상을 조정합니다 (%ssystemcolor reset으로 초기화).",
            "インターフェースの色を調整します（%ssystemcolor reset で初期化）。",
            "自定义界面颜色（用 %ssystemcolor reset 重置）。",
            "Настроить цвета интерфейса (сброс — %ssystemcolor reset).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "시스템색상 (전경;배경[;하이라이트][;굵게])",
            [SESSION_UI_LANGUAGE_JP] = "システムカラー (前景色;背景色[;ハイライト][;太字])",
            [SESSION_UI_LANGUAGE_ZH] = "系统颜色 (前景;背景[;高亮][;粗体])",
            [SESSION_UI_LANGUAGE_RU] = "системныйцвет (передний;фон[;выделение][;жирный])",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "set-trans-lang <language|off>",
        .description = {
            "Translate terminal output to a language.",
            "터미널 출력 번역 대상 언어를 지정합니다.",
            "端末出力の翻訳先を指定します。",
            "设置终端输出的翻译语言。",
            "Задать язык для перевода терминальных сообщений.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "번역언어설정 <언어|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "翻訳言語設定 <言語|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "设置翻译语言 <语言|关闭>",
            [SESSION_UI_LANGUAGE_RU] = "установить-язык-перевода <язык|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "set-target-lang <language|off>",
        .description = {
            "Translate your outgoing messages.",
            "내보내는 메시지를 번역합니다.",
            "自分の送信メッセージを翻訳します。",
            "翻译你发送的消息。",
            "Переводить исходящие сообщения.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "대상언어설정 <언어|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "ターゲット言語設定 <言語|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "设置目标语言 <语言|关闭>",
            [SESSION_UI_LANGUAGE_RU] = "установить-целевой-язык <язык|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "weather <region> <city>",
        .description = {
            "Show weather for a region and city.",
            "지역과 도시의 날씨를 보여줍니다.",
            "地域と都市の天気を表示します。",
            "显示指定地区和城市的天气。",
            "Показать погоду для региона и города.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "날씨 <지역> <도시>",
            [SESSION_UI_LANGUAGE_JP] = "天気 <地域> <都市>",
            [SESSION_UI_LANGUAGE_ZH] = "天气 <地区> <城市>",
            [SESSION_UI_LANGUAGE_RU] = "погода <регион> <город>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "translate <on|off>",
        .description = {
            "Enable or disable translation after configuring languages.",
            "언어를 설정한 후 번역 기능을 켜거나 끕니다.",
            "言語設定後に翻訳機能を有効/無効にします。",
            "在设定语言后开启或关闭翻译。",
            "Включить или отключить перевод после настройки языков.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "번역 <켜기|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "翻訳 <オン|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "翻译 <开|关>",
            [SESSION_UI_LANGUAGE_RU] = "перевод <вкл|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "eliza-chat <message>",
        .description = {
            "Chat with the shared Eliza persona.",
            "공유된 엘리자 페르소나와 대화합니다.",
            "共有のエリザ人格と会話します。",
            "与共享的 Eliza 人格聊天。",
            "Пообщаться с общей персоной Элиза.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "엘리자채팅 <메시지>",
            [SESSION_UI_LANGUAGE_JP] = "エリザチャット <メッセージ>",
            [SESSION_UI_LANGUAGE_ZH] = "伊丽莎聊天 <消息>",
            [SESSION_UI_LANGUAGE_RU] = "элиза-чат <сообщение>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "chat-spacing <0-5>",
        .description = {
            "Reserve blank lines before translated captions in chat.",
            "번역 자막 앞에 공백 줄을 예약합니다.",
            "翻訳キャプション前に空行を確保します。",
            "在聊天翻译字幕前预留空行。",
            "Резервировать пустые строки перед переводами в чате.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "채팅간격 <0-5>",
            [SESSION_UI_LANGUAGE_JP] = "チャット間隔 <0-5>",
            [SESSION_UI_LANGUAGE_ZH] = "聊天间距 <0-5>",
            [SESSION_UI_LANGUAGE_RU] = "интервал-чата <0-5>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "palette <name>",
        .description = {
            "Apply a predefined interface palette (%spalette list).",
            "미리 정의된 팔레트를 적용합니다 (%spalette list 참고).",
            "定義済みの配色を適用します（%spalette list を参照）。",
            "应用预设的界面配色（参见 %spalette list）。",
            "Применить готовую палитру интерфейса (см. %spalette list).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "팔레트 <이름>",
            [SESSION_UI_LANGUAGE_JP] = "パレット <名前>",
            [SESSION_UI_LANGUAGE_ZH] = "调色板 <名称>",
            [SESSION_UI_LANGUAGE_RU] = "палитра <имя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "today",
        .description = {
            "Discover today's function (once per day).",
            "오늘의 기능을 확인합니다 (하루 1회).",
            "本日の機能を確認します（1日1回）。",
            "查看今日功能（每天一次）。",
            "Узнать сегодняшнюю функцию (раз в день).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "오늘",
            [SESSION_UI_LANGUAGE_JP] = "今日",
            [SESSION_UI_LANGUAGE_ZH] = "今日",
            [SESSION_UI_LANGUAGE_RU] = "сегодня",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "date <timezone>",
        .description = {
            "View the server time in another timezone.",
            "다른 시간대의 서버 시간을 확인합니다.",
            "別のタイムゾーンでサーバー時刻を表示します。",
            "查看其他时区的服务器时间。",
            "Показать серверное время в другом часовом поясе.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "날짜 <시간대>",
            [SESSION_UI_LANGUAGE_JP] = "日付 <タイムゾーン>",
            [SESSION_UI_LANGUAGE_ZH] = "日期 <时区>",
            [SESSION_UI_LANGUAGE_RU] = "дата <часовойпояс>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "os <name>",
        .description = {
            "Record the operating system you use.",
            "사용 중인 운영체제를 기록합니다.",
            "使用中のOSを記録します。",
            "记录你使用的操作系统。",
            "Сохранить информацию о вашей ОС.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "운영체제 <이름>",
            [SESSION_UI_LANGUAGE_JP] = "OS <名前>",
            [SESSION_UI_LANGUAGE_ZH] = "操作系统 <名称>",
            [SESSION_UI_LANGUAGE_RU] = "ОС <имя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "getos <username>",
        .description = {
            "Look up someone else's recorded operating system.",
            "다른 사용자가 기록한 운영체제를 확인합니다.",
            "他のユーザーが登録したOSを確認します。",
            "查看他人记录的操作系统。",
            "Посмотреть, какую ОС указал другой пользователь.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "운영체제확인 <사용자이름>",
            [SESSION_UI_LANGUAGE_JP] = "OS取得 <ユーザー名>",
            [SESSION_UI_LANGUAGE_ZH] = "获取操作系统 <用户名>",
            [SESSION_UI_LANGUAGE_RU] = "получить-ОС <имяпользователя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "birthday YYYY-MM-DD",
        .description = {
            "Register your birthday.",
            "생일을 등록합니다.",
            "誕生日を登録します。",
            "登记你的生日。",
            "Зарегистрировать дату рождения.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "생일 YYYY-MM-DD",
            [SESSION_UI_LANGUAGE_JP] = "誕生日 YYYY-MM-DD",
            [SESSION_UI_LANGUAGE_ZH] = "生日 YYYY-MM-DD",
            [SESSION_UI_LANGUAGE_RU] = "деньрождения ГГГГ-ММ-ДД",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "soulmate",
        .description = {
            "List users sharing your birthday.",
            "생일이 같은 사용자를 나열합니다.",
            "同じ誕生日のユーザーを一覧表示します。",
            "列出与你同生日的用户。",
            "Показать пользователей с той же датой рождения.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "영혼의단짝",
            [SESSION_UI_LANGUAGE_JP] = "ソウルメイト",
            [SESSION_UI_LANGUAGE_ZH] = "灵魂伴侣",
            [SESSION_UI_LANGUAGE_RU] = "родственнаядуша",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "pair",
        .description = {
            "List users sharing your recorded OS.",
            "등록한 OS가 같은 사용자를 나열합니다.",
            "同じOSを登録したユーザーを表示します。",
            "列出记录的操作系统相同的用户。",
            "Показать пользователей с той же записанной ОС.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "짝",
            [SESSION_UI_LANGUAGE_JP] = "ペア",
            [SESSION_UI_LANGUAGE_ZH] = "配对",
            [SESSION_UI_LANGUAGE_RU] = "пара",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "connected",
        .description = {
            "Privately list everyone connected.",
            "현재 접속 중인 사용자 목록을 비공개로 확인합니다.",
            "接続中のユーザーを自分だけに一覧表示します。",
            "私下查看所有在线用户。",
            "Получить приватный список всех подключённых.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "접속자",
            [SESSION_UI_LANGUAGE_JP] = "接続中",
            [SESSION_UI_LANGUAGE_ZH] = "在线",
            [SESSION_UI_LANGUAGE_RU] = "подключенные",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "alpha-centauri-landers",
        .description = {
            "View the Immigrants' Flag hall of fame.",
            "Immigrants' Flag 명예의 전당을 확인합니다.",
            "Immigrants' Flag 殿堂を表示します。",
            "查看 Immigrants' Flag 名人堂。",
            "Открыть зал славы Immigrants' Flag.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "알파센타우리착륙자",
            [SESSION_UI_LANGUAGE_JP] = "アルファケンタウリ着陸者",
            [SESSION_UI_LANGUAGE_ZH] = "半人马座阿尔法星登陆者",
            [SESSION_UI_LANGUAGE_RU] = "альфа-центавра-посадочные",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "poll <question>|<option...>",
        .description = {
            "Start or view a quick poll.",
            "빠른 투표를 시작하거나 확인합니다.",
            "簡易投票を開始または表示します。",
            "发起或查看快速投票。",
            "Создать или просмотреть быстрый опрос.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "전역투표 <질문>|<옵션...>",
            [SESSION_UI_LANGUAGE_JP] = "投票 <質問>|<選択肢...>",
            [SESSION_UI_LANGUAGE_ZH] = "投票 <问题>|<选项...>",
            [SESSION_UI_LANGUAGE_RU] = "опрос <вопрос>|<вариант...>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "vote <label> <question>|<option...>",
        .description = {
            "Start or inspect a named multiple-choice poll (close with %svote @close <label>).",
            "이름 있는 다중 선택 투표를 시작하거나 확인합니다 (%svote @close <label> 로 종료).",
            "名前付きの複数選択投票を開始/確認します（終了は %svote @close <label>）。",
            "发起或查看命名的多选投票（用 %svote @close <label> 结束）。",
            "Создать или просмотреть именованный многовариантный опрос (закрытие — %svote @close <label>).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "투표 <라벨> <질문>|<옵션...>",
            [SESSION_UI_LANGUAGE_JP] = "投票 <ラベル> <質問>|<選択肢...>",
            [SESSION_UI_LANGUAGE_ZH] = "投票 <标签> <问题>|<选项...>",
            [SESSION_UI_LANGUAGE_RU] = "голосовать <метка> <вопрос>|<вариант...>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "vote-single <label> <question>|<option...>",
        .description = {
            "Start or inspect a named single-choice poll.",
            "이름 있는 단일 선택 투표를 시작하거나 확인합니다.",
            "名前付き単一選択投票を開始/確認します。",
            "发起或查看命名的单选投票。",
            "Создать или просмотреть именованный одно вариантный опрос.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "단일투표 <라벨> <질문>|<옵션...>",
            [SESSION_UI_LANGUAGE_JP] = "単一投票 <ラベル> <質問>|<選択肢...>",
            [SESSION_UI_LANGUAGE_ZH] = "单选投票 <标签> <问题>|<选项...>",
            [SESSION_UI_LANGUAGE_RU] = "голосовать-один <метка> <вопрос>|<вариант...>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "elect <label> <choice>",
        .description = {
            "Vote in a named poll by label.",
            "라벨로 지정된 투표에 참여합니다.",
            "ラベルを指定して名前付き投票に投票します。",
            "按标签在命名投票中投票。",
            "Проголосовать в именованном опросе по метке.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "선택 <라벨> <선택>",
            [SESSION_UI_LANGUAGE_JP] = "選択 <ラベル> <選択肢>",
            [SESSION_UI_LANGUAGE_ZH] = "选择 <标签> <选项>",
            [SESSION_UI_LANGUAGE_RU] = "выбрать <метка> <выбор>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "poke <username>",
        .description = {
            "Send a bell to call a user.",
            "사용자를 호출하는 종소리를 보냅니다.",
            "ユーザーを呼び出すベルを送ります。",
            "向用户发送提醒铃声。",
            "Отправить звуковой сигнал пользователю.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "호출 <사용자이름>",
            [SESSION_UI_LANGUAGE_JP] = "つつく <ユーザー名>",
            [SESSION_UI_LANGUAGE_ZH] = "戳 <用户名>",
            [SESSION_UI_LANGUAGE_RU] = "пинг <имяпользователя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "block <user|ip>",
        .description = {
            "Hide messages from a user or IP locally (%sblock list to review).",
            "사용자 또는 IP의 메시지를 차단합니다 (%sblock list로 확인).",
            "ユーザーやIPのメッセージをローカルで非表示にします（確認は %sblock list）。",
            "本地屏蔽某用户或 IP 的消息（用 %sblock list 查看）。",
            "Скрыть сообщения пользователя или IP локально (проверка через %sblock list).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "차단 <사용자|IP>",
            [SESSION_UI_LANGUAGE_JP] = "ブロック <ユーザー|IP>",
            [SESSION_UI_LANGUAGE_ZH] = "屏蔽 <用户|IP>",
            [SESSION_UI_LANGUAGE_RU] = "заблокировать <пользователь|IP>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "unblock <target|all>",
        .description = {
            "Remove a local block entry.",
            "로컬 차단을 해제합니다.",
            "ローカルのブロックを解除します。",
            "解除本地屏蔽。",
            "Удалить локальную блокировку.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "차단해제 <대상|모두>",
            [SESSION_UI_LANGUAGE_JP] = "ブロック解除 <ターゲット|すべて>",
            [SESSION_UI_LANGUAGE_ZH] = "解除屏蔽 <目标|全部>",
            [SESSION_UI_LANGUAGE_RU] = "разблокировать <цель|все>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_FORMATTED,
        .label = "%sgood|%ssad|%scool|%sangry|%schecked|%slove|%swtf <id>",
        .description = {
            "React to a message by number.",
            "번호로 메시지에 반응합니다.",
            "番号を指定してメッセージにリアクションします。",
            "按编号为消息添加表情反应。",
            "Реагировать на сообщение по номеру.",
        },
        .label_arg_count = 7U,
        .label_args = {
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "좋아요|/슬퍼요|/멋져요|/화나요|/확인|/사랑해요|/어쩌라고 <id>",
            [SESSION_UI_LANGUAGE_JP] = "いいね|/かなしい|/クール|/怒り|/確認済み|/愛|/なんだと <id>",
            [SESSION_UI_LANGUAGE_ZH] = "点赞|/难过|/酷|/生气|/已检查|/爱|/搞什么 <id>",
            [SESSION_UI_LANGUAGE_RU] = "класс|/грусть|/круто|/злой|/проверено|/любовь|/чтоэто <id>",
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_FORMATTED,
        .label = "%s1 .. %s5",
        .description = {
            "Vote for an option in the active poll.",
            "진행 중인 투표에서 항목에 투표합니다.",
            "実施中の投票で候補に投票します。",
            "为当前投票的选项投票。",
            "Проголосовать за вариант в активном опросе.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "/1 .. /5",
            [SESSION_UI_LANGUAGE_JP] = "/1 .. /5",
            [SESSION_UI_LANGUAGE_ZH] = "/1 .. /5",
            [SESSION_UI_LANGUAGE_RU] = "/1 .. /5",
        },
        .label_arg_count = 2U,
        .label_args = {
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
            SESSION_HELP_TEMPLATE_ARG_PREFIX,
        },
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "rss list",
        .description = {
            "List saved RSS feeds.",
            "저장된 RSS 피드를 나열합니다.",
            "保存された RSS フィードを一覧表示します。",
            "列出已保存的 RSS 源。",
            "Показать сохранённые RSS-ленты.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "rss 목록",
            [SESSION_UI_LANGUAGE_JP] = "rss 一覧",
            [SESSION_UI_LANGUAGE_ZH] = "rss 列表",
            [SESSION_UI_LANGUAGE_RU] = "rss список",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "rss read <tag>",
        .description = {
            "Open a saved feed in the inline reader.",
            "저장된 피드를 인라인 리더로 엽니다.",
            "保存されたフィードをインラインリーダーで開きます。",
            "在内嵌阅读器中打开已保存的源。",
            "Открыть сохранённую ленту во встроенном ридере.",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "rss 읽기 <태그>",
            [SESSION_UI_LANGUAGE_JP] = "rss 読む <タグ>",
            [SESSION_UI_LANGUAGE_ZH] = "rss 阅读 <标签>",
            [SESSION_UI_LANGUAGE_RU] = "rss читать <тег>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "suspend!",
        .description = {
            "Suspend the active game (Ctrl+Z while playing).",
            "진행 중인 게임을 일시 중단합니다 (플레이 중 Ctrl+Z).",
            "進行中のゲームを一時停止します（プレイ中に Ctrl+Z）。",
            "暂停正在进行的游戏（游戏中按 Ctrl+Z）。",
            "Приостановить активную игру (Ctrl+Z во время игры).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "일시중지!",
            [SESSION_UI_LANGUAGE_JP] = "一時停止!",
            [SESSION_UI_LANGUAGE_ZH] = "暂停!",
            [SESSION_UI_LANGUAGE_RU] = "приостановить!",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
};

static const session_help_entry_t kSessionHelpOperator[] = {
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "translate-scope <chat|chat-nohistory|all>",
        .description = {
            "Limit translation scope (operators only).",
            "번역 범위를 제한합니다 (운영자 전용).",
            "翻訳対象範囲を制限します（オペレーター専用）。",
            "限制翻译范围（仅限管理员）。",
            "Ограничить область перевода (только для операторов).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "번역범위 <채팅|채팅기록없음|모두>",
            [SESSION_UI_LANGUAGE_JP] = "翻訳範囲 <チャット|チャット履歴なし|すべて>",
            [SESSION_UI_LANGUAGE_ZH] = "翻译范围 <聊天|无聊天记录|全部>",
            [SESSION_UI_LANGUAGE_RU] = "область-перевода <чат|чат-без-истории|все>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "gemini <on|off>",
        .description = {
            "Toggle Gemini provider (operator only).",
            "Gemini 제공자를 전환합니다 (운영자 전용).",
            "Gemini プロバイダーを切り替えます（オペレーター専用）。",
            "切换 Gemini 提供方（仅限管理员）。",
            "Включить/выключить провайдер Gemini (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "제미니 <켜기|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "ジェミニ <オン|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "Gemini <开|关>",
            [SESSION_UI_LANGUAGE_RU] = "джемини <вкл|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "gemini-unfreeze",
        .description = {
            "Clear automatic Gemini cooldown (operator only).",
            "Gemini 자동 쿨다운을 해제합니다 (운영자 전용).",
            "Gemini の自動クールダウンを解除します（オペレーター専用）。",
            "清除 Gemini 自动冷却（仅限管理员）。",
            "Снять автоматическую задержку Gemini (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "제미니-해제",
            [SESSION_UI_LANGUAGE_JP] = "ジェミニ-解除",
            [SESSION_UI_LANGUAGE_ZH] = "Gemini-解冻",
            [SESSION_UI_LANGUAGE_RU] = "джемини-разморозить",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "captcha <on|off>",
        .description = {
            "Toggle captcha requirement (operator only).",
            "캡차 요구를 전환합니다 (운영자 전용).",
            "CAPTCHA の必須設定を切り替えます（オペレーター専用）。",
            "切换验证码要求（仅限管理员）。",
            "Включить/выключить требование капчи (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "캡차 <켜기|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "キャプチャ <オン|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "验证码 <开|关>",
            [SESSION_UI_LANGUAGE_RU] = "капча <вкл|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "eliza <on|off>",
        .description = {
            "Toggle the Eliza moderator persona (operator only).",
            "엘리자 모더레이터를 전환합니다 (운영자 전용).",
            "Eliza モデレーターを切り替えます（オペレーター専用）。",
            "切换 Eliza 管理员人格（仅限管理员）。",
            "Включить/выключить модератора Элиза (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "/엘리자 <켜기|끄기>",
            [SESSION_UI_LANGUAGE_JP] = "/エリザ <オン|オフ>",
            [SESSION_UI_LANGUAGE_ZH] = "/伊丽莎 <开|关>",
            [SESSION_UI_LANGUAGE_RU] = "/элиза <вкл|выкл>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "grant <ip>",
        .description = {
            "Grant operator access to an IP (LAN only).",
            "IP에 운영자 권한을 부여합니다 (LAN 한정).",
            "IP にオペレーター権限を付与します（LAN 限定）。",
            "为 IP 授予管理员权限（仅限局域网）。",
            "Выдать операторские права IP-адресу (только LAN).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "권한부여 <IP>",
            [SESSION_UI_LANGUAGE_JP] = "許可 <IP>",
            [SESSION_UI_LANGUAGE_ZH] = "授予 <IP>",
            [SESSION_UI_LANGUAGE_RU] = "выдать <IP>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "revoke <ip>",
        .description = {
            "Revoke an IP's operator access (LAN top admin).",
            "IP의 운영자 권한을 회수합니다 (LAN 최고 관리자).",
            "IP のオペレーター権限を剥奪します（LAN トップ管理者）。",
            "撤销 IP 的管理员权限（局域网最高管理员）。",
            "Отозвать операторские права IP (только старший LAN-админ).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "권한해제 <IP>",
            [SESSION_UI_LANGUAGE_JP] = "取り消し <IP>",
            [SESSION_UI_LANGUAGE_ZH] = "撤销 <IP>",
            [SESSION_UI_LANGUAGE_RU] = "отозвать <IP>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "kick <username>",
        .description = {
            "Disconnect a user (operator only).",
            "사용자를 강제로 종료합니다 (운영자 전용).",
            "ユーザーを切断します（オペレーター専用）。",
            "断开某位用户（仅限管理员）。",
            "Отключить пользователя (operator).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "강퇴 <사용자이름>",
            [SESSION_UI_LANGUAGE_JP] = "キック <ユーザー名>",
            [SESSION_UI_LANGUAGE_ZH] = "踢出 <用户名>",
            [SESSION_UI_LANGUAGE_RU] = "кик <имяпользователя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "ban <username>",
        .description = {
            "Ban a user (operator only).",
            "사용자를 차단합니다 (운영자 전용).",
            "ユーザーを追放します（オペレーター専用）。",
            "封禁用户（仅限管理员）。",
            "Забанить пользователя (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "밴 <사용자이름>",
            [SESSION_UI_LANGUAGE_JP] = "バン <ユーザー名>",
            [SESSION_UI_LANGUAGE_ZH] = "封禁 <用户名>",
            [SESSION_UI_LANGUAGE_RU] = "бан <имяпользователя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "banname <nickname>",
        .description = {
            "Block a nickname (operator only).",
            "닉네임을 차단합니다 (운영자 전용).",
            "ニックネームを禁止します（オペレーター専用）。",
            "屏蔽昵称（仅限管理员）。",
            "Заблокировать ник (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "닉네임차단 <닉네임>",
            [SESSION_UI_LANGUAGE_JP] = "ニックネーム禁止 <ニックネーム>",
            [SESSION_UI_LANGUAGE_ZH] = "屏蔽昵称 <昵称>",
            [SESSION_UI_LANGUAGE_RU] = "забанить-ник <ник>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "banlist",
        .description = {
            "List active bans (operator only).",
            "활성화된 차단 목록을 봅니다 (운영자 전용).",
            "現在のBANを一覧表示します（オペレーター専用）。",
            "列出当前生效的封禁（仅限管理员）。",
            "Показать активные баны (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "밴목록",
            [SESSION_UI_LANGUAGE_JP] = "バンリスト",
            [SESSION_UI_LANGUAGE_ZH] = "封禁列表",
            [SESSION_UI_LANGUAGE_RU] = "список-банов",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "delete-msg <id|start-end>",
        .description = {
            "Remove chat history messages (operator only).",
            "채팅 기록 메시지를 삭제합니다 (운영자 전용).",
            "チャット履歴のメッセージを削除します（オペレーター専用）。",
            "删除聊天记录中的消息（仅限管理员）。",
            "Удалить сообщения из истории чата (operator).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "메시지삭제 <ID|시작-끝>",
            [SESSION_UI_LANGUAGE_JP] = "メッセージ削除 <ID|開始-終了>",
            [SESSION_UI_LANGUAGE_ZH] = "删除消息 <ID|开始-结束>",
            [SESSION_UI_LANGUAGE_RU] = "удалить-сообщение <ID|начало-конец>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "pardon <user|ip>",
        .description = {
            "Remove a ban (operator only).",
            "차단을 해제합니다 (운영자 전용).",
            "BAN を解除します（オペレーター専用）。",
            "解除封禁（仅限管理员）。",
            "Снять бан (operator).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "사면 <사용자|IP>",
            [SESSION_UI_LANGUAGE_JP] = "許し <ユーザー|IP>",
            [SESSION_UI_LANGUAGE_ZH] = "赦免 <用户|IP>",
            [SESSION_UI_LANGUAGE_RU] = "помиловать <пользователь|IP>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "rss add <url> <tag>",
        .description = {
            "Register a feed (operator only).",
            "피드를 등록합니다 (운영자 전용).",
            "フィードを登録します（オペレーター専用）。",
            "注册新的源（仅限管理员）。",
            "Добавить ленту (оператор).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "rss 추가 <url> <태그>",
            [SESSION_UI_LANGUAGE_JP] = "rss 追加 <url> <タグ>",
            [SESSION_UI_LANGUAGE_ZH] = "rss 添加 <url> <标签>",
            [SESSION_UI_LANGUAGE_RU] = "rss добавить <url> <тег>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "rss del <tag>",
        .description = {
            "Delete a feed (operator only).",
            "피드를 삭제합니다 (운영자 전용).",
            "フィードを削除します（オペレーター専用）。",
            "删除源（仅限管理员）。",
            "Удалить ленту (operator).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "rss 삭제 <태그>",
            [SESSION_UI_LANGUAGE_JP] = "rss 削除 <タグ>",
            [SESSION_UI_LANGUAGE_ZH] = "rss 删除 <标签>",
            [SESSION_UI_LANGUAGE_RU] = "rss удалить <тег>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
    {
        .kind = SESSION_HELP_ENTRY_COMMAND,
        .label = "getaddr <username>",
        .description = {
            "Look up a user's last known address (operator only).",
            "사용자의 마지막 접속 주소를 확인합니다 (운영자 전용).",
            "ユーザーの最新の接続アドレスを確認します（オペレーター専用）。",
            "查看用户最近的连接地址（仅限管理员）。",
            "Посмотреть последний известный адрес пользователя (operator).",
        },
        .label_translations = {
            [SESSION_UI_LANGUAGE_KO] = "주소확인 <사용자이름>",
            [SESSION_UI_LANGUAGE_JP] = "アドレス取得 <ユーザー名>",
            [SESSION_UI_LANGUAGE_ZH] = "获取地址 <用户名>",
            [SESSION_UI_LANGUAGE_RU] = "получить-адрес <имяпользователя>",
        },
        .label_arg_count = 0U,
        .label_args = {},
    },
};

static const int kSessionHelpLabelWidth = 26;

static session_ui_language_t session_ui_language_from_code(const char *code) {
  if (code == NULL || code[0] == '\0') {
    return SESSION_UI_LANGUAGE_COUNT;
  }

  for (size_t idx = 0; idx < SESSION_UI_LANGUAGE_COUNT; ++idx) {
    if (strcasecmp(code, kSessionUiLanguageCodes[idx]) == 0) {
      return (session_ui_language_t)idx;
    }
  }

  return SESSION_UI_LANGUAGE_COUNT;
}

static const char *session_ui_language_code(session_ui_language_t language) {
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  return kSessionUiLanguageCodes[language];
}

static const char *session_ui_language_name(session_ui_language_t language, session_ui_language_t locale) {
  if (locale < 0 || locale >= SESSION_UI_LANGUAGE_COUNT) {
    locale = SESSION_UI_LANGUAGE_KO;
  }
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  return kSessionUiLanguageNames[locale][language];
}

static const session_ui_locale_t *session_ui_get_locale(const session_ctx_t *ctx) {
  session_ui_language_t language = SESSION_UI_LANGUAGE_KO;
  if (ctx != NULL) {
    language = ctx->ui_language;
  }
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }

  for (size_t idx = 0; idx < SESSION_UI_LANGUAGE_COUNT; ++idx) {
    if (kSessionUiLocales[idx].language == language) {
      return &kSessionUiLocales[idx];
    }
  }

  return &kSessionUiLocales[SESSION_UI_LANGUAGE_KO];
}

static void session_dispatch_command(session_ctx_t *ctx, const char *line);
static void session_handle_mode(session_ctx_t *ctx, const char *arguments);

static const char *session_command_prefix(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return "/";
  }
  return ctx->input_mode == SESSION_INPUT_MODE_COMMAND ? "" : "/";
}

static bool session_try_localized_command_forward(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || line == NULL) {
    return false;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *command_label =
      (locale != NULL && locale->mode_label_command != NULL && locale->mode_label_command[0] != '\0')
          ? locale->mode_label_command
          : "command";

  char localized_prefix[128];
  int prefix_len = snprintf(localized_prefix, sizeof(localized_prefix), "/%s", command_label);
  if (prefix_len <= 0 || (size_t)prefix_len >= sizeof(localized_prefix)) {
    return false;
  }

  if (strncmp(line, localized_prefix, (size_t)prefix_len) != 0) {
    return false;
  }

  const char *remainder = line + prefix_len;
  while (*remainder == ' ' || *remainder == '\t') {
    ++remainder;
  }

  if (*remainder == '\0') {
    ctx->ops->handle_mode(ctx, command_label);
    return true;
  }

  if (*remainder == '/') {
    ctx->ops->dispatch_command(ctx, remainder);
    return true;
  }

  char forwarded[SSH_CHATTER_MAX_INPUT_LEN];
  forwarded[0] = '/';
  size_t copy_len = strnlen(remainder, sizeof(forwarded) - 2U);
  memcpy(&forwarded[1], remainder, copy_len);
  forwarded[copy_len + 1U] = '\0';
  ctx->ops->dispatch_command(ctx, forwarded);
  return true;
}

static session_ui_language_t session_ui_language_current(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return SESSION_UI_LANGUAGE_KO;
  }
  session_ui_language_t language = ctx->ui_language;
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  return language;
}

static const char *session_asciiart_terminator_for_language(session_ui_language_t language) {
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  const char *terminator = kSessionAsciiartTerminators[language];
  if (terminator != NULL && terminator[0] != '\0') {
    return terminator;
  }
  const char *fallback = kSessionAsciiartTerminators[SESSION_UI_LANGUAGE_KO];
  return (fallback != NULL && fallback[0] != '\0') ? fallback : SSH_CHATTER_ASCIIART_TERMINATOR_EN;
}

static const char *session_bbs_terminator_for_language(session_ui_language_t language) {
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  const char *terminator = kSessionBbsTerminators[language];
  if (terminator != NULL && terminator[0] != '\0') {
    return terminator;
  }
  const char *fallback = kSessionBbsTerminators[SESSION_UI_LANGUAGE_KO];
  return (fallback != NULL && fallback[0] != '\0') ? fallback : SSH_CHATTER_BBS_TERMINATOR_EN;
}

static const char *session_asciiart_terminator(const session_ctx_t *ctx) {
  return session_asciiart_terminator_for_language(session_ui_language_current(ctx));
}

static const char *session_bbs_terminator(const session_ctx_t *ctx) {
  return session_bbs_terminator_for_language(session_ui_language_current(ctx));
}

static const char *session_editor_terminator(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return SSH_CHATTER_BBS_TERMINATOR_EN;
  }

  if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
    return session_asciiart_terminator(ctx);
  }

  return session_bbs_terminator(ctx);
}

static bool session_asciiart_matches_terminator(const char *line) {
  if (line == NULL) {
    return false;
  }
  for (size_t idx = 0; idx < SESSION_UI_LANGUAGE_COUNT; ++idx) {
    const char *terminator = session_asciiart_terminator_for_language((session_ui_language_t)idx);
    if (terminator != NULL && strcmp(line, terminator) == 0) {
      return true;
    }
  }
  return false;
}

static bool session_bbs_matches_terminator(const char *line) {
  if (line == NULL) {
    return false;
  }
  for (size_t idx = 0; idx < SESSION_UI_LANGUAGE_COUNT; ++idx) {
    const char *terminator = session_bbs_terminator_for_language((session_ui_language_t)idx);
    if (terminator != NULL && strcmp(line, terminator) == 0) {
      return true;
    }
  }
  return false;
}

static const char *session_command_alias_preferred_by_canonical(const session_ctx_t *ctx, const char *canonical);
static void session_send_system_line(session_ctx_t *ctx, const char *message);

static const session_bbs_subcommand_alias_t *session_bbs_subcommand_lookup(const char *canonical) {
  if (canonical == NULL || canonical[0] == '\0') {
    return NULL;
  }
  for (size_t idx = 0; idx < kSessionBbsSubcommandCount; ++idx) {
    if (strcmp(kSessionBbsSubcommands[idx].canonical, canonical) == 0) {
      return &kSessionBbsSubcommands[idx];
    }
  }
  return NULL;
}

static const char *session_bbs_subcommand_localized(const session_bbs_subcommand_alias_t *alias,
                                                    session_ui_language_t language) {
  if (alias == NULL) {
    return NULL;
  }
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  const char *localized = alias->localized[language];
  if (localized != NULL && localized[0] != '\0') {
    return localized;
  }
  return NULL;
}

static const char *session_bbs_subcommand_preferred(const session_ctx_t *ctx, const char *canonical) {
  const session_bbs_subcommand_alias_t *alias = session_bbs_subcommand_lookup(canonical);
  if (alias == NULL) {
    return canonical;
  }
  const char *localized = session_bbs_subcommand_localized(alias, session_ui_language_current(ctx));
  if (localized != NULL) {
    return localized;
  }
  return alias->canonical;
}

static const char *session_bbs_subcommand_canonicalize(const session_ctx_t *ctx, const char *command) {
  if (command == NULL || command[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0; idx < kSessionBbsSubcommandCount; ++idx) {
    if (strcmp(command, kSessionBbsSubcommands[idx].canonical) == 0) {
      return kSessionBbsSubcommands[idx].canonical;
    }
  }

  session_ui_language_t language = session_ui_language_current(ctx);
  for (size_t idx = 0; idx < kSessionBbsSubcommandCount; ++idx) {
    const char *localized = session_bbs_subcommand_localized(&kSessionBbsSubcommands[idx], language);
    if (localized != NULL && strcmp(command, localized) == 0) {
      return kSessionBbsSubcommands[idx].canonical;
    }
  }

  for (size_t idx = 0; idx < kSessionBbsSubcommandCount; ++idx) {
    for (size_t lang = 0; lang < SESSION_UI_LANGUAGE_COUNT; ++lang) {
      const char *localized =
          session_bbs_subcommand_localized(&kSessionBbsSubcommands[idx], (session_ui_language_t)lang);
      if (localized != NULL && strcmp(command, localized) == 0) {
        return kSessionBbsSubcommands[idx].canonical;
      }
    }
  }

  return NULL;
}

static void session_bbs_format_usage(session_ctx_t *ctx, const char *canonical, const char *arguments,
                                     char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }

  buffer[0] = '\0';
  const char *bbs_command = session_command_alias_preferred_by_canonical(ctx, "/bbs");
  if (bbs_command == NULL || bbs_command[0] == '\0') {
    bbs_command = "/bbs";
  }

  const char *subcommand = canonical != NULL ? session_bbs_subcommand_preferred(ctx, canonical) : NULL;
  if (subcommand == NULL || subcommand[0] == '\0') {
    subcommand = canonical != NULL ? canonical : "";
  }

  const char *args = arguments != NULL ? arguments : "";
  const char *separator = args[0] != '\0' ? " " : "";

  snprintf(buffer, length, "Usage: %s %s%s%s", bbs_command, subcommand, separator, args);
}

static void session_bbs_send_usage(session_ctx_t *ctx, const char *canonical, const char *arguments) {
  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_bbs_format_usage(ctx, canonical, arguments, usage, sizeof(usage));
  session_send_system_line(ctx, usage);
}

static const session_command_alias_t *session_command_alias_lookup(const char *canonical) {
  if (canonical == NULL || canonical[0] == '\0') {
    return NULL;
  }
  for (size_t idx = 0; idx < kSessionCommandAliasCount; ++idx) {
    if (strcmp(kSessionCommandAliases[idx].canonical, canonical) == 0) {
      return &kSessionCommandAliases[idx];
    }
  }
  return NULL;
}

static const char *session_command_alias_for_language(const session_command_alias_t *alias,
                                                      session_ui_language_t language) {
  if (alias == NULL) {
    return NULL;
  }
  if (language < 0 || language >= SESSION_UI_LANGUAGE_COUNT) {
    language = SESSION_UI_LANGUAGE_KO;
  }
  const char *localized = alias->localized[language];
  if (localized != NULL && localized[0] != '\0') {
    return localized;
  }
  return alias->canonical;
}

static const char *session_command_alias_preferred(const session_ctx_t *ctx,
                                                   const session_command_alias_t *alias) {
  return session_command_alias_for_language(alias, session_ui_language_current(ctx));
}

static const char *session_command_alias_preferred_by_canonical(const session_ctx_t *ctx,
                                                                const char *canonical) {
  const session_command_alias_t *alias = session_command_alias_lookup(canonical);
  if (alias == NULL) {
    return canonical;
  }
  return session_command_alias_preferred(ctx, alias);
}

static bool session_parse_command(const char *line, const char *command, const char **arguments);
static bool session_parse_localized_command(session_ctx_t *ctx, const session_command_alias_t *alias, const char *line,
                                            const char **arguments);

static bool session_parse_command_any(session_ctx_t *ctx, const char *canonical, const char *line,
                                      const char **arguments) {
  if (canonical == NULL) {
    return false;
  }
  const session_command_alias_t *alias = session_command_alias_lookup(canonical);
  if (alias != NULL) {
    return session_parse_localized_command(ctx, alias, line, arguments);
  }
  return session_parse_command(line, canonical, arguments);
}

static void session_command_collect_localized_matches(session_ctx_t *ctx, const char *prefix,
                                                      const char **matches, size_t *match_count, size_t max_count) {
  if (ctx == NULL || matches == NULL || match_count == NULL) {
    return;
  }

  size_t prefix_len = prefix != NULL ? strlen(prefix) : 0U;

  for (size_t idx = 0; idx < kSessionCommandAliasCount; ++idx) {
    const session_command_alias_t *alias = &kSessionCommandAliases[idx];
    const char *localized = session_command_alias_preferred(ctx, alias);
    if (localized == NULL || localized[0] == '\0') {
      continue;
    }
    if (strcmp(localized, alias->canonical) == 0) {
      continue;
    }

    const char *name = localized[0] == '/' ? localized + 1 : localized;
    if (name[0] == '\0') {
      continue;
    }

    if (prefix_len > 0U && strncasecmp(name, prefix, prefix_len) != 0) {
      continue;
    }

    bool duplicate = false;
    for (size_t existing = 0; existing < *match_count; ++existing) {
      if (strcmp(matches[existing], name) == 0) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      continue;
    }

    if (*match_count >= max_count) {
      break;
    }
    matches[(*match_count)++] = name;
  }
}

static void session_command_format_usage(session_ctx_t *ctx, const char *canonical, const char *fallback,
                                         char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (fallback == NULL) {
    return;
  }

  if (canonical == NULL || canonical[0] == '\0') {
    snprintf(buffer, length, "%s", fallback);
    return;
  }

  const char *alias = session_command_alias_preferred_by_canonical(ctx, canonical);
  if (alias == NULL || alias[0] == '\0') {
    alias = canonical;
  }

  const char *prefix = session_command_prefix(ctx);
  if (prefix == NULL) {
    prefix = "";
  }

  const char *alias_body = alias;
  if (alias_body != NULL && alias_body[0] == '/') {
    ++alias_body;
  }

  const char *canonical_body = canonical;
  if (canonical_body[0] == '/') {
    ++canonical_body;
  }

  if (alias_body == NULL || alias_body[0] == '\0') {
    alias_body = canonical_body;
  }

  char replacement[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(replacement, sizeof(replacement), "%s%s", prefix, alias_body != NULL ? alias_body : "");

  const char *source = fallback;
  size_t canonical_len = strlen(canonical);
  size_t out_index = 0U;
  bool replaced = false;

  for (size_t idx = 0U; source[idx] != '\0' && out_index + 1U < length;) {
    if (canonical_len > 0U && strncmp(source + idx, canonical, canonical_len) == 0) {
      size_t repl_len = strnlen(replacement, length - out_index - 1U);
      memcpy(buffer + out_index, replacement, repl_len);
      out_index += repl_len;
      idx += canonical_len;
      replaced = true;
      continue;
    }
    buffer[out_index++] = source[idx++];
  }
  buffer[out_index] = '\0';

  if (replaced) {
    return;
  }

  size_t body_len = canonical_body != NULL ? strlen(canonical_body) : 0U;
  if (body_len == 0U) {
    snprintf(buffer, length, "%s", fallback);
    return;
  }

  out_index = 0U;
  bool body_replaced = false;
  for (size_t idx = 0U; source[idx] != '\0' && out_index + 1U < length;) {
    if (strncmp(source + idx, canonical_body, body_len) == 0) {
      size_t repl_len = strnlen(replacement, length - out_index - 1U);
      memcpy(buffer + out_index, replacement, repl_len);
      out_index += repl_len;
      idx += body_len;
      body_replaced = true;
      continue;
    }
    buffer[out_index++] = source[idx++];
  }
  buffer[out_index] = '\0';

  if (!body_replaced) {
    snprintf(buffer, length, "%s", fallback);
  }
}

static int session_utf8_display_width(const char *text) {
  if (text == NULL) {
    return 0;
  }

  mbstate_t state;
  memset(&state, 0, sizeof(state));

  int width = 0;
  const char *cursor = text;
  size_t remaining = strlen(text);
  while (remaining > 0U) {
    wchar_t wc;
    size_t consumed = mbrtowc(&wc, cursor, remaining, &state);
    if (consumed == (size_t)-1 || consumed == (size_t)-2) {
      ++cursor;
      --remaining;
      memset(&state, 0, sizeof(state));
      width += 1;
      continue;
    }
    if (consumed == 0U) {
      break;
    }

    int char_width = wcwidth(wc);
    if (char_width < 0) {
      char_width = 1;
    }
    width += char_width;
    cursor += consumed;
    remaining -= consumed;
  }

  return width;
}

static void session_send_system_line(session_ctx_t *ctx, const char *message);

static void session_format_template(const char *format, const char *const *args, size_t arg_count, char *buffer,
                                    size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (format == NULL) {
    return;
  }

  size_t out_index = 0U;
  size_t arg_index = 0U;
  for (size_t idx = 0U; format[idx] != '\0' && out_index + 1U < length; ++idx) {
    if (format[idx] == '%' && format[idx + 1U] == 's') {
      const char *replacement = (args != NULL && arg_index < arg_count && args[arg_index] != NULL)
                                    ? args[arg_index]
                                    : "";
      size_t available = length - out_index - 1U;
      size_t rep_len = strnlen(replacement, available);
      memcpy(buffer + out_index, replacement, rep_len);
      out_index += rep_len;
      ++arg_index;
      ++idx;
      continue;
    }
    if (format[idx] == '%' && format[idx + 1U] == '%') {
      buffer[out_index++] = '%';
      ++idx;
      continue;
    }

    buffer[out_index++] = format[idx];
  }

  buffer[out_index] = '\0';
}

static size_t session_help_collect_arguments(session_ctx_t *ctx,
                                             const session_help_template_arg_kind_t *kinds,
                                             size_t kind_count, const char **output, size_t capacity) {
  if (output == NULL || capacity == 0U) {
    return 0U;
  }

  size_t produced = 0U;
  const char *prefix = session_command_prefix(ctx);

  if (kind_count == 0U) {
    size_t repeat = capacity < 8U ? capacity : 8U;
    for (size_t idx = 0; idx < repeat; ++idx) {
      output[produced++] = prefix;
    }
    return produced;
  }

  for (size_t idx = 0; idx < kind_count && produced < capacity; ++idx) {
    const char *value = "";
    switch (kinds[idx]) {
    case SESSION_HELP_TEMPLATE_ARG_PREFIX:
      value = prefix;
      break;
    case SESSION_HELP_TEMPLATE_ARG_ASCIIART_TERMINATOR:
      value = session_asciiart_terminator(ctx);
      break;
    case SESSION_HELP_TEMPLATE_ARG_BBS_TERMINATOR:
      value = session_bbs_terminator(ctx);
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_REPLY:
      value = session_command_alias_preferred_by_canonical(ctx, "/reply");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_GOOD:
      value = session_command_alias_preferred_by_canonical(ctx, "/good");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_SAD:
      value = session_command_alias_preferred_by_canonical(ctx, "/sad");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_WTF:
      value = session_command_alias_preferred_by_canonical(ctx, "/wtf");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_COOL:
      value = session_command_alias_preferred_by_canonical(ctx, "/cool");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_ANGRY:
      value = session_command_alias_preferred_by_canonical(ctx, "/angry");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_CHECKED:
      value = session_command_alias_preferred_by_canonical(ctx, "/checked");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_LOVE:
      value = session_command_alias_preferred_by_canonical(ctx, "/love");
      break;
    case SESSION_HELP_TEMPLATE_ARG_COMMAND_BBS:
      value = session_command_alias_preferred_by_canonical(ctx, "/bbs");
      break;
    default:
      value = prefix;
      break;
    }
    if (value == NULL) {
      value = "";
    }
    output[produced++] = value;
  }

  return produced;
}

static void session_format_help_line(session_ctx_t *ctx, const session_help_entry_t *entry, const char *description,
                                     char *buffer, size_t length) {
  if (ctx == NULL || entry == NULL || buffer == NULL || length == 0U) {
    return;
  }

  const size_t language_index = (size_t)session_ui_language_current(ctx);
  const char *label_template = entry->label;
  if (language_index < SESSION_UI_LANGUAGE_COUNT && entry->label_translations[language_index] != NULL &&
      entry->label_translations[language_index][0] != '\0') {
    label_template = entry->label_translations[language_index];
  }
  if (label_template == NULL) {
    label_template = "";
  }

  const char *prefix = session_command_prefix(ctx);
  char label[128];
  label[0] = '\0';

  if (entry->kind == SESSION_HELP_ENTRY_COMMAND) {
    snprintf(label, sizeof(label), "%s%s", prefix, label_template);
  } else if (entry->kind == SESSION_HELP_ENTRY_FORMATTED) {
    const char *args[SESSION_HELP_TEMPLATE_ARG_LIMIT];
    size_t arg_count = session_help_collect_arguments(ctx, entry->label_args, entry->label_arg_count, args,
                                                      sizeof(args) / sizeof(args[0]));
    session_format_template(label_template, args, arg_count, label, sizeof(label));
  }

  if (entry->kind == SESSION_HELP_ENTRY_TEXT) {
    snprintf(buffer, length, "%s", description != NULL ? description : "");
    return;
  }

  int display_width = session_utf8_display_width(label);
  if (display_width < 0) {
    display_width = 0;
  }

  int padding = kSessionHelpLabelWidth - display_width;
  if (padding < 1) {
    padding = 1;
  }
  if (padding > 32) {
    padding = 32;
  }

  char padding_buffer[33];
  memset(padding_buffer, ' ', (size_t)padding);
  padding_buffer[padding] = '\0';

  snprintf(buffer, length, "%s%s- %s", label, padding_buffer, description != NULL ? description : "");
}

static void session_help_send_entries(session_ctx_t *ctx, const session_help_entry_t *entries, size_t count) {
  if (ctx == NULL || entries == NULL) {
    return;
  }

  const size_t language_index = (size_t)session_ui_language_current(ctx);

  for (size_t idx = 0; idx < count; ++idx) {
    const session_help_entry_t *entry = &entries[idx];
    const char *format = entry->description[language_index];
    if (format == NULL || format[0] == '\0') {
      continue;
    }

    char description[SSH_CHATTER_MESSAGE_LIMIT];
    const char *args[SESSION_HELP_TEMPLATE_ARG_LIMIT];
    size_t arg_count = session_help_collect_arguments(ctx, entry->description_args, entry->description_arg_count, args,
                                                      sizeof(args) / sizeof(args[0]));
    session_format_template(format, args, arg_count, description, sizeof(description));

    if (entry->kind == SESSION_HELP_ENTRY_TEXT) {
      session_send_system_line(ctx, description);
      continue;
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_help_line(ctx, entry, description, line, sizeof(line));
    session_send_system_line(ctx, line);
  }
}

#ifndef MSG_DONTWAIT
#define MSG_DONTWAIT 0
#endif

typedef struct {
  char question_en[256];
  char question_ko[256];
  char question_ru[256];
  char question_zh[256];
  char answer[64];
} captcha_prompt_t;

typedef enum {
  CAPTCHA_LANGUAGE_KO = 0,
  CAPTCHA_LANGUAGE_EN,
  CAPTCHA_LANGUAGE_ZH,
  CAPTCHA_LANGUAGE_RU,
  CAPTCHA_LANGUAGE_COUNT,
} captcha_language_t;

typedef enum {
  HOST_SECURITY_SCAN_CLEAN = 0,
  HOST_SECURITY_SCAN_BLOCKED,
  HOST_SECURITY_SCAN_ERROR,
} host_security_scan_result_t;


static unsigned session_prng_next(unsigned *state) {
  if (state == NULL) {
    return 0U;
  }

  *state = (*state * 1664525U) + 1013904223U;
  return *state;
}

static void session_fill_digit_sum_prompt(captcha_prompt_t *prompt, unsigned *state) {
  if (prompt == NULL) {
    return;
  }

  unsigned digits_count = 3U;
  if (state != NULL) {
    digits_count = 2U + (session_prng_next(state) % 2U);
  }
  if (digits_count < 2U) {
    digits_count = 2U;
  }
  if (digits_count > 3U) {
    digits_count = 3U;
  }

  unsigned digits[4] = {0U, 0U, 0U, 0U};
  unsigned sum = 0U;

  if (digits_count == 3U) {
    bool valid = false;
    for (unsigned attempt = 0U; attempt < 16U && !valid; ++attempt) {
      sum = 0U;
      for (unsigned idx = 0U; idx < digits_count; ++idx) {
        unsigned raw = (unsigned)((idx + 1U) % 10U);
        if (state != NULL) {
          raw = session_prng_next(state) % 10U;
        }
        digits[idx] = raw;
        sum += raw;
      }
      if (sum < 10U) {
        valid = true;
      }
    }

    if (!valid && sum >= 10U) {
      unsigned overflow = sum - 9U;
      for (int idx = (int)digits_count - 1; idx >= 0 && overflow > 0U; --idx) {
        unsigned current = digits[(size_t)idx];
        unsigned reduction = current > overflow ? overflow : current;
        digits[(size_t)idx] = current - reduction;
        sum -= reduction;
        overflow -= reduction;
      }
      if (sum >= 10U) {
        digits[0] = 3U;
        digits[1] = 3U;
        digits[2] = 3U;
        sum = 9U;
      }
    }
  } else {
    sum = 0U;
    for (unsigned idx = 0U; idx < digits_count; ++idx) {
      unsigned raw = (unsigned)(idx + 1U);
      if (state != NULL) {
        raw = (session_prng_next(state) % 9U) + 1U;
      } else {
        raw = (raw % 9U) + 1U;
      }
      digits[idx] = raw;
      sum += raw;
    }
  }

  char expression[64];
  expression[0] = '\0';
  size_t written = 0U;
  for (unsigned idx = 0U; idx < digits_count; ++idx) {
    int appended = 0;
    if (idx == 0U) {
      appended = snprintf(expression + written, sizeof(expression) - written, "%u", digits[idx]);
    } else {
      appended = snprintf(expression + written, sizeof(expression) - written, " + %u", digits[idx]);
    }
    if (appended < 0) {
      expression[sizeof(expression) - 1U] = '\0';
      break;
    }
    size_t appended_size = (size_t)appended;
    if (appended_size >= sizeof(expression) - written) {
      expression[sizeof(expression) - 1U] = '\0';
      break;
    }
    written += appended_size;
  }

  snprintf(prompt->question_en, sizeof(prompt->question_en), "Add the digits: %s = ?", expression);
  snprintf(prompt->question_ko, sizeof(prompt->question_ko), "다음 숫자들의 합은 얼마인가요? %s = ?", expression);
  snprintf(prompt->question_ru, sizeof(prompt->question_ru), "Чему равна сумма цифр: %s = ?", expression);
  snprintf(prompt->question_zh, sizeof(prompt->question_zh), "請計算以下數字的總和：%s = ?", expression);
  snprintf(prompt->answer, sizeof(prompt->answer), "%u", sum);
}

static bool string_contains_case_insensitive(const char *haystack, const char *needle) {
  if (haystack == NULL || needle == NULL || *needle == '\0') {
    return false;
  }

  const size_t haystack_length = strlen(haystack);
  const size_t needle_length = strlen(needle);
  if (needle_length == 0U || haystack_length < needle_length) {
    return false;
  }

  for (size_t idx = 0; idx <= haystack_length - needle_length; ++idx) {
    size_t matched = 0U;
    while (matched < needle_length) {
      const unsigned char hay = (unsigned char)haystack[idx + matched];
      const unsigned char nee = (unsigned char)needle[matched];
      if (tolower(hay) != tolower(nee)) {
        break;
      }
      ++matched;
    }
    if (matched == needle_length) {
      return true;
    }
  }

  return false;
}

static bool session_editor_matches_terminator(const session_ctx_t *ctx, const char *line) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
    return session_asciiart_matches_terminator(line);
  }

  return session_bbs_matches_terminator(line);
}

static bool string_contains_token_case_insensitive(const char *haystack, const char *needle) {
  if (haystack == NULL || needle == NULL || *needle == '\0') {
    return false;
  }

  const size_t haystack_length = strlen(haystack);
  const size_t needle_length = strlen(needle);
  if (needle_length == 0U || haystack_length < needle_length) {
    return false;
  }

  for (size_t idx = 0; idx <= haystack_length - needle_length; ++idx) {
    size_t matched = 0U;
    while (matched < needle_length) {
      const unsigned char hay = (unsigned char)haystack[idx + matched];
      const unsigned char nee = (unsigned char)needle[matched];
      if (tolower(hay) != tolower(nee)) {
        break;
      }
      ++matched;
    }

    if (matched != needle_length) {
      continue;
    }

    const bool has_prev = idx > 0U;
    const bool has_next = (idx + needle_length) < haystack_length;
    const unsigned char prev = has_prev ? (unsigned char)haystack[idx - 1U] : 0U;
    const unsigned char next = has_next ? (unsigned char)haystack[idx + needle_length] : 0U;
    const bool prev_boundary = !has_prev || (!isalnum(prev) && prev != '_');
    const bool next_boundary = !has_next || (!isalnum(next) && next != '_');

    if (prev_boundary && next_boundary) {
      return true;
    }
  }

  return false;
}

static void session_extract_banner_token(const char *banner, char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (banner == NULL || *banner == '\0') {
    return;
  }

  size_t idx = 0U;
  while (banner[idx] != '\0' && isspace((unsigned char)banner[idx])) {
    ++idx;
  }

  size_t produced = 0U;
  while (banner[idx] != '\0' && !isspace((unsigned char)banner[idx])) {
    if (produced + 1U >= length) {
      break;
    }
    buffer[produced++] = banner[idx++];
  }

  if (produced == 0U) {
    snprintf(buffer, length, "%.*s", (int)length - 1, banner);
  } else {
    buffer[produced] = '\0';
  }
}

static void session_format_telnet_identity(session_ctx_t *ctx, const char *primary_label) {
  if (ctx == NULL) {
    return;
  }

  ctx->telnet_identity[0] = '\0';
  if (ctx->transport_kind != SESSION_TRANSPORT_TELNET) {
    return;
  }

  const char *label = primary_label;
  char snippet[SSH_CHATTER_TERMINAL_TYPE_LEN];
  snippet[0] = '\0';

  if (label == NULL || label[0] == '\0') {
    if (ctx->terminal_type[0] != '\0') {
      label = ctx->terminal_type;
    } else if (ctx->client_banner[0] != '\0') {
      session_extract_banner_token(ctx->client_banner, snippet, sizeof(snippet));
      if (snippet[0] != '\0') {
        label = snippet;
      }
    }
  }

  if (label == NULL || label[0] == '\0') {
    label = "unknown";
  }

  snprintf(ctx->telnet_identity, sizeof(ctx->telnet_identity), "telnet/%s", label);
}

static bool host_is_leap_year(int year) {
  if (year <= 0) {
    return false;
  }

  if ((year % 4) != 0) {
    return false;
  }
  if ((year % 100) != 0) {
    return true;
  }
  return (year % 400) == 0;
}

static struct timespec timespec_diff(const struct timespec *end, const struct timespec *start) {
  struct timespec result = {0, 0};
  if (end == NULL || start == NULL) {
    return result;
  }

  time_t sec = end->tv_sec - start->tv_sec;
  long nsec = end->tv_nsec - start->tv_nsec;
  if (nsec < 0) {
    --sec;
    nsec += 1000000000L;
  }
  if (sec < 0) {
    sec = 0;
    nsec = 0;
  }
  result.tv_sec = sec;
  result.tv_nsec = nsec;
  return result;
}

static bool host_listener_attempt_recover(host_t *host, ssh_bind bind_handle, const char *address,
                                          const char *bind_port) {
  if (host == NULL || bind_handle == NULL) {
    return false;
  }

  printf("[listener] attempting in-place recovery on %s:%s after socket error\n", address, bind_port);
  ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDADDR, address);
  ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDPORT_STR, bind_port);
  if (ssh_bind_listen(bind_handle) == SSH_OK) {
    host->listener.inplace_recoveries += 1U;
    printf("[listener] listener recovered without restart (total in-place recoveries: %u)\n",
           host->listener.inplace_recoveries);
    return true;
  }

  const char *error_message = ssh_get_error(bind_handle);
  if (error_message == NULL || error_message[0] == '\0') {
    error_message = "unknown error";
  }
  printf("[listener] in-place recovery failed: %s\n", error_message);
  return false;
}

static bool host_join_key_path(const char *directory, const char *filename, char *buffer, size_t buffer_len) {
  if (directory == NULL || filename == NULL || buffer == NULL || buffer_len == 0U) {
    return false;
  }

  const size_t dir_len = strlen(directory);
  const bool needs_separator = dir_len > 0U && directory[dir_len - 1U] != '/';
  const int written = snprintf(buffer, buffer_len, "%s%s%s", directory, needs_separator ? "/" : "",
                               filename);
  if (written < 0 || (size_t)written >= buffer_len) {
    return false;
  }

  return true;
}

static bool host_bind_algorithm_is_rsa(const char *algorithm) {
  return algorithm != NULL && strcmp(algorithm, "ssh-rsa") == 0;
}

static void host_bind_append_single_algorithm(char *buffer, size_t buffer_len, size_t *current_len,
                                              const char *algorithm) {
  if (buffer == NULL || current_len == NULL || algorithm == NULL || algorithm[0] == '\0' || buffer_len == 0U) {
    return;
  }

  const size_t usable_length = buffer_len - 1U;
  if (*current_len > usable_length) {
    *current_len = usable_length;
    buffer[usable_length] = '\0';
    return;
  }

  if (*current_len > 0U) {
    if (*current_len >= usable_length) {
      buffer[usable_length] = '\0';
      return;
    }
    buffer[*current_len] = ',';
    ++(*current_len);
  }

  size_t remaining = usable_length - *current_len;
  if (remaining == 0U) {
    buffer[*current_len] = '\0';
    return;
  }

  size_t algorithm_length = strlen(algorithm);
  if (algorithm_length > remaining) {
    algorithm_length = remaining;
  }

  memcpy(buffer + *current_len, algorithm, algorithm_length);
  *current_len += algorithm_length;
  buffer[*current_len] = '\0';
}

static void host_bind_append_algorithm(char *buffer, size_t buffer_len, size_t *current_len,
                                       const char *algorithm) {
  if (buffer == NULL || current_len == NULL || algorithm == NULL || algorithm[0] == '\0' || buffer_len == 0U) {
    return;
  }

  if (host_bind_algorithm_is_rsa(algorithm)) {
    host_bind_append_single_algorithm(buffer, buffer_len, current_len, "rsa-sha2-512");
    host_bind_append_single_algorithm(buffer, buffer_len, current_len, "rsa-sha2-256");
  }

  host_bind_append_single_algorithm(buffer, buffer_len, current_len, algorithm);
}

static bool host_bind_import_key(ssh_bind bind_handle, const char *algorithm, const char *key_path) {
  if (bind_handle == NULL || algorithm == NULL || key_path == NULL) {
    return false;
  }

  ssh_key imported_key = NULL;
  if (ssh_pki_import_privkey_file(key_path, NULL, NULL, NULL, &imported_key) != SSH_OK || imported_key == NULL) {
    char message[256];
    snprintf(message, sizeof(message), "failed to import %s host key", algorithm);
    humanized_log_error("host", message, errno != 0 ? errno : EIO);
    if (imported_key != NULL) {
      ssh_key_free(imported_key);
    }
    return false;
  }

  errno = 0;
  const int import_result = ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_IMPORT_KEY, imported_key);
  ssh_key_free(imported_key);
  if (import_result != SSH_OK) {
    const char *error_message = ssh_get_error(bind_handle);
    char message[256];
    snprintf(message, sizeof(message), "failed to register %s host key", algorithm);
    humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
    return false;
  }

  return true;
}

static bool host_bind_load_key(ssh_bind bind_handle, const host_key_definition_t *definition,
                               const char *key_path) {
  if (bind_handle == NULL || definition == NULL || key_path == NULL) {
    return false;
  }

  bool require_import = definition->requires_import;
  if (!require_import) {
    errno = 0;
    const int set_result = ssh_bind_options_set(bind_handle, definition->option, key_path);
    if (set_result == SSH_OK) {
      return true;
    }

    const char *error_message = ssh_get_error(bind_handle);
    const bool unsupported_option =
        (error_message != NULL && strstr(error_message, "Unknown ssh option") != NULL) || errno == ENOTSUP;
    if (!unsupported_option) {
      char message[256];
      snprintf(message, sizeof(message), "failed to load %s host key", definition->algorithm);
      humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
      return false;
    }
    require_import = true;
  }

  if (require_import && !definition->requires_import) {
    printf("[listener] importing %s host key due to limited libssh support\n", definition->algorithm);
  }

  return host_bind_import_key(bind_handle, definition->algorithm, key_path);
}

static void host_bind_set_optional_string(ssh_bind bind_handle, ssh_bind_options_e option, const char *value,
                                          const char *label) {
  if (bind_handle == NULL || value == NULL || value[0] == '\0') {
    return;
  }

  errno = 0;
  if (ssh_bind_options_set(bind_handle, option, value) == SSH_OK) {
    return;
  }

  const char *error_message = ssh_get_error(bind_handle);
  const bool unsupported_option =
      (error_message != NULL && strstr(error_message, "Unknown ssh option") != NULL) || errno == ENOTSUP;
  if (unsupported_option) {
    return;
  }

  char message[256];
  snprintf(message, sizeof(message), "%s", label != NULL ? label : "failed to configure listener option");
  humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
}

static struct timespec timespec_add_ms(const struct timespec *start, long milliseconds) {
  struct timespec result = {0, 0};
  if (start != NULL) {
    result = *start;
  }

  long seconds = milliseconds / 1000L;
  long remaining_ms = milliseconds % 1000L;
  result.tv_sec += seconds;
  result.tv_nsec += remaining_ms * 1000000L;
  if (result.tv_nsec >= 1000000000L) {
    result.tv_sec += result.tv_nsec / 1000000000L;
    result.tv_nsec %= 1000000000L;
  }
  return result;
}

static int timespec_compare(const struct timespec *lhs, const struct timespec *rhs) {
  if (lhs == NULL || rhs == NULL) {
    return 0;
  }
  if (lhs->tv_sec < rhs->tv_sec) {
    return -1;
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return 1;
  }
  if (lhs->tv_nsec < rhs->tv_nsec) {
    return -1;
  }
  if (lhs->tv_nsec > rhs->tv_nsec) {
    return 1;
  }
  return 0;
}

static bool host_try_load_motd_from_path(host_t *host, const char *path);

static struct timespec host_stat_mtime(const struct stat *info) {
  struct timespec result = {0, 0};
  if (info == NULL) {
    return result;
  }

#if defined(__APPLE__)
  result.tv_sec = info->st_mtimespec.tv_sec;
  result.tv_nsec = info->st_mtimespec.tv_nsec;
#elif defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(__USE_XOPEN2K8)
  result.tv_sec = info->st_mtim.tv_sec;
  result.tv_nsec = info->st_mtim.tv_nsec;
#else
  result.tv_sec = info->st_mtime;
  result.tv_nsec = 0;
#endif

  if (result.tv_sec < 0) {
    result.tv_sec = 0;
  }
  if (result.tv_nsec < 0) {
    result.tv_nsec = 0;
  }
  return result;
}

static void host_maybe_reload_motd_from_file(host_t *host) {
  if (host == NULL) {
    return;
  }

  char stored_path[PATH_MAX];
  stored_path[0] = '\0';
  struct timespec last_loaded = {0, 0};
  bool had_file = false;

  pthread_mutex_lock(&host->lock);
  if (host->motd_path[0] != '\0') {
    snprintf(stored_path, sizeof(stored_path), "%s", host->motd_path);
    last_loaded = host->motd_last_modified;
    had_file = host->motd_has_file;
  }
  pthread_mutex_unlock(&host->lock);

  if (stored_path[0] == '\0') {
    return;
  }

  char resolved_path[PATH_MAX];
  resolved_path[0] = '\0';

  if (stored_path[0] == '~' && (stored_path[1] == '\0' || stored_path[1] == '/')) {
    const char *home = getenv("HOME");
    if (home != NULL && home[0] != '\0') {
      int expanded = snprintf(resolved_path, sizeof(resolved_path), "%s%s", home, stored_path + 1);
      if (expanded <= 0 || (size_t)expanded >= sizeof(resolved_path)) {
        resolved_path[0] = '\0';
      }
    }
  }

  const char *path_to_try = resolved_path[0] != '\0' ? resolved_path : stored_path;

  struct stat file_info;
  if (stat(path_to_try, &file_info) != 0 || !S_ISREG(file_info.st_mode)) {
    if (!had_file) {
      (void)host_try_load_motd_from_path(host, path_to_try);
    }
    if (had_file) {
      pthread_mutex_lock(&host->lock);
      if (host->motd_has_file && strncmp(host->motd_path, stored_path, sizeof(host->motd_path)) == 0) {
        host->motd_has_file = false;
        host->motd_last_modified.tv_sec = 0;
        host->motd_last_modified.tv_nsec = 0L;
      }
      pthread_mutex_unlock(&host->lock);
    }
    return;
  }

  struct timespec modified = host_stat_mtime(&file_info);

  if (had_file && modified.tv_sec == last_loaded.tv_sec && modified.tv_nsec == last_loaded.tv_nsec) {
    return;
  }

  (void)host_try_load_motd_from_path(host, path_to_try);
}

static unsigned session_simple_hash(const char *text) {
  unsigned hash = 5381U;
  if (text == NULL) {
    return hash;
  }

  for (const unsigned char *cursor = (const unsigned char *)text; *cursor != '\0'; ++cursor) {
    hash = (hash * 33U) ^ *cursor;
  }
  return hash;
}

static void session_build_captcha_prompt(session_ctx_t *ctx, captcha_prompt_t *prompt) {
  if (prompt == NULL) {
    return;
  }

  memset(prompt, 0, sizeof(*prompt));

  unsigned basis = session_simple_hash(ctx != NULL ? ctx->user.name : "user");
  basis ^= session_simple_hash(ctx != NULL ? ctx->client_ip : "ip");

  unsigned entropy = 0U;
  struct timespec now = {0, 0};
  if (clock_gettime(CLOCK_REALTIME, &now) == 0) {
    uint64_t now_sec = (uint64_t)now.tv_sec;
    entropy ^= (unsigned)now_sec;
    entropy ^= (unsigned)(now_sec >> 32);
    entropy ^= (unsigned)now.tv_nsec;
  } else {
    uint64_t fallback = (uint64_t)time(NULL);
    entropy ^= (unsigned)fallback;
    entropy ^= (unsigned)(fallback >> 32);
  }

  host_t *host = (ctx != NULL) ? ctx->owner : NULL;
  if (host != NULL) {
    pthread_mutex_lock(&host->lock);
    uint64_t nonce = ++host->captcha_nonce;
    pthread_mutex_unlock(&host->lock);
    entropy ^= (unsigned)nonce;
    entropy ^= (unsigned)(nonce >> 32);
  }

  basis ^= entropy;

  const unsigned variant_seed = basis ^ (basis >> 16U) ^ (entropy << 1U);
  unsigned prng_state = variant_seed | 1U;

  session_fill_digit_sum_prompt(prompt, &prng_state);
}

typedef struct {
  const char *name;
  const char *code;
} color_entry_t;

static const color_entry_t USER_COLOR_MAP[] = {
  {"black", ANSI_BLACK},          {"red", ANSI_RED},
  {"green", ANSI_GREEN},          {"yellow", ANSI_YELLOW},
  {"blue", ANSI_BLUE},           {"magenta", ANSI_MAGENTA},
  {"cyan", ANSI_CYAN},           {"white", ANSI_WHITE},
  {"default", ANSI_DEFAULT},

  {"검정", ANSI_BLACK},           {"검은색", ANSI_BLACK},
  {"黒", ANSI_BLACK},             {"黑", ANSI_BLACK},
  {"黑色", ANSI_BLACK},           {"черный", ANSI_BLACK},
  {"чёрный", ANSI_BLACK},

  {"빨강", ANSI_RED},            {"빨간색", ANSI_RED},
  {"赤", ANSI_RED},               {"红", ANSI_RED},
  {"红色", ANSI_RED},             {"красный", ANSI_RED},

  {"초록", ANSI_GREEN},          {"초록색", ANSI_GREEN},
  {"緑", ANSI_GREEN},             {"绿", ANSI_GREEN},
  {"绿色", ANSI_GREEN},           {"зелёный", ANSI_GREEN},
  {"зеленый", ANSI_GREEN},

  {"노랑", ANSI_YELLOW},         {"노란색", ANSI_YELLOW},
  {"黄色", ANSI_YELLOW},          {"黄", ANSI_YELLOW},
  {"黄色い", ANSI_YELLOW},        {"黃色", ANSI_YELLOW},
  {"жёлтый", ANSI_YELLOW},        {"желтый", ANSI_YELLOW},

  {"파랑", ANSI_BLUE},           {"파란색", ANSI_BLUE},
  {"青", ANSI_BLUE},              {"青色", ANSI_BLUE},
  {"蓝", ANSI_BLUE},             {"蓝色", ANSI_BLUE},
  {"синий", ANSI_BLUE},

  {"마젠타", ANSI_MAGENTA},      {"자주", ANSI_MAGENTA},
  {"보라", ANSI_MAGENTA},        {"보라색", ANSI_MAGENTA},
  {"マゼンタ", ANSI_MAGENTA},      {"紫", ANSI_MAGENTA},
  {"洋红", ANSI_MAGENTA},         {"品红", ANSI_MAGENTA},
  {"紫色", ANSI_MAGENTA},        {"пурпурный", ANSI_MAGENTA},
  {"фиолетовый", ANSI_MAGENTA},

  {"시안", ANSI_CYAN},           {"청록", ANSI_CYAN},
  {"하늘", ANSI_CYAN},           {"하늘색", ANSI_CYAN},
  {"シアン", ANSI_CYAN},          {"水色", ANSI_CYAN},
  {"青绿", ANSI_CYAN},           {"青色", ANSI_CYAN},
  {"青綠", ANSI_CYAN},           {"青藍", ANSI_CYAN},
  {"青蓝", ANSI_CYAN},           {"циан", ANSI_CYAN},
  {"бирюзовый", ANSI_CYAN},      {"голубой", ANSI_CYAN},

  {"하양", ANSI_WHITE},          {"흰색", ANSI_WHITE},
  {"白", ANSI_WHITE},             {"白色", ANSI_WHITE},
  {"белый", ANSI_WHITE},

  {"기본", ANSI_DEFAULT},        {"기본값", ANSI_DEFAULT},
  {"デフォルト", ANSI_DEFAULT},    {"既定", ANSI_DEFAULT},
  {"默认", ANSI_DEFAULT},         {"默認", ANSI_DEFAULT},
  {"по умолчанию", ANSI_DEFAULT},

  {"bright-black", ANSI_BRIGHT_BLACK},   {"bright-red", ANSI_BRIGHT_RED},
  {"bright-green", ANSI_BRIGHT_GREEN}, {"bright-yellow", ANSI_BRIGHT_YELLOW},
  {"bright-blue", ANSI_BRIGHT_BLUE},   {"bright-magenta", ANSI_BRIGHT_MAGENTA},
  {"bright-cyan", ANSI_BRIGHT_CYAN},   {"bright-white", ANSI_BRIGHT_WHITE},

  {"밝은검정", ANSI_BRIGHT_BLACK}, {"회색", ANSI_BRIGHT_BLACK},
  {"明るい黒", ANSI_BRIGHT_BLACK}, {"グレー", ANSI_BRIGHT_BLACK},
  {"灰色", ANSI_BRIGHT_BLACK},    {"серый", ANSI_BRIGHT_BLACK},

  {"밝은빨강", ANSI_BRIGHT_RED},  {"밝은빨간색", ANSI_BRIGHT_RED},
  {"明るい赤", ANSI_BRIGHT_RED},   {"亮红", ANSI_BRIGHT_RED},
  {"亮红色", ANSI_BRIGHT_RED},     {"ярко-красный", ANSI_BRIGHT_RED},

  {"밝은초록", ANSI_BRIGHT_GREEN}, {"밝은초록색", ANSI_BRIGHT_GREEN},
  {"明るい緑", ANSI_BRIGHT_GREEN}, {"亮绿", ANSI_BRIGHT_GREEN},
  {"亮绿色", ANSI_BRIGHT_GREEN},   {"ярко-зелёный", ANSI_BRIGHT_GREEN},
  {"ярко-зеленый", ANSI_BRIGHT_GREEN},

  {"밝은노랑", ANSI_BRIGHT_YELLOW}, {"밝은노란색", ANSI_BRIGHT_YELLOW},
  {"明るい黄", ANSI_BRIGHT_YELLOW}, {"亮黄", ANSI_BRIGHT_YELLOW},
  {"亮黄色", ANSI_BRIGHT_YELLOW},   {"ярко-жёлтый", ANSI_BRIGHT_YELLOW},
  {"ярко-желтый", ANSI_BRIGHT_YELLOW},

  {"밝은파랑", ANSI_BRIGHT_BLUE}, {"밝은파란색", ANSI_BRIGHT_BLUE},
  {"明るい青", ANSI_BRIGHT_BLUE},  {"亮蓝", ANSI_BRIGHT_BLUE},
  {"亮蓝色", ANSI_BRIGHT_BLUE},    {"ярко-синий", ANSI_BRIGHT_BLUE},

  {"밝은마젠타", ANSI_BRIGHT_MAGENTA}, {"밝은자주", ANSI_BRIGHT_MAGENTA},
  {"밝은보라", ANSI_BRIGHT_MAGENTA},   {"밝은보라색", ANSI_BRIGHT_MAGENTA},
  {"明るいマゼンタ", ANSI_BRIGHT_MAGENTA}, {"明るい紫", ANSI_BRIGHT_MAGENTA},
  {"亮洋红", ANSI_BRIGHT_MAGENTA}, {"亮品红", ANSI_BRIGHT_MAGENTA},
  {"亮紫色", ANSI_BRIGHT_MAGENTA}, {"ярко-пурпурный", ANSI_BRIGHT_MAGENTA},
  {"ярко-фиолетовый", ANSI_BRIGHT_MAGENTA},

  {"밝은시안", ANSI_BRIGHT_CYAN}, {"밝은청록", ANSI_BRIGHT_CYAN},
  {"밝은하늘", ANSI_BRIGHT_CYAN}, {"밝은하늘색", ANSI_BRIGHT_CYAN},
  {"明るいシアン", ANSI_BRIGHT_CYAN}, {"明るい水色", ANSI_BRIGHT_CYAN},
  {"亮青色", ANSI_BRIGHT_CYAN},   {"亮青绿", ANSI_BRIGHT_CYAN},
  {"亮青綠", ANSI_BRIGHT_CYAN},   {"亮青藍", ANSI_BRIGHT_CYAN},
  {"亮青蓝", ANSI_BRIGHT_CYAN},   {"ярко-циан", ANSI_BRIGHT_CYAN},
  {"ярко-бирюзовый", ANSI_BRIGHT_CYAN}, {"ярко-голубой", ANSI_BRIGHT_CYAN},

  {"밝은하양", ANSI_BRIGHT_WHITE}, {"밝은흰색", ANSI_BRIGHT_WHITE},
  {"明るい白", ANSI_BRIGHT_WHITE}, {"亮白", ANSI_BRIGHT_WHITE},
  {"亮白色", ANSI_BRIGHT_WHITE},   {"ярко-белый", ANSI_BRIGHT_WHITE},
};

static const color_entry_t HIGHLIGHT_COLOR_MAP[] = {
  {"black", ANSI_BG_BLACK},       {"red", ANSI_BG_RED},
  {"green", ANSI_BG_GREEN},       {"yellow", ANSI_BG_YELLOW},
  {"blue", ANSI_BG_BLUE},        {"magenta", ANSI_BG_MAGENTA},
  {"cyan", ANSI_BG_CYAN},        {"white", ANSI_BG_WHITE},
  {"default", ANSI_BG_DEFAULT},

  {"검정", ANSI_BG_BLACK},         {"검은색", ANSI_BG_BLACK},
  {"黒", ANSI_BG_BLACK},           {"黑", ANSI_BG_BLACK},
  {"黑色", ANSI_BG_BLACK},         {"черный", ANSI_BG_BLACK},
  {"чёрный", ANSI_BG_BLACK},

  {"빨강", ANSI_BG_RED},          {"빨간색", ANSI_BG_RED},
  {"赤", ANSI_BG_RED},             {"红", ANSI_BG_RED},
  {"红色", ANSI_BG_RED},           {"красный", ANSI_BG_RED},

  {"초록", ANSI_BG_GREEN},        {"초록색", ANSI_BG_GREEN},
  {"緑", ANSI_BG_GREEN},           {"绿", ANSI_BG_GREEN},
  {"绿色", ANSI_BG_GREEN},         {"зелёный", ANSI_BG_GREEN},
  {"зеленый", ANSI_BG_GREEN},

  {"노랑", ANSI_BG_YELLOW},       {"노란색", ANSI_BG_YELLOW},
  {"黄色", ANSI_BG_YELLOW},        {"黄", ANSI_BG_YELLOW},
  {"黄色い", ANSI_BG_YELLOW},      {"黃色", ANSI_BG_YELLOW},
  {"жёлтый", ANSI_BG_YELLOW},      {"желтый", ANSI_BG_YELLOW},

  {"파랑", ANSI_BG_BLUE},         {"파란색", ANSI_BG_BLUE},
  {"青", ANSI_BG_BLUE},            {"青色", ANSI_BG_BLUE},
  {"蓝", ANSI_BG_BLUE},           {"蓝色", ANSI_BG_BLUE},
  {"синий", ANSI_BG_BLUE},

  {"마젠타", ANSI_BG_MAGENTA},    {"자주", ANSI_BG_MAGENTA},
  {"보라", ANSI_BG_MAGENTA},      {"보라색", ANSI_BG_MAGENTA},
  {"マゼンタ", ANSI_BG_MAGENTA},    {"紫", ANSI_BG_MAGENTA},
  {"洋红", ANSI_BG_MAGENTA},       {"品红", ANSI_BG_MAGENTA},
  {"紫色", ANSI_BG_MAGENTA},      {"пурпурный", ANSI_BG_MAGENTA},
  {"фиолетовый", ANSI_BG_MAGENTA},

  {"시안", ANSI_BG_CYAN},         {"청록", ANSI_BG_CYAN},
  {"하늘", ANSI_BG_CYAN},         {"하늘색", ANSI_BG_CYAN},
  {"シアン", ANSI_BG_CYAN},        {"水色", ANSI_BG_CYAN},
  {"青绿", ANSI_BG_CYAN},         {"青色", ANSI_BG_CYAN},
  {"青綠", ANSI_BG_CYAN},         {"青藍", ANSI_BG_CYAN},
  {"青蓝", ANSI_BG_CYAN},         {"циан", ANSI_BG_CYAN},
  {"бирюзовый", ANSI_BG_CYAN},    {"голубой", ANSI_BG_CYAN},

  {"하양", ANSI_BG_WHITE},        {"흰색", ANSI_BG_WHITE},
  {"白", ANSI_BG_WHITE},           {"白色", ANSI_BG_WHITE},
  {"белый", ANSI_BG_WHITE},

  {"기본", ANSI_BG_DEFAULT},      {"기본값", ANSI_BG_DEFAULT},
  {"デフォルト", ANSI_BG_DEFAULT},  {"既定", ANSI_BG_DEFAULT},
  {"默认", ANSI_BG_DEFAULT},       {"默認", ANSI_BG_DEFAULT},
  {"по умолчанию", ANSI_BG_DEFAULT},

  {"bright-black", ANSI_BG_BRIGHT_BLACK}, {"bright-red", ANSI_BG_BRIGHT_RED},
  {"bright-green", ANSI_BG_BRIGHT_GREEN}, {"bright-yellow", ANSI_BG_BRIGHT_YELLOW},
  {"bright-blue", ANSI_BG_BRIGHT_BLUE},  {"bright-magenta", ANSI_BG_BRIGHT_MAGENTA},
  {"bright-cyan", ANSI_BG_BRIGHT_CYAN},  {"bright-white", ANSI_BG_BRIGHT_WHITE},

  {"밝은검정", ANSI_BG_BRIGHT_BLACK}, {"회색", ANSI_BG_BRIGHT_BLACK},
  {"明るい黒", ANSI_BG_BRIGHT_BLACK}, {"グレー", ANSI_BG_BRIGHT_BLACK},
  {"灰色", ANSI_BG_BRIGHT_BLACK},    {"серый", ANSI_BG_BRIGHT_BLACK},

  {"밝은빨강", ANSI_BG_BRIGHT_RED},  {"밝은빨간색", ANSI_BG_BRIGHT_RED},
  {"明るい赤", ANSI_BG_BRIGHT_RED},   {"亮红", ANSI_BG_BRIGHT_RED},
  {"亮红色", ANSI_BG_BRIGHT_RED},     {"ярко-красный", ANSI_BG_BRIGHT_RED},

  {"밝은초록", ANSI_BG_BRIGHT_GREEN}, {"밝은초록색", ANSI_BG_BRIGHT_GREEN},
  {"明るい緑", ANSI_BG_BRIGHT_GREEN}, {"亮绿", ANSI_BG_BRIGHT_GREEN},
  {"亮绿色", ANSI_BG_BRIGHT_GREEN},   {"ярко-зелёный", ANSI_BG_BRIGHT_GREEN},
  {"ярко-зеленый", ANSI_BG_BRIGHT_GREEN},

  {"밝은노랑", ANSI_BG_BRIGHT_YELLOW}, {"밝은노란색", ANSI_BG_BRIGHT_YELLOW},
  {"明るい黄", ANSI_BG_BRIGHT_YELLOW}, {"亮黄", ANSI_BG_BRIGHT_YELLOW},
  {"亮黄色", ANSI_BG_BRIGHT_YELLOW},   {"ярко-жёлтый", ANSI_BG_BRIGHT_YELLOW},
  {"ярко-желтый", ANSI_BG_BRIGHT_YELLOW},

  {"밝은파랑", ANSI_BG_BRIGHT_BLUE}, {"밝은파란색", ANSI_BG_BRIGHT_BLUE},
  {"明るい青", ANSI_BG_BRIGHT_BLUE},  {"亮蓝", ANSI_BG_BRIGHT_BLUE},
  {"亮蓝色", ANSI_BG_BRIGHT_BLUE},    {"ярко-синий", ANSI_BG_BRIGHT_BLUE},

  {"밝은마젠타", ANSI_BG_BRIGHT_MAGENTA}, {"밝은자주", ANSI_BG_BRIGHT_MAGENTA},
  {"밝은보라", ANSI_BG_BRIGHT_MAGENTA},   {"밝은보라색", ANSI_BG_BRIGHT_MAGENTA},
  {"明るいマゼンタ", ANSI_BG_BRIGHT_MAGENTA}, {"明るい紫", ANSI_BG_BRIGHT_MAGENTA},
  {"亮洋红", ANSI_BG_BRIGHT_MAGENTA}, {"亮品红", ANSI_BG_BRIGHT_MAGENTA},
  {"亮紫色", ANSI_BG_BRIGHT_MAGENTA}, {"ярко-пурпурный", ANSI_BG_BRIGHT_MAGENTA},
  {"ярко-фиолетовый", ANSI_BG_BRIGHT_MAGENTA},

  {"밝은시안", ANSI_BG_BRIGHT_CYAN}, {"밝은청록", ANSI_BG_BRIGHT_CYAN},
  {"밝은하늘", ANSI_BG_BRIGHT_CYAN}, {"밝은하늘색", ANSI_BG_BRIGHT_CYAN},
  {"明るいシアン", ANSI_BG_BRIGHT_CYAN}, {"明るい水色", ANSI_BG_BRIGHT_CYAN},
  {"亮青色", ANSI_BG_BRIGHT_CYAN},   {"亮青绿", ANSI_BG_BRIGHT_CYAN},
  {"亮青綠", ANSI_BG_BRIGHT_CYAN},   {"亮青藍", ANSI_BG_BRIGHT_CYAN},
  {"亮青蓝", ANSI_BG_BRIGHT_CYAN},   {"ярко-циан", ANSI_BG_BRIGHT_CYAN},
  {"ярко-бирюзовый", ANSI_BG_BRIGHT_CYAN}, {"ярко-голубой", ANSI_BG_BRIGHT_CYAN},

  {"밝은하양", ANSI_BG_BRIGHT_WHITE}, {"밝은흰색", ANSI_BG_BRIGHT_WHITE},
  {"明るい白", ANSI_BG_BRIGHT_WHITE}, {"亮白", ANSI_BG_BRIGHT_WHITE},
  {"亮白色", ANSI_BG_BRIGHT_WHITE},   {"ярко-белый", ANSI_BG_BRIGHT_WHITE},
};

typedef struct palette_descriptor {
  const char *name;
  const char *description;
  const char *user_color_name;
  const char *user_highlight_name;
  bool user_is_bold;
  const char *system_fg_name;
  const char *system_bg_name;
  const char *system_highlight_name;
  bool system_is_bold;
} palette_descriptor_t;

static const palette_descriptor_t PALETTE_DEFINITIONS[] = {
  {"windows", "High contrast palette reminiscent of Windows", "cyan", "blue", true, "white", "blue", "yellow", true},
  {"gnu-linux", "Modern, elegant, and free. the universal rhythm of your workflow.", "bright-green", "black", true, "blue", "black", "bright-yellow", true},
  {"macos", "Precision in silence. Minimalist contemporary unix.", "bright-white", "black", false, "bright-blue", "black", "white", false},
  {"freebsd", "Rigid and graceful BSD. The biggest 'True UNIX'", "bright-red", "black", false, "red", "black", "bright-white", false},
  {"solaris", "Ancient sun of enterprise UNIX: Sun, Machine, nostalgia.", "bright-yellow", "black", true, "bright-red", "black", "bright-white", true},
  {"openbsd-fortress", "Security through simplicity. calm blue walls over disciplined darkness.", "bright-blue", "black", false, "bright-white", "black", "cyan", false},
  {"netbsd-universal", "Runs on anything. Maybe your fridge, too?", "bright-cyan", "black", false, "bright-white", "black", "bright-yellow", false},

  {"moe", "Soft magenta accents with playful highlights", "bright-magenta", "white", true, "white", "bright-magenta", "cyan", true},
  {"neon-genesis-evangelion", "Sho-nen yo Shin-wa ni nare--", "bright-red", "white", true, "white", "bright-magenta", "blue", true},
  {"megami", "Japanese anime goddess cliché", "bright-white", "black", false, "bright-yellow", "blue", "cyan", false},

  {"clean", "Balanced neutral palette", "default", "default", false, "white", "default", "default", false},
  {"adwaita", "Bright background inspired by GNOME Adwaita", "blue", "default", false, "blue", "bright-white", "white", true},

  {"80shacker", "Bright monochrome green inspired by old CRT", "bright-green", "default", true, "bright-green", "default", "default", true},
  {"plato", "Bright monochrome yellow inspired by old Amber CRT", "yellow", "default", false, "yellow", "default", "default", false},
  {"atarist", "Sharp paper-white monochrome for high-res work", "bright-white", "black", true, "bright-white", "black", "black", false},
  {"win95bsod", "High-contrast blue screen of death style", "bright-white", "blue", true, "bright-white", "blue", "cyan", true},
  {"chn-hanzi", "Bright cyan high-clarity Chinese text terminal", "bright-cyan", "black", true, "white", "black", "cyan", true},

  {"usa-flag", "Flag blue base with red/white highlights", "bright-white", "blue", true, "red", "blue", "bright-white", true},
  {"jpn-flag", "Minimalist white with rising sun red accent", "bright-white", "black", false, "red", "black", "black", true},
  {"chn-flag", "Star-red background with lucky yellow text", "bright-yellow", "red", true, "white", "red", "white", true},
  {"rus-flag", "Tricolor base with strong red emphasis", "bright-white", "blue", true, "red", "blue", "bright-white", true},
  {"de-flag", "Tricolor base with strong red/yellow emphasis", "bright-black", "black", true, "yellow", "black", "red", true},
  {"holy-light", "Christian sacred light on pure white/blue base", "bright-white", "blue", false, "blue", "black", "yellow", true},

  {"islam", "Iconic color of muslim, white/green base", "bright-white", "green", false, "green", "black", "bright-white", true},
  {"dharma-ochre", "Ochre robes of enlightenment and vitality", "yellow", "black", true, "red", "black", "yellow", true},
  {"yin-yang", "Balance of Black and White with Jade accent", "white", "black", false, "green", "black", "white", false},

  {"soviet-cold", "Cold blue/white terminal for scientific systems", "white", "blue", false, "white", "cyan", "blue", true},
  {"hi-tel", "1990s Korean BBS blue background and text style", "bright-white", "blue", true, "bright-white", "blue", "magenta", true},
  {"amiga-cli", "AmigaOS style with cyan/blue", "cyan", "blue", true, "cyan", "blue", "blue", true},
  {"jpn-pc98", "NEC PC-9801 subtle, earthy low-res tones", "yellow", "black", false, "red", "black", "yellow", false},
  {"deep-blue", "IBM Supercomputer monitoring interface style", "white", "blue", true, "cyan", "blue", "white", true},

  {"korea", "Taegeuk-gi inspired black base with red and blue accents", "bright-blue", "blue", true, "bright-white", "blue", "red", true},

  {"neo-seoul", "Neon skyline of Gangnam and Hongdae: glowing magenta and cyan lights on dark asphalt", "bright-magenta", "black", true, "bright-cyan", "black", "cyan", true},
  {"incheon-industrial", "Metallic cranes and sodium streetlights of Incheon docks", "bright-yellow", "black", true, "bright-yellow", "black", "bright-red", true},
  {"gyeonggi-modern", "Suburban calm of modern Korea. asphalt gray and warm window light", "bright-white", "black", false, "bright-yellow", "black", "bright-cyan", false},
  {"korean-palace", "Royal dancheong harmony: jade green, vermilion red, and gold over black lacquer", "bright-yellow", "black", true, "red", "black", "green", false},

  {"gyeongsangbukdo", "Stoic mountains and agricultural spirit. stone, pine, and the quiet gold of temples", "bright-yellow", "black", false, "bright-green", "black", "bright-white", false},
  {"daegu-summer", "The biggest, the hottest of north gyeongsang: Blazing red-orange heat and festival gold under night sky", "bright-red", "black", true, "bright-yellow", "black", "yellow", true},
  {"gyeongju-heritage", "Eternal relics and golden crowns: moonlit stone and ancient buddhism with blue flag of shilla military force", "bright-white", "black", false, "bright-yellow", "black", "blue", false},
  {"kangwon-winter", "Cold white peaks and blue shadows of Gangwon’s frozen dawn", "bright-white", "blue", true, "bright-cyan", "blue", "white", true},
  {"ulsan-steel", "Molten metal glow inside heavy industry furnace halls", "bright-red", "black", true, "bright-yellow", "black", "red", true},

  {"jeolla-seaside", "Quiet sea and horizon light of Mokpo and Yeosu nights", "bright-cyan", "black", false, "cyan", "black", "bright-blue", true},
  {"gwangju-biennale", "Experimental art city with a heritage of democracy: violet neon and philosophical blue", "bright-magenta", "black", true, "bright-blue", "black", "magenta", true},
  {"jeonju-hanok", "The symbol of north jeolla. warm roofs and calm golden light", "bright-yellow", "black", false, "yellow", "black", "bright-white", false},

  {"daejeon-tech", "Futuristic research district glow: clean LED light on steel gray night", "white", "black", true, "white", "black", "bright-green", true},
  {"sejong-night", "Balanced dark-blue administration city under cool LED light", "bright-white", "blue", true, "bright-cyan", "blue", "white", true},
  {"cheongju-intellect", "Scholarly ink and soft dawn over hills: serene blue clarity", "bright-cyan", "black", false, "bright-white", "black", "cyan", false},
  {"chungcheong-field", "Muted greens and dust gold of inland farmlands", "yellow", "black", false, "green", "black", "yellow", false},

  {"jeju-rock", "Volcanic basalt, moss green, and deep sea mist of Jeju Island", "bright-green", "black", false, "bright-cyan", "black", "green", false},

  {"gyeongsangnamdo", "Sea breeze and industry — blue steel, orange dusk, and vibrant harbors", "bright-blue", "black", true, "bright-yellow", "black", "bright-cyan", true},
  {"busan-harbor", "Night harbor lights and steel-blue waters of Busan Port", "bright-blue", "black", true, "cyan", "black", "bright-blue", true},

  {"han", "Deep unresolved sorrow and austere beauty pale blue and gray layers", "bright-cyan", "blue", false, "white", "blue", "bright-white", false},
  {"jeong", "Warm emotional bonds and communal comfort soft red and gold glow on darkness", "bright-red", "black", true, "black", "black", "bright-yellow", true},
  {"heung", "Joyful energy and dynamic spirit: brilliant magenta and yellow over black", "bright-magenta", "black", true, "bright-yellow", "black", "magenta", true},
  {"nunchi", "Subtle perception and quiet adaptation: dim neutral tones with cyan glints", "white", "black", false, "bright-cyan", "black", "cyan", false},

  {"pcbang-night", "Late-night gaming neon: cold blue LEDs, energy drink, and so on", "bright-cyan", "black", true, "bright-red", "black", "bright-blue", true},
  {"alcohol", "Soju nights and neon haze: industrial green bottles and pink laughter", "bright-green", "black", true, "bright-magenta", "black", "green", true},

  {"korean-hardcore", "I don't wanna die yet! neon blood and cold steel over asphalt black", "bright-red", "black", true, "bright-blue", "black", "bright-red", true},
  {"korean-nationalists", "Slightly exclusive types. you know the kind.", "bright-green", "black", true, "bright-blue", "black", "bright-cyan", true},

  {"medieval-korea", "Celadon grace and temple gold over aged ink-black lacquer", "bright-cyan", "black", false, "bright-yellow", "black", "cyan", false},
  {"stoneage-korea", "Primitive contrast of pale clothing and ground stone tools - raw earth and silence", "bright-white", "black", false, "bright-yellow", "black", "white", false},

  {"flame-and-blood", "An East Asian war of 1592–1598. A great conflict akin to a world war, where flame met blood and nothing could be forsaken.", "bright-blue", "black", true, "bright-yellow", "black", "red", true},
  {"korean-war", "The Korean War: an unforgettable sorrow beneath ash, blood, and snow.", "bright-white", "black", false, "bright-red", "black", "white", false},
  {"independence-spirit", "The spirit of independence. A soul that we must remember.", "bright-red", "black", true, "blue", "black", "bright-yellow", true},
};

typedef int (*accept_channel_fn_t)(ssh_message, ssh_channel);

#if defined(__GNUC__)
extern int ssh_message_channel_request_open_reply_accept_channel(ssh_message message,
                                                                 ssh_channel channel)
    __attribute__((weak));
#endif

static void resolve_accept_channel_once(void);
static accept_channel_fn_t g_accept_channel_fn = NULL;
static pthread_once_t g_accept_channel_once = PTHREAD_ONCE_INIT;

static accept_channel_fn_t resolve_accept_channel_fn(void) {
  pthread_once(&g_accept_channel_once, resolve_accept_channel_once);
  return g_accept_channel_fn;
}

static void resolve_accept_channel_once(void) {
#if defined(__GNUC__)
  if (ssh_message_channel_request_open_reply_accept_channel != NULL) {
    g_accept_channel_fn = ssh_message_channel_request_open_reply_accept_channel;
    return;
  }
#endif

  static const char *kSymbol = "ssh_message_channel_request_open_reply_accept_channel";

#if defined(RTLD_DEFAULT)
  g_accept_channel_fn = (accept_channel_fn_t)dlsym(RTLD_DEFAULT, kSymbol);
  if (g_accept_channel_fn != NULL) {
    return;
  }
#endif

  const char *candidates[] = {"libssh.so.4", "libssh.so", "libssh.dylib"};
  for (size_t idx = 0; idx < sizeof(candidates) / sizeof(candidates[0]); ++idx) {
    const char *name = candidates[idx];
    void *handle = dlopen(name, RTLD_LAZY | RTLD_LOCAL);
    if (handle == NULL) {
      handle = dlopen(name, RTLD_LAZY);
    }
    if (handle == NULL) {
      continue;
    }

    g_accept_channel_fn = (accept_channel_fn_t)dlsym(handle, kSymbol);
    if (g_accept_channel_fn != NULL) {
      return;
    }
  }
}

static void trim_whitespace_inplace(char *text);
static const char *lookup_color_code(const color_entry_t *entries, size_t entry_count, const char *name);
static bool parse_bool_token(const char *token, bool *value);
static bool session_transport_active(const session_ctx_t *ctx);
static void session_transport_request_close(session_ctx_t *ctx);
static void session_channel_write(session_ctx_t *ctx, const void *data, size_t length);
static bool session_channel_write_cp437(session_ctx_t *ctx, const char *data, size_t length);
static bool session_channel_write_utf16(session_ctx_t *ctx, const char *data, size_t length);
static bool session_channel_write_utf16_segment(session_ctx_t *ctx, const char *data, size_t length);
static size_t session_utf8_decode_codepoint(const unsigned char *data, size_t length, uint32_t *codepoint);
static bool session_utf8_to_utf16le(const char *input, size_t length, unsigned char *output, size_t capacity,
                                    size_t *produced);
static bool session_channel_write_all(session_ctx_t *ctx, const void *data, size_t length);
static bool session_channel_wait_writable(session_ctx_t *ctx, int timeout_ms);
static void session_channel_log_write_failure(session_ctx_t *ctx, const char *reason);
static int session_transport_read(session_ctx_t *ctx, void *buffer, size_t length, int timeout_ms);
static bool session_transport_is_open(const session_ctx_t *ctx);
static bool session_transport_is_eof(const session_ctx_t *ctx);
static void session_apply_background_fill(session_ctx_t *ctx);
static void session_write_rendered_line(session_ctx_t *ctx, const char *render_source);
static void session_send_caption_line(session_ctx_t *ctx, const char *message);
static void session_render_caption_with_offset(session_ctx_t *ctx, const char *message, size_t move_up);
static void session_send_line(session_ctx_t *ctx, const char *message);
static void session_send_plain_line(session_ctx_t *ctx, const char *message);
static void session_send_system_line(session_ctx_t *ctx, const char *message);
static void session_send_raw_text(session_ctx_t *ctx, const char *text);
static void session_send_raw_text_bulk(session_ctx_t *ctx, const char *text);
static bool session_render_external_banner(session_ctx_t *ctx);
static void session_render_banner_ascii(session_ctx_t *ctx);
static void session_render_prelogin_banner(session_ctx_t *ctx);
static session_ui_language_t session_client_geo_language(const session_ctx_t *ctx);
static void session_render_prelogin_language_prompt(session_ctx_t *ctx);
static void session_render_banner(session_ctx_t *ctx);
static const char *session_editor_terminator(const session_ctx_t *ctx);
static bool session_editor_matches_terminator(const session_ctx_t *ctx, const char *line);
static size_t session_editor_body_capacity(const session_ctx_t *ctx);
static size_t session_editor_max_lines(const session_ctx_t *ctx);
static void session_format_separator_line(session_ctx_t *ctx, const char *label, char *out, size_t length);
static void session_render_separator(session_ctx_t *ctx, const char *label);
static void session_clear_screen(session_ctx_t *ctx);
static void session_bbs_prepare_canvas(session_ctx_t *ctx);
static void session_bbs_render_editor(session_ctx_t *ctx, const char *status);
static void session_bbs_recalculate_line_count(session_ctx_t *ctx);
static bool session_bbs_get_line_range(const session_ctx_t *ctx, size_t line_index, size_t *start, size_t *length);
static void session_bbs_copy_line(const session_ctx_t *ctx, size_t line_index, char *buffer, size_t length);
static bool session_bbs_append_line(session_ctx_t *ctx, const char *line, char *status, size_t status_length);
static bool session_bbs_replace_line(session_ctx_t *ctx, size_t line_index, const char *line, char *status,
                                     size_t status_length);
static void session_bbs_move_cursor(session_ctx_t *ctx, int direction);
static bool session_bbs_is_admin_only_tag(const char *tag);
static void session_bbs_buffer_breaking_notice(session_ctx_t *ctx, const char *message);
static bool session_bbs_should_defer_breaking(session_ctx_t *ctx, const char *message);
static void session_render_prompt(session_ctx_t *ctx, bool include_separator);
static void session_refresh_input_line(session_ctx_t *ctx);
static void session_set_input_text(session_ctx_t *ctx, const char *text);
static void session_local_echo_char(session_ctx_t *ctx, char ch);
static void session_local_backspace(session_ctx_t *ctx);
static void session_clear_input(session_ctx_t *ctx);
static bool session_try_command_completion(session_ctx_t *ctx);
static bool session_consume_escape_sequence(session_ctx_t *ctx, char ch);
static void session_cleanup(session_ctx_t *ctx);
static void *session_thread(void *arg);
static void host_telnet_listener_stop(host_t *host);
static void session_refresh_output_encoding(session_ctx_t *ctx);
static bool session_detect_retro_client(session_ctx_t *ctx);
static void session_telnet_request_terminal_type(session_ctx_t *ctx);
static void session_telnet_capture_startup_metadata(session_ctx_t *ctx);
static void session_history_record(session_ctx_t *ctx, const char *line);
static void session_history_navigate(session_ctx_t *ctx, int direction);
static void session_scrollback_navigate(session_ctx_t *ctx, int direction);
static bool session_try_localized_command_forward(session_ctx_t *ctx, const char *line);
static void chat_history_entry_prepare_user(chat_history_entry_t *entry, const session_ctx_t *from, const char *message);
static bool host_history_record_user(host_t *host, const session_ctx_t *from, const char *message, chat_history_entry_t *stored_entry);
static bool host_history_commit_entry(host_t *host, chat_history_entry_t *entry, chat_history_entry_t *stored_entry);
static void host_notify_external_clients(host_t *host, const chat_history_entry_t *entry);
static bool host_history_append_locked(host_t *host, const chat_history_entry_t *entry);
static bool host_history_reserve_locked(host_t *host, size_t min_capacity);
static size_t host_history_total(host_t *host);
static size_t host_history_copy_range(host_t *host, size_t start_index, chat_history_entry_t *buffer, size_t capacity);
static bool host_history_find_entry_by_id(host_t *host, uint64_t message_id, chat_history_entry_t *entry);
static size_t host_history_delete_range(host_t *host, uint64_t start_id, uint64_t end_id, uint64_t *first_removed,
                                        uint64_t *last_removed, size_t *replies_removed);
static void chat_room_broadcast_entry(chat_room_t *room, const chat_history_entry_t *entry, const session_ctx_t *from);
static void chat_room_broadcast(chat_room_t *room, const char *message, const session_ctx_t *from);
static void chat_room_broadcast_caption(chat_room_t *room, const char *message);
static bool host_history_apply_reaction(host_t *host, uint64_t message_id, size_t reaction_index, chat_history_entry_t *updated_entry);
static bool chat_history_entry_build_reaction_summary(const chat_history_entry_t *entry, char *buffer, size_t length);
static void host_ban_resolve_path(host_t *host);
static void host_ban_state_save_locked(host_t *host);
static void host_ban_state_load(host_t *host);
static void host_reply_state_resolve_path(host_t *host);
static void host_reply_state_save_locked(host_t *host);
static void host_reply_state_load(host_t *host);
static bool host_replies_find_entry_by_id(host_t *host, uint64_t reply_id, chat_reply_entry_t *entry);
static bool host_replies_commit_entry(host_t *host, chat_reply_entry_t *entry, chat_reply_entry_t *stored_entry);
static void session_send_reply_tree(session_ctx_t *ctx, uint64_t parent_message_id, uint64_t parent_reply_id, size_t depth);
static void host_broadcast_reply(host_t *host, const chat_reply_entry_t *entry);
static void session_send_private_message_line(session_ctx_t *ctx, const session_ctx_t *color_source,
                                              const char *label, const char *message);
static session_ctx_t *chat_room_find_user(chat_room_t *room, const char *username);
static bool host_is_ip_banned(host_t *host, const char *ip);
static bool host_is_username_banned(host_t *host, const char *username);
static bool host_add_ban_entry(host_t *host, const char *username, const char *ip);
static bool host_remove_ban_entry(host_t *host, const char *token);
static join_activity_entry_t *host_find_join_activity_locked(host_t *host, const char *ip);
static join_activity_entry_t *host_ensure_join_activity_locked(host_t *host, const char *ip);
static bool host_register_suspicious_activity(host_t *host, const char *username, const char *ip,
                                             size_t *attempts_out);
static bool session_is_private_ipv4(const unsigned char octets[4]);
static bool session_is_lan_client(const char *ip);
static void session_assign_lan_privileges(session_ctx_t *ctx);
static void session_apply_granted_privileges(session_ctx_t *ctx);
static void session_apply_theme_defaults(session_ctx_t *ctx);
static void session_apply_system_theme_defaults(session_ctx_t *ctx);
static void session_force_dark_mode_foreground(session_ctx_t *ctx);
static void session_apply_saved_preferences(session_ctx_t *ctx);
static void session_dispatch_command(session_ctx_t *ctx, const char *line);
static void session_handle_exit(session_ctx_t *ctx);
static void session_force_disconnect(session_ctx_t *ctx, const char *reason);
static void session_handle_nick(session_ctx_t *ctx, const char *arguments);
static bool session_detect_provider_ip(const char *ip, char *label, size_t length);
static bool host_lookup_member_ip(host_t *host, const char *username, char *ip, size_t length);
static bool host_lookup_last_ip(host_t *host, const char *username, char *ip, size_t length);
static bool session_should_hide_entry(session_ctx_t *ctx, const chat_history_entry_t *entry);
static bool session_blocklist_add(session_ctx_t *ctx, const char *ip, const char *username, bool ip_wide,
                                  bool *already_present);
static bool session_blocklist_remove(session_ctx_t *ctx, const char *token);
static void session_blocklist_show(session_ctx_t *ctx);
static void session_handle_reply(session_ctx_t *ctx, const char *arguments);
static void session_handle_block(session_ctx_t *ctx, const char *arguments);
static void session_handle_unblock(session_ctx_t *ctx, const char *arguments);
static void session_handle_pm(session_ctx_t *ctx, const char *arguments);
static void session_handle_motd(session_ctx_t *ctx);
static void session_handle_system_color(session_ctx_t *ctx, const char *arguments);
static void session_handle_palette(session_ctx_t *ctx, const char *arguments);
static void session_handle_translate(session_ctx_t *ctx, const char *arguments);
static void session_handle_translate_scope(session_ctx_t *ctx, const char *arguments);
static void session_handle_gemini(session_ctx_t *ctx, const char *arguments);
static void session_handle_captcha(session_ctx_t *ctx, const char *arguments);
static void session_handle_set_trans_lang(session_ctx_t *ctx, const char *arguments);
static void session_handle_set_target_lang(session_ctx_t *ctx, const char *arguments);
static void session_handle_chat_spacing(session_ctx_t *ctx, const char *arguments);
static void session_handle_mode(session_ctx_t *ctx, const char *arguments);
static void session_handle_history(session_ctx_t *ctx, const char *arguments);
static void session_handle_eliza(session_ctx_t *ctx, const char *arguments);
static void session_handle_eliza_chat(session_ctx_t *ctx, const char *arguments);
static void session_handle_status(session_ctx_t *ctx, const char *arguments);
static void session_handle_showstatus(session_ctx_t *ctx, const char *arguments);
static void session_handle_weather(session_ctx_t *ctx, const char *arguments);
static void session_handle_pardon(session_ctx_t *ctx, const char *arguments);
static void session_handle_ban_name(session_ctx_t *ctx, const char *arguments);
static void session_handle_ban_list(session_ctx_t *ctx, const char *arguments);
static void session_handle_kick(session_ctx_t *ctx, const char *arguments);
static void session_handle_usercount(session_ctx_t *ctx);
static bool host_username_reserved(host_t *host, const char *username);
static void session_handle_search(session_ctx_t *ctx, const char *arguments);
static void session_handle_chat_lookup(session_ctx_t *ctx, const char *arguments);
static void session_handle_image(session_ctx_t *ctx, const char *arguments);
static void session_handle_video(session_ctx_t *ctx, const char *arguments);
static void session_handle_audio(session_ctx_t *ctx, const char *arguments);
static void session_handle_files(session_ctx_t *ctx, const char *arguments);
static void session_handle_reaction(session_ctx_t *ctx, size_t reaction_index, const char *arguments);
static void session_handle_mail(session_ctx_t *ctx, const char *arguments);
static void session_handle_profile_picture(session_ctx_t *ctx, const char *arguments);
static void session_handle_today(session_ctx_t *ctx);
static void session_handle_date(session_ctx_t *ctx, const char *arguments);
static void session_handle_os(session_ctx_t *ctx, const char *arguments);
static void session_handle_getos(session_ctx_t *ctx, const char *arguments);
static void session_handle_getaddr(session_ctx_t *ctx, const char *arguments);
static void session_handle_pair(session_ctx_t *ctx);
static void session_handle_connected(session_ctx_t *ctx);
static bool session_parse_birthday(const char *input, char *normalized, size_t length);
static void session_handle_birthday(session_ctx_t *ctx, const char *arguments);
static void session_handle_soulmate(session_ctx_t *ctx);
static void session_handle_grant(session_ctx_t *ctx, const char *arguments);
static void session_handle_revoke(session_ctx_t *ctx, const char *arguments);
static void session_handle_delete_message(session_ctx_t *ctx, const char *arguments);
static void session_normalize_newlines(char *text);
static bool timezone_sanitize_identifier(const char *input, char *output, size_t length);
static bool timezone_resolve_identifier(const char *input, char *resolved, size_t length);
static const palette_descriptor_t *palette_find_descriptor(const char *name);
static bool palette_apply_to_session(session_ctx_t *ctx, const palette_descriptor_t *descriptor);
static void session_translation_flush_ready(session_ctx_t *ctx);
static bool session_translation_queue_caption(session_ctx_t *ctx, const char *message, size_t placeholder_lines);
static void session_translation_reserve_placeholders(session_ctx_t *ctx, size_t placeholder_lines);
static void session_translation_clear_queue(session_ctx_t *ctx);
static bool session_translation_worker_ensure(session_ctx_t *ctx);
static void session_translation_worker_shutdown(session_ctx_t *ctx);
static void *session_translation_worker(void *arg);
static void session_translation_queue_block(session_ctx_t *ctx, const char *text);
static bool session_translation_queue_private_message(session_ctx_t *ctx, session_ctx_t *target, const char *message);
static void session_translation_normalize_output(char *text);
static void host_handle_translation_quota_exhausted(host_t *host);
static void session_handle_translation_quota_exhausted(session_ctx_t *ctx, const char *error_detail);
static bool session_argument_is_disable(const char *token);
static void session_language_normalize(const char *input, char *normalized, size_t length);
static bool session_language_equals(const char *lhs, const char *rhs);
static session_ui_language_t session_ui_language_from_code(const char *code);
static const char *session_ui_language_code(session_ui_language_t language);
static const char *session_ui_language_name(session_ui_language_t language, session_ui_language_t locale);
static const session_ui_locale_t *session_ui_get_locale(const session_ctx_t *ctx);
static const char *session_command_prefix(const session_ctx_t *ctx);
static int session_utf8_display_width(const char *text);
static void session_format_help_line(session_ctx_t *ctx, const session_help_entry_t *entry, const char *description,
                                     char *buffer, size_t length);
static void session_help_send_entries(session_ctx_t *ctx, const session_help_entry_t *entries, size_t count);
static bool session_fetch_weather_summary(const char *region, const char *city, char *summary, size_t summary_len);
static void session_handle_poll(session_ctx_t *ctx, const char *arguments);
static void session_handle_vote(session_ctx_t *ctx, size_t option_index);
static void session_handle_named_vote(session_ctx_t *ctx, size_t option_index, const char *label);
static void session_handle_elect_command(session_ctx_t *ctx, const char *arguments);
static void session_handle_vote_command(session_ctx_t *ctx, const char *arguments, bool allow_multiple);
static void session_handle_alpha_centauri_landers(session_ctx_t *ctx);
static void session_print_help(session_ctx_t *ctx);
static void session_print_help_extra(session_ctx_t *ctx);
static void session_handle_set_ui_lang(session_ctx_t *ctx, const char *arguments);
static bool session_line_is_exit_command(const char *line);
static void session_handle_username_conflict_input(session_ctx_t *ctx, const char *line);
static const char *session_consume_token(const char *input, char *token, size_t length);
static bool session_user_data_available(session_ctx_t *ctx);
static bool session_user_data_load(session_ctx_t *ctx);
static bool session_user_data_commit(session_ctx_t *ctx);
static void session_user_data_touch(session_ctx_t *ctx);
static bool host_user_data_send_mail(host_t *host, const char *recipient, const char *recipient_ip,
                                    const char *sender, const char *message, char *error, size_t error_length);
static bool host_user_data_load_existing(host_t *host, const char *username, const char *ip,
                                        user_data_record_t *record, bool create_if_missing);
static void host_user_data_bootstrap(host_t *host);
static bool session_parse_color_arguments(char *working, char **tokens, size_t max_tokens, size_t *token_count);
static size_t session_utf8_prev_char_len(const char *buffer, size_t length);
static int session_utf8_char_width(const char *bytes, size_t length);
static void host_history_record_system(host_t *host, const char *message);
static void session_send_history(session_ctx_t *ctx);
static void session_send_history_entry(session_ctx_t *ctx, const chat_history_entry_t *entry);
static void session_deliver_outgoing_message(session_ctx_t *ctx, const char *message,
                                             bool clear_prompt_text);
static void chat_room_broadcast_reaction_update(host_t *host, const chat_history_entry_t *entry);
static user_preference_t *host_find_preference_locked(host_t *host, const char *username);
static user_preference_t *host_ensure_preference_locked(host_t *host, const char *username);
static void host_store_user_theme(host_t *host, const session_ctx_t *ctx);
static size_t host_prepare_join_delay(host_t *host, struct timespec *wait_duration);
static host_join_attempt_result_t host_register_join_attempt(host_t *host, const char *username, const char *ip);
static bool session_run_captcha(session_ctx_t *ctx);
static bool session_is_captcha_exempt(const session_ctx_t *ctx);
static void host_store_system_theme(host_t *host, const session_ctx_t *ctx);
static void host_store_user_os(host_t *host, const session_ctx_t *ctx);
static void host_store_birthday(host_t *host, const session_ctx_t *ctx, const char *birthday);
static void host_store_chat_spacing(host_t *host, const session_ctx_t *ctx);
static void host_store_translation_preferences(host_t *host, const session_ctx_t *ctx);
static void host_store_ui_language(host_t *host, const session_ctx_t *ctx);
static bool host_ip_has_grant_locked(host_t *host, const char *ip);
static bool host_ip_has_grant(host_t *host, const char *ip);
static bool host_add_operator_grant_locked(host_t *host, const char *ip);
static bool host_remove_operator_grant_locked(host_t *host, const char *ip);
static void host_apply_grant_to_ip(host_t *host, const char *ip);
static void host_refresh_motd_locked(host_t *host);
static void host_refresh_motd(host_t *host);
static void host_build_birthday_notice_locked(host_t *host, char *line, size_t length);
static bool host_is_leap_year(int year);
static void host_revoke_grant_from_ip(host_t *host, const char *ip);
static void host_history_normalize_entry(host_t *host, chat_history_entry_t *entry);
static const char *chat_attachment_type_label(chat_attachment_type_t type);
static void host_state_resolve_path(host_t *host);
static void host_state_load(host_t *host);
static void host_state_save_locked(host_t *host);
static void host_eliza_state_resolve_path(host_t *host);
static void host_eliza_state_load(host_t *host);
static void host_eliza_state_save_locked(host_t *host);
static void host_eliza_memory_resolve_path(host_t *host);
static void host_eliza_memory_load(host_t *host);
static void host_eliza_memory_save_locked(host_t *host);
static void host_eliza_memory_store(host_t *host, const char *prompt, const char *reply);
static size_t host_eliza_memory_collect_context(host_t *host, const char *prompt, char *context,
                                                size_t context_length);
static void host_eliza_history_normalize_line(char *text);
static size_t host_eliza_history_collect_context(host_t *host, char *context, size_t context_length);
static void host_eliza_prepare_preview(const char *source, char *dest, size_t dest_length);
static size_t host_eliza_bbs_collect_context(host_t *host, char *context, size_t context_length);
static size_t host_eliza_memory_collect_tokens(const char *prompt, char tokens[][32], size_t max_tokens);
static void host_bbs_resolve_path(host_t *host);
static void host_bbs_state_load(host_t *host);
static void host_bbs_state_save_locked(host_t *host);
static void host_bbs_start_watchdog(host_t *host);
static void *host_bbs_watchdog_thread(void *arg);
static void host_bbs_watchdog_scan(host_t *host);
static void host_security_configure(host_t *host);
static bool host_ensure_private_data_path(host_t *host, const char *path, bool create_directories);
static void host_security_compact_whitespace(char *text);
static bool host_security_execute_clamav_backend(host_t *host, char *notice, size_t notice_length);
static void *host_security_clamav_backend(void *arg);
static void host_security_start_clamav_backend(host_t *host);
static void host_security_disable_filter(host_t *host, const char *reason);
static void host_security_disable_clamav(host_t *host, const char *reason);
static host_security_scan_result_t host_security_scan_payload(host_t *host, const char *category, const char *payload,
                                                              size_t length, char *diagnostic, size_t diagnostic_length);
static void host_security_process_blocked(host_t *host, const char *category, const char *diagnostic,
                                         const char *username, const char *ip, session_ctx_t *session,
                                         bool post_send, const char *content);
static void host_security_process_error(host_t *host, const char *category, const char *diagnostic,
                                         const char *username, const char *ip, session_ctx_t *session,
                                         bool post_send);
static bool host_moderation_init(host_t *host);
static void host_moderation_shutdown(host_t *host);
static void host_moderation_backoff(unsigned int attempts);
static bool host_moderation_spawn_worker(host_t *host);
static void host_moderation_close_worker(host_t *host);
static bool host_moderation_recover_worker(host_t *host, const char *diagnostic);
static bool host_moderation_queue_chat(session_ctx_t *ctx, const char *message, size_t length);
static void *host_moderation_thread(void *arg);
static bool host_moderation_write_all(int fd, const void *buffer, size_t length);
static bool host_moderation_read_all(int fd, void *buffer, size_t length);
static void host_moderation_worker_loop(int request_fd, int response_fd);
static void host_moderation_handle_failure(host_t *host, host_moderation_task_t *task, const char *diagnostic);
static void host_moderation_apply_result(host_t *host, host_moderation_task_t *task,
                                         const host_moderation_ipc_response_t *response, const char *message);
static void host_moderation_flush_pending(host_t *host, const char *diagnostic);
static double host_elapsed_seconds(const struct timespec *start, const struct timespec *end);
static bool host_eliza_enable(host_t *host);
static bool host_eliza_disable(host_t *host);
static void host_eliza_announce_join(host_t *host);
static void host_eliza_announce_depart(host_t *host);
static void host_eliza_say(host_t *host, const char *message);
static void host_eliza_handle_private_message(session_ctx_t *ctx, const char *message);
static void host_eliza_prepare_private_reply(const char *message, char *reply, size_t reply_length);
static bool host_eliza_content_is_severe(const char *text);
static bool host_eliza_worker_init(host_t *host);
static void host_eliza_worker_shutdown(host_t *host);
static bool host_eliza_worker_enqueue(host_t *host, host_eliza_intervene_task_t *task);
static void *host_eliza_worker_thread(void *arg);
static bool host_eliza_intervene(session_ctx_t *ctx, const char *content, const char *reason, bool from_filter);
static void host_eliza_intervene_execute(session_ctx_t *ctx, const char *reason, bool from_filter);
static host_security_scan_result_t session_security_check_text(session_ctx_t *ctx, const char *category,
                                                               const char *content, size_t length, bool post_send);
static void host_vote_resolve_path(host_t *host);
static void host_vote_state_load(host_t *host);
static void host_vote_state_save_locked(host_t *host);
static bool host_try_load_motd_from_path(host_t *host, const char *path);
static bool username_contains(const char *username, const char *needle);
static void host_apply_palette_descriptor(host_t *host, const palette_descriptor_t *descriptor);
static bool host_lookup_user_os(host_t *host, const char *username, char *buffer, size_t length);
static void session_send_poll_summary(session_ctx_t *ctx);
static void session_send_poll_summary_generic(session_ctx_t *ctx, const poll_state_t *poll, const char *label);
static void session_list_named_polls(session_ctx_t *ctx);
static void session_handle_bbs(session_ctx_t *ctx, const char *arguments);
static void poll_state_reset(poll_state_t *poll);
static void named_poll_reset(named_poll_state_t *poll);
static named_poll_state_t *host_find_named_poll_locked(host_t *host, const char *label);
static named_poll_state_t *host_ensure_named_poll_locked(host_t *host, const char *label);
static void host_recount_named_polls_locked(host_t *host);
static bool poll_label_is_valid(const char *label);
static void session_bbs_show_dashboard(session_ctx_t *ctx);
static void session_bbs_list(session_ctx_t *ctx);
static void session_bbs_list_topic(session_ctx_t *ctx, const char *topic);
static void session_bbs_read(session_ctx_t *ctx, uint64_t id);
static void session_bbs_begin_post(session_ctx_t *ctx, const char *arguments);
static void session_bbs_begin_edit(session_ctx_t *ctx, uint64_t id);
static void session_bbs_capture_body_text(session_ctx_t *ctx, const char *text);
static void session_bbs_capture_body_line(session_ctx_t *ctx, const char *line);
static bool session_bbs_capture_continue(const session_ctx_t *ctx);
static void session_bbs_add_comment(session_ctx_t *ctx, const char *arguments);
static void session_bbs_regen_post(session_ctx_t *ctx, uint64_t id);
static void session_bbs_delete(session_ctx_t *ctx, uint64_t id);
static void session_bbs_reset_pending_post(session_ctx_t *ctx);
static bbs_post_t *host_find_bbs_post_locked(host_t *host, uint64_t id);
static bbs_post_t *host_allocate_bbs_post_locked(host_t *host);
static void host_clear_bbs_post_locked(host_t *host, bbs_post_t *post);
static void session_bbs_queue_translation(session_ctx_t *ctx, const bbs_post_t *post);
static void session_bbs_render_post(session_ctx_t *ctx, const bbs_post_t *post, const char *notice,
                                    bool reset_scroll, bool scroll_to_bottom);
static bool host_user_data_load_existing(host_t *host, const char *username, const char *ip,
                                        user_data_record_t *record, bool create_if_missing);
static void host_user_data_build_match_key(const char *username, char *key, size_t length);
static bool host_user_data_find_profile_picture(host_t *host, const char *alias, user_data_record_t *record);
static bool session_bbs_scroll(session_ctx_t *ctx, int direction, size_t step);
static bool session_bbs_refresh_view(session_ctx_t *ctx);
static void session_handle_rss(session_ctx_t *ctx, const char *arguments);
static void session_rss_list(session_ctx_t *ctx);
static void session_rss_read(session_ctx_t *ctx, const char *tag);
static void session_rss_begin(session_ctx_t *ctx, const char *tag, const rss_session_item_t *items, size_t count);
static void session_rss_show_current(session_ctx_t *ctx);
static bool session_rss_move(session_ctx_t *ctx, int delta);
static void session_rss_exit(session_ctx_t *ctx, const char *reason);
static void session_rss_clear(session_ctx_t *ctx);
static bool session_parse_command(const char *line, const char *command, const char **arguments);
static bool session_parse_localized_command(session_ctx_t *ctx, const session_command_alias_t *alias, const char *line,
                                            const char **arguments);
static void rss_strip_html(char *text);
static void rss_decode_entities(char *text);
static void rss_trim_whitespace(char *text);
static bool rss_tag_is_valid(const char *tag);
static rss_feed_t *host_find_rss_feed_locked(host_t *host, const char *tag);
static void host_clear_rss_feed(rss_feed_t *feed);
static void host_rss_recount_locked(host_t *host);
static bool host_rss_add_feed(host_t *host, const char *url, const char *tag, char *error, size_t error_length);
static bool host_rss_remove_feed(host_t *host, const char *tag, char *error, size_t error_length);
static void host_rss_resolve_path(host_t *host);
static void host_rss_state_load(host_t *host);
static void host_rss_state_save_locked(host_t *host);
static size_t host_rss_write_callback(void *contents, size_t size, size_t nmemb, void *userp);
static bool host_rss_download(const char *url, char **payload, size_t *length);
static bool host_rss_extract_tag(const char *block, const char *tag, char *out, size_t out_len);
static bool host_rss_extract_atom_link(const char *block, char *out, size_t out_len);
static size_t host_rss_parse_items(const char *payload, rss_session_item_t *items, size_t max_items);
static bool host_rss_fetch_items(const rss_feed_t *feed, rss_session_item_t *items, size_t max_items, size_t *out_count);
static void host_rss_start_backend(host_t *host);
static void *host_rss_backend(void *arg);
static bool host_rss_should_broadcast_breaking(const rss_session_item_t *item);
static bool host_asciiart_cooldown_active(host_t *host, const char *ip, const struct timespec *now,
                                          long *remaining_seconds);
static void host_asciiart_register_post(host_t *host, const char *ip, const struct timespec *when);
static bool session_asciiart_cooldown_active(session_ctx_t *ctx, struct timespec *now, long *remaining_seconds);
static void session_asciiart_reset(session_ctx_t *ctx);
static void session_asciiart_begin(session_ctx_t *ctx, session_asciiart_target_t target);
static void session_asciiart_import_from_editor(session_ctx_t *ctx);
static void session_asciiart_capture_text(session_ctx_t *ctx, const char *text);
static void session_asciiart_capture_line(session_ctx_t *ctx, const char *line);
static void session_asciiart_commit(session_ctx_t *ctx);
static void session_asciiart_cancel(session_ctx_t *ctx, const char *reason);
typedef void (*session_text_line_consumer_t)(session_ctx_t *, const char *);
typedef bool (*session_text_continue_predicate_t)(const session_ctx_t *);
static void session_capture_multiline_text(session_ctx_t *ctx, const char *text, session_text_line_consumer_t consumer,
                                           session_text_continue_predicate_t should_continue);
static bool session_asciiart_capture_continue(const session_ctx_t *ctx);
static void session_handle_game(session_ctx_t *ctx, const char *arguments);
static void session_game_suspend(session_ctx_t *ctx, const char *reason);
static int session_channel_read_poll(session_ctx_t *ctx, char *buffer, size_t length, int timeout_ms);
static void session_game_seed_rng(session_ctx_t *ctx);
static uint32_t session_game_random(session_ctx_t *ctx);
static int session_game_random_range(session_ctx_t *ctx, int max);
static void session_game_start_tetris(session_ctx_t *ctx);
static void session_game_tetris_reset(tetris_game_state_t *state);
static void session_game_tetris_apply_round_settings(tetris_game_state_t *state);
static void session_game_tetris_handle_round_progress(session_ctx_t *ctx);
static void session_game_tetris_fill_bag(session_ctx_t *ctx);
static int session_game_tetris_take_piece(session_ctx_t *ctx);
static bool session_game_tetris_spawn_piece(session_ctx_t *ctx);
static bool session_game_tetris_cell_occupied(int piece, int rotation, int row, int column);
static bool session_game_tetris_position_valid(const tetris_game_state_t *state, int piece, int rotation, int row,
                                               int column);
static bool session_game_tetris_move(session_ctx_t *ctx, int drow, int dcol);
static bool session_game_tetris_soft_drop(session_ctx_t *ctx);
static bool session_game_tetris_rotate(session_ctx_t *ctx);
static bool session_game_tetris_apply_gravity(session_ctx_t *ctx, unsigned ticks);
static bool session_game_tetris_update_timer(session_ctx_t *ctx, bool accelerate);
static bool session_game_tetris_process_timeout(session_ctx_t *ctx);
static bool session_game_tetris_process_action(session_ctx_t *ctx, int action);
static bool session_game_tetris_process_raw_input(session_ctx_t *ctx, char ch);
static void session_game_tetris_lock_piece(session_ctx_t *ctx);
static void session_game_tetris_clear_lines(session_ctx_t *ctx, unsigned *cleared);
static void session_game_tetris_render(session_ctx_t *ctx);
static void session_game_tetris_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_start_liargame(session_ctx_t *ctx);
static void session_game_liar_present_round(session_ctx_t *ctx);
static void session_game_liar_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_start_alpha(session_ctx_t *ctx);
static void session_game_alpha_reset(session_ctx_t *ctx);
static void session_game_alpha_prepare_navigation(session_ctx_t *ctx);
static void session_game_alpha_reroll_navigation(session_ctx_t *ctx);
static void session_game_alpha_add_gravity_source(alpha_centauri_game_state_t *state, int x, int y, double mu,
                                                  int influence_radius, char symbol, const char *name);
static void session_game_alpha_configure_gravity(session_ctx_t *ctx);
static void session_game_alpha_apply_gravity(alpha_centauri_game_state_t *state);
static const char *const kAlphaStarCatalog[] = {
    "Midway Star",
    "Binary Torch",
    "Turnover Sun",
    "Arrival Flare",
    "Relay Star",
    "Shepherd Star",
};

static const char *const kAlphaPlanetCatalog[] = {
    "Departure World",
    "Drift Planet",
    "Relay Outpost",
    "Approach World",
    "Proxima b",
    "Immigrants' Harbor",
};

static const char *const kAlphaDebrisCatalog[] = {
    "Comet Trail",
    "Asteroid Swarm",
    "Ice Shard",
    "Dust Ribbon",
    "Sail Wreck",
};

#define ALPHA_STAR_CATALOG_COUNT (sizeof(kAlphaStarCatalog) / sizeof(kAlphaStarCatalog[0]))
#define ALPHA_PLANET_CATALOG_COUNT (sizeof(kAlphaPlanetCatalog) / sizeof(kAlphaPlanetCatalog[0]))
#define ALPHA_DEBRIS_CATALOG_COUNT (sizeof(kAlphaDebrisCatalog) / sizeof(kAlphaDebrisCatalog[0]))

static bool session_game_alpha_position_occupied(const alpha_centauri_game_state_t *state, int x, int y) {
  if (state == NULL) {
    return true;
  }
  if (state->nav_x == x && state->nav_y == y) {
    return true;
  }
  if (state->nav_target_x == x && state->nav_target_y == y) {
    return true;
  }
  for (unsigned idx = 0U; idx < state->gravity_source_count; ++idx) {
    const alpha_gravity_source_t *existing = &state->gravity_sources[idx];
    if (existing->x == x && existing->y == y) {
      return true;
    }
  }
  if (state->stage == 4U) {
    if (!state->eva_ready) {
      for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
        const alpha_waypoint_t *waypoint = &state->waypoints[idx];
        if (waypoint->x == x && waypoint->y == y) {
          return true;
        }
      }
    }
    if (state->final_waypoint.symbol != '\0' && state->final_waypoint.x == x && state->final_waypoint.y == y) {
      return true;
    }
  }
  return false;
}

static void session_game_alpha_place_random_source(session_ctx_t *ctx, alpha_centauri_game_state_t *state, int margin,
                                                   double mu, int radius, char symbol, const char *name) {
  if (ctx == NULL || state == NULL) {
    return;
  }

  int attempts = 0;
  int min_margin = margin >= 0 ? margin : 0;
  int usable_width = ALPHA_NAV_WIDTH - (min_margin * 2);
  int usable_height = ALPHA_NAV_HEIGHT - (min_margin * 2);
  if (usable_width <= 0) {
    usable_width = ALPHA_NAV_WIDTH;
    min_margin = 0;
  }
  if (usable_height <= 0) {
    usable_height = ALPHA_NAV_HEIGHT;
    min_margin = 0;
  }

  while (attempts < 128) {
    int x = min_margin + session_game_random_range(ctx, usable_width);
    int y = min_margin + session_game_random_range(ctx, usable_height);
    if (!session_game_alpha_position_occupied(state, x, y)) {
      session_game_alpha_add_gravity_source(state, x, y, mu, radius, symbol, name);
      return;
    }
    ++attempts;
  }

  int fallback_x = min_margin < ALPHA_NAV_WIDTH ? min_margin : 0;
  int fallback_y = min_margin < ALPHA_NAV_HEIGHT ? min_margin : 0;
  session_game_alpha_add_gravity_source(state, fallback_x, fallback_y, mu, radius, symbol, name);
}

static double session_game_alpha_random_double(session_ctx_t *ctx, double min_value, double max_value) {
  if (ctx == NULL) {
    return min_value;
  }
  if (max_value <= min_value) {
    return min_value;
  }
  double fraction = (double)session_game_random(ctx) / (double)UINT32_MAX;
  if (fraction < 0.0) {
    fraction = 0.0;
  } else if (fraction > 1.0) {
    fraction = 1.0;
  }
  return min_value + (max_value - min_value) * fraction;
}

static int session_game_alpha_random_with_margin(session_ctx_t *ctx, int extent, int margin) {
  if (extent <= 0) {
    return 0;
  }
  int safe_margin = margin;
  if (safe_margin < 0) {
    safe_margin = 0;
  }
  int usable = extent - (safe_margin * 2);
  if (usable <= 0) {
    usable = extent;
    safe_margin = 0;
  }
  return safe_margin + session_game_random_range(ctx, usable);
}
static void session_game_alpha_sync_from_save(session_ctx_t *ctx);
static void session_game_alpha_sync_to_save(session_ctx_t *ctx);
static void session_game_alpha_present_stage(session_ctx_t *ctx);
static void session_game_alpha_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_alpha_log_completion(session_ctx_t *ctx);
static void session_game_alpha_render_navigation(session_ctx_t *ctx);
static void session_game_alpha_refresh_navigation(session_ctx_t *ctx);
static void session_game_alpha_plan_waypoints(session_ctx_t *ctx);
static void session_game_alpha_present_waypoints(session_ctx_t *ctx);
static void session_game_alpha_complete_waypoint(session_ctx_t *ctx);
static bool session_game_alpha_handle_arrow(session_ctx_t *ctx, int dx, int dy);
static bool session_game_alpha_attempt_completion(session_ctx_t *ctx);
static void session_game_alpha_execute_ignite(session_ctx_t *ctx);
static void session_game_alpha_execute_trim(session_ctx_t *ctx);
static void session_game_alpha_execute_flip(session_ctx_t *ctx);
static void session_game_alpha_execute_retro(session_ctx_t *ctx);
static void session_game_alpha_execute_eva(session_ctx_t *ctx);
static void session_game_alpha_manual_lock(session_ctx_t *ctx);
static void session_game_alpha_manual_save(session_ctx_t *ctx);
static void host_update_last_captcha_prompt(host_t *host, const captcha_prompt_t *prompt,
                                            const captcha_language_t *order, size_t count);

typedef struct liar_prompt {
  const char *statements[3];
  unsigned liar_index;
} liar_prompt_t;

static const liar_prompt_t LIAR_PROMPTS[] = {
    {{"I have contributed code to an open source project.", "I once replaced an entire server rack solo.",
      "I prefer mechanical keyboards with clicky switches."}, 1U},
    {{"I have memorized pi to 200 digits.", "I used to write BASIC games in middle school.",
      "I cannot solve a Rubik's Cube."}, 0U},
    {{"I drink my coffee without sugar.", "I debug using `printf` more than any other tool.",
      "I have never broken a build."}, 2U},
    {{"I run Linux on my primary laptop.", "I have camped overnight for a console launch.",
      "I have attended a demoparty."}, 1U},
    {{"I know how to solder surface-mount components.", "I have written an emulator in C.",
      "I have a pet snake named Segfault."}, 2U},
    {{"I play at least one rhythm game competitively.", "I once deployed to production from my phone.",
      "I have built a keyboard from scratch."}, 1U},
};

static const char *const TETROMINO_SHAPES[7][4] = {
    {
        "...."
        "####"
        "...."
        "....",
        "..#."
        "..#."
        "..#."
        "..#.",
        "...."
        "####"
        "...."
        "....",
        "..#."
        "..#."
        "..#."
        "..#.",
    },
    {
        "#..."
        "###."
        "...."
        "....",
        ".##."
        ".#.."
        ".#.."
        "....",
        "...."
        "###."
        "..#."
        "....",
        ".#.."
        ".#.."
        "##.."
        "....",
    },
    {
        "..#."
        "###."
        "...."
        "....",
        ".#.."
        ".#.."
        ".##."
        "....",
        "...."
        "###."
        "#..."
        "....",
        "##.."
        ".#.."
        ".#.."
        "....",
    },
    {
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
    },
    {
        ".##."
        "##.."
        "...."
        "....",
        ".#.."
        ".##."
        "..#."
        "....",
        ".##."
        "##.."
        "...."
        "....",
        ".#.."
        ".##."
        "..#."
        "....",
    },
    {
        ".#.."
        "###."
        "...."
        "....",
        ".#.."
        ".##."
        ".#.."
        "....",
        "...."
        "###."
        ".#.."
        "....",
        ".#.."
        "##.."
        ".#.."
        "....",
    },
    {
        "##.."
        ".##."
        "...."
        "....",
        "..#."
        ".##."
        ".#.."
        "....",
        "##.."
        ".##."
        "...."
        "....",
        "..#."
        ".##."
        ".#.."
        "....",
    },
};

static const char TETROMINO_DISPLAY_CHARS[7] = {'I', 'J', 'L', 'O', 'S', 'T', 'Z'};

static const uint32_t HOST_STATE_MAGIC = 0x53484354U; /* 'SHCT' */
static const uint32_t HOST_STATE_VERSION = 9U;
static const uint32_t ELIZA_STATE_MAGIC = 0x454c5354U; /* 'ELST' */
static const uint32_t ELIZA_STATE_VERSION = 1U;

#define HOST_STATE_SOUND_ALIAS_LEN 32U

typedef struct eliza_memory_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint32_t reserved;
  uint64_t next_id;
} eliza_memory_header_t;

typedef struct eliza_memory_entry_serialized {
  uint64_t id;
  int64_t stored_at;
  char prompt[SSH_CHATTER_MESSAGE_LIMIT];
  char reply[SSH_CHATTER_MESSAGE_LIMIT];
} eliza_memory_entry_serialized_t;

typedef struct eliza_state_record {
  uint32_t magic;
  uint32_t version;
  uint8_t enabled;
  uint8_t reserved[7];
} eliza_state_record_t;

typedef struct host_state_header_v1 {
  uint32_t magic;
  uint32_t version;
  uint32_t history_count;
  uint32_t preference_count;
} host_state_header_v1_t;

typedef struct host_state_header {
  host_state_header_v1_t base;
  uint32_t legacy_sound_count;
  uint32_t grant_count;
  uint64_t next_message_id;
  uint8_t captcha_enabled;
  uint8_t reserved[7];
} host_state_header_t;

typedef struct host_state_history_entry_v1 {
  uint8_t is_user_message;
  uint8_t user_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char message[SSH_CHATTER_MESSAGE_LIMIT];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
} host_state_history_entry_v1_t;

typedef struct host_state_history_entry_v2 {
  host_state_history_entry_v1_t base;
  uint64_t message_id;
  uint8_t attachment_type;
  char attachment_target[SSH_CHATTER_ATTACHMENT_TARGET_LEN];
  char attachment_caption[SSH_CHATTER_ATTACHMENT_CAPTION_LEN];
  char sound_alias[HOST_STATE_SOUND_ALIAS_LEN];
  uint32_t reaction_counts[SSH_CHATTER_REACTION_KIND_COUNT];
} host_state_history_entry_v2_t;

typedef struct host_state_history_entry_v3 {
  host_state_history_entry_v1_t base;
  uint64_t message_id;
  uint8_t attachment_type;
  uint8_t reserved[7];
  char attachment_target[SSH_CHATTER_ATTACHMENT_TARGET_LEN];
  char attachment_caption[SSH_CHATTER_ATTACHMENT_CAPTION_LEN];
  uint32_t reaction_counts[SSH_CHATTER_REACTION_KIND_COUNT];
} host_state_history_entry_v3_t;

typedef struct host_state_preference_entry_v3 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
} host_state_preference_entry_v3_t;

typedef struct host_state_preference_entry_v4 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
} host_state_preference_entry_v4_t;

typedef struct host_state_preference_entry_v5 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t reserved[3];
  char birthday[16];
} host_state_preference_entry_v5_t;

typedef struct host_state_preference_entry_v6 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t reserved[3];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_v6_t;

typedef struct host_state_preference_entry_v7 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t translation_master_explicit;
  uint8_t reserved[2];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_v7_t;

typedef struct host_state_preference_entry {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t translation_master_explicit;
  uint8_t reserved[2];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char ui_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_t;

static const uint32_t BAN_STATE_MAGIC = 0x5348424eU; /* 'SHBN' */
static const uint32_t BAN_STATE_VERSION = 1U;

typedef struct ban_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
} ban_state_header_t;

typedef struct ban_state_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  char ip[SSH_CHATTER_IP_LEN];
} ban_state_entry_t;

static const uint32_t REPLY_STATE_MAGIC = 0x53485250U; /* 'SHRP' */
static const uint32_t REPLY_STATE_VERSION = 1U;

typedef struct reply_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint64_t next_reply_id;
} reply_state_header_t;

typedef struct reply_state_entry {
  uint64_t reply_id;
  uint64_t parent_message_id;
  uint64_t parent_reply_id;
  int64_t created_at;
  char username[SSH_CHATTER_USERNAME_LEN];
  char message[SSH_CHATTER_MESSAGE_LIMIT];
} reply_state_entry_t;

typedef struct host_state_grant_entry {
  char ip[SSH_CHATTER_IP_LEN];
} host_state_grant_entry_t;

static const uint32_t BBS_STATE_MAGIC = 0x42425331U; /* 'BBS1' */
static const uint32_t BBS_STATE_VERSION = 4U;

#define SSH_CHATTER_BBS_TITLE_LEN_V1 96U
#define SSH_CHATTER_BBS_BODY_LEN_V1 2048U
#define SSH_CHATTER_BBS_BODY_LEN_V2 10240U
#define SSH_CHATTER_BBS_BODY_LEN_V3 20480U

typedef struct bbs_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t post_count;
  uint32_t reserved;
  uint64_t next_id;
} bbs_state_header_t;

typedef struct bbs_state_comment_entry {
  char author[SSH_CHATTER_USERNAME_LEN];
  char text[SSH_CHATTER_BBS_COMMENT_LEN];
  int64_t created_at;
} bbs_state_comment_entry_t;

typedef struct bbs_state_post_entry {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_t;

typedef struct bbs_state_post_entry_v1 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN_V1];
  char body[SSH_CHATTER_BBS_BODY_LEN_V1];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v1_t;

typedef struct bbs_state_post_entry_v2 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN_V2];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v2_t;

typedef struct bbs_state_post_entry_v3 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN_V3];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v3_t;

static const uint32_t RSS_STATE_MAGIC = 0x52535331U; /* 'RSS1' */
static const uint32_t RSS_STATE_VERSION = 1U;

typedef struct rss_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t feed_count;
  uint32_t reserved;
} rss_state_header_t;

typedef struct rss_state_entry {
  char tag[SSH_CHATTER_RSS_TAG_LEN];
  char url[SSH_CHATTER_RSS_URL_LEN];
  char last_item_key[SSH_CHATTER_RSS_ITEM_KEY_LEN];
} rss_state_entry_t;

static const uint32_t ALPHA_LANDERS_STATE_MAGIC = 0x464C4147U; /* 'FLAG' */
static const uint32_t ALPHA_LANDERS_STATE_VERSION = 1U;

typedef struct alpha_landers_file_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint32_t reserved;
} alpha_landers_file_header_t;

typedef struct alpha_landers_file_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  uint32_t flag_count;
  uint64_t last_flag_timestamp;
  uint32_t reserved;
} alpha_landers_file_entry_t;

static const uint32_t VOTE_STATE_MAGIC = 0x564F5445U; /* 'VOTE' */
static const uint32_t VOTE_STATE_VERSION = 1U;

typedef struct vote_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t named_count;
  uint32_t reserved;
} vote_state_header_t;

typedef struct vote_state_poll_option_entry {
  char text[SSH_CHATTER_MESSAGE_LIMIT];
  uint32_t votes;
} vote_state_poll_option_entry_t;

typedef struct vote_state_poll_entry {
  uint8_t active;
  uint8_t allow_multiple;
  uint8_t reserved[6];
  uint64_t id;
  uint32_t option_count;
  uint32_t reserved2;
  char question[SSH_CHATTER_MESSAGE_LIMIT];
  vote_state_poll_option_entry_t options[5];
} vote_state_poll_entry_t;

typedef struct vote_state_named_voter_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  int32_t choice;
  uint32_t choices_mask;
} vote_state_named_voter_entry_t;

typedef struct vote_state_named_entry {
  vote_state_poll_entry_t poll;
  char label[SSH_CHATTER_POLL_LABEL_LEN];
  char owner[SSH_CHATTER_USERNAME_LEN];
  uint32_t voter_count;
  uint32_t reserved;
  vote_state_named_voter_entry_t voters[SSH_CHATTER_MAX_NAMED_VOTERS];
} vote_state_named_entry_t;


typedef struct reaction_descriptor {
  const char *command;
  const char *label;
  const char *icon;
} reaction_descriptor_t;

static const reaction_descriptor_t REACTION_DEFINITIONS[SSH_CHATTER_REACTION_KIND_COUNT] = {
    {"good", "good", "b"},   {"sad", "sad", ":("},   {"cool", "cool", "(ツ)!"},
    {"angry", "angry", ":/"}, {"checked", "checked", "[v]"},
    {"love", "love", "<3"},   {"wtf", "wtf", "凸_(ツ)"},
};

typedef struct os_descriptor {
  const char *name;
  const char *display;
} os_descriptor_t;

static const os_descriptor_t OS_CATALOG[] = {
    {"windows", "Windows"},      {"macos", "macOS"},      {"linux", "Linux"},
    {"freebsd", "FreeBSD"},      {"ios", "iOS"},          {"android", "Android"},
    {"watchos", "watchOS"},      {"solaris", "Solaris"},  {"openbsd", "OpenBSD"},
    {"netbsd", "NetBSD"},        {"dragonflybsd", "DragonFlyBSD"},
    {"reactos", "ReactOS"},      {"tizen", "Tizen"}, {"bsd", "BSD"},
    {"msdos", "MS-DOS"}, {"drdos", "DR-DOS"}, {"kdos", "K-DOS"},
    {"templeos", "TempleOS"}, {"zealos", "ZealOS"},
    {"haiku", "Haiku"}, {"pcdos", "PC-DOS"}
};

static const os_descriptor_t *session_lookup_os_descriptor(const char *name);

// random pool for daily functions
static const char *DAILY_FUNCTIONS[] = {"sin",   "cos",   "tan",   "sqrt",  "log",   "exp",     "printf",
                                        "malloc", "free",  "memcpy", "strncpy", "qsort", "fopen",   "close",
                                        "select", "poll",  "fork",  "exec",  "pthread_create", "strtok"};

static bool chat_room_ensure_capacity(chat_room_t *room, size_t required) { // chat members should be within capacity
  if (room == NULL) {
    return false;
  }

  if (required <= room->member_capacity) {
    return true;
  }

  size_t new_capacity = room->member_capacity == 0U ? 8U : room->member_capacity;
  while (new_capacity < required) {
    if (new_capacity > SIZE_MAX / 2U) {
      new_capacity = required;
      break;
    }
    new_capacity *= 2U;
  }

  session_ctx_t **resized = realloc(room->members, new_capacity * sizeof(*resized));
  if (resized == NULL) {
    return false;
  }

  for (size_t idx = room->member_capacity; idx < new_capacity; ++idx) {
    resized[idx] = NULL;
  }

  room->members = resized;
  room->member_capacity = new_capacity;
  return true;
}

static void chat_room_init(chat_room_t *room) {
  if (room == NULL) {
    return;
  }
  pthread_mutex_init(&room->lock, NULL);
  room->members = NULL;
  room->member_count = 0U;
  room->member_capacity = 0U;
}

static void session_describe_peer(ssh_session session, char *buffer, size_t len) {
  if (buffer == NULL || len == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (session == NULL) {
    return;
  }

  const int socket_fd = ssh_get_fd(session);
  if (socket_fd < 0) {
    return;
  }

  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);
  if (getpeername(socket_fd, (struct sockaddr *)&addr, &addr_len) != 0) {
    return;
  }

  char host[NI_MAXHOST];
  if (getnameinfo((struct sockaddr *)&addr, addr_len, host, sizeof(host), NULL, 0,
                  NI_NUMERICHOST) != 0) {
    return;
  }

  snprintf(buffer, len, "%s", host);
}

static void host_format_sockaddr(const struct sockaddr *addr, socklen_t len, char *buffer, size_t size) {
  if (buffer == NULL || size == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (addr == NULL) {
    return;
  }

  socklen_t host_len = (socklen_t)(size > (size_t)UINT_MAX ? UINT_MAX : size);
  if (host_len == 0) {
    return;
  }

  if (getnameinfo(addr, len, buffer, host_len, NULL, 0, NI_NUMERICHOST) != 0) {
    buffer[0] = '\0';
  }
}

typedef enum {
  HOSTKEY_SUPPORT_UNKNOWN = 0,
  HOSTKEY_SUPPORT_ACCEPTED,
  HOSTKEY_SUPPORT_REJECTED, // unlisted auth key should be rejected.
} hostkey_support_status_t;

typedef struct {
  hostkey_support_status_t status;
  char offered_algorithms[256];
} hostkey_probe_result_t;

static bool hostkey_list_contains(const unsigned char *data, size_t data_len, const char *needle,
                                 size_t needle_len) {
  if (data == NULL || needle == NULL || needle_len == 0U) {
    return false;
  }

  size_t position = 0U;
  while (position < data_len) {
    size_t token_end = position;
    while (token_end < data_len && data[token_end] != ',') {
      ++token_end;
    }

    const size_t token_length = token_end - position;
    if (token_length == needle_len && memcmp(data + position, needle, needle_len) == 0) {
      return true;
    }

    if (token_end >= data_len) {
      break;
    }

    position = token_end + 1U;
  }

  return false;
}

static hostkey_probe_result_t session_probe_client_hostkey_algorithms(
    ssh_session session, const char *const *required_algorithms, size_t required_algorithm_count) {
  hostkey_probe_result_t result;
  result.status = HOSTKEY_SUPPORT_UNKNOWN;
  result.offered_algorithms[0] = '\0';

  if (session == NULL || required_algorithms == NULL || required_algorithm_count == 0U) {
    return result;
  }

  for (size_t i = 0; i < required_algorithm_count; ++i) {
    if (required_algorithms[i] == NULL || required_algorithms[i][0] == '\0') {
      return result;
    }
  }

  const int socket_fd = ssh_get_fd(session);
  if (socket_fd < 0) {
    return result;
  }

  const size_t max_buffer_size = 65536U;
  size_t buffer_size = 16384U;
  unsigned char *buffer = (unsigned char *)GC_MALLOC(buffer_size);
  if (buffer == NULL) {
    return result;
  }

  unsigned int attempts = 0U;
  const unsigned int max_attempts = 5U;

  while (attempts < max_attempts) {
    struct pollfd poll_fd;
    poll_fd.fd = socket_fd;
    poll_fd.events = POLLIN;
    poll_fd.revents = 0;

    int poll_result = poll(&poll_fd, 1, 1000);
    if (poll_result < 0) {
      if (errno == EINTR) {
        continue;
      }
      break;
    }

    if (poll_result == 0) {
      ++attempts;
      continue;
    }

    if ((poll_fd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
      break;
    }

    ssize_t peeked = recv(socket_fd, buffer, buffer_size, MSG_PEEK | MSG_DONTWAIT);
    if (peeked < 0) {
      if (errno == EINTR) {
        continue;
      }
      if (errno == EAGAIN
#ifdef EWOULDBLOCK
          || errno == EWOULDBLOCK
#endif
      ) {
        ++attempts;
        continue;
      }
      break;
    }

    if (peeked == 0) {
      break;
    }

    size_t available = (size_t)peeked;
    unsigned char *newline = memchr(buffer, '\n', available);
    if (newline == NULL) {
      if (available == buffer_size && buffer_size < max_buffer_size) {
        size_t new_size = buffer_size * 2U;
        if (new_size > max_buffer_size) {
          new_size = max_buffer_size;
        }
        unsigned char *resized = realloc(buffer, new_size);
        if (resized != NULL) {
          buffer = resized;
          buffer_size = new_size;
          continue;
        }
      }
      ++attempts;
      continue;
    }

    size_t payload_offset = (size_t)(newline - buffer) + 1U;
    while (payload_offset < available && (buffer[payload_offset] == '\r' || buffer[payload_offset] == '\n')) {
      ++payload_offset;
    }

    if (available <= payload_offset || available - payload_offset < 5U) {
      ++attempts;
      continue;
    }

    const unsigned char *packet = buffer + payload_offset;
    uint32_t packet_length = ((uint32_t)packet[0] << 24) | ((uint32_t)packet[1] << 16) |
                             ((uint32_t)packet[2] << 8) | (uint32_t)packet[3];
    if (packet_length == 0U) {
      break;
    }

    size_t total_packet_size = 4U + (size_t)packet_length;
    if (total_packet_size > available - payload_offset) {
      if (payload_offset + total_packet_size > buffer_size && buffer_size < max_buffer_size) {
        size_t new_size = buffer_size;
        while (new_size < payload_offset + total_packet_size && new_size < max_buffer_size) {
          new_size *= 2U;
          if (new_size > max_buffer_size) {
            new_size = max_buffer_size;
          }
        }
        if (new_size > buffer_size) {
          unsigned char *resized = realloc(buffer, new_size);
          if (resized != NULL) {
            buffer = resized;
            buffer_size = new_size;
            continue;
          }
        }
      }
      ++attempts;
      continue;
    }

    unsigned int padding_length = packet[4];
    if ((size_t)padding_length + 1U > packet_length) {
      break;
    }

    size_t payload_length = (size_t)packet_length - (size_t)padding_length - 1U;
    if (payload_length < 17U) {
      break;
    }

    const unsigned char *payload = packet + 5;
    if (payload[0] != 20U) {
      break;
    }

    const unsigned char *cursor = payload + 17U;
    size_t remaining = payload_length - 17U;
    if (remaining < 4U) {
      break;
    }

    uint32_t kex_names_len = ((uint32_t)cursor[0] << 24) | ((uint32_t)cursor[1] << 16) |
                             ((uint32_t)cursor[2] << 8) | (uint32_t)cursor[3];
    cursor += 4U;
    if ((size_t)kex_names_len > remaining - 4U) {
      break;
    }

    cursor += (size_t)kex_names_len;
    remaining -= 4U + (size_t)kex_names_len;
    if (remaining < 4U) {
      break;
    }

    uint32_t hostkey_names_len = ((uint32_t)cursor[0] << 24) | ((uint32_t)cursor[1] << 16) |
                                 ((uint32_t)cursor[2] << 8) | (uint32_t)cursor[3];
    cursor += 4U;
    if ((size_t)hostkey_names_len > remaining - 4U) {
      break;
    }

    size_t hostkey_len = (size_t)hostkey_names_len;
    const unsigned char *hostkey_data = cursor;

    size_t copy_length = hostkey_len;
    if (copy_length >= sizeof(result.offered_algorithms)) {
      copy_length = sizeof(result.offered_algorithms) - 1U;
    }
    memcpy(result.offered_algorithms, hostkey_data, copy_length);
    result.offered_algorithms[copy_length] = '\0';

    if (hostkey_len == 0U) {
      result.status = HOSTKEY_SUPPORT_REJECTED;
    } else {
      bool supported = false;
      for (size_t i = 0; i < required_algorithm_count; ++i) {
        const char *algorithm = required_algorithms[i];
        const size_t required_length = strlen(algorithm);
        if (required_length == 0U) {
          continue;
        }

        if (hostkey_list_contains(hostkey_data, hostkey_len, algorithm, required_length)) {
          supported = true;
          break;
        }
      }

      if (supported) {
        result.status = HOSTKEY_SUPPORT_ACCEPTED;
      } else {
        result.status = HOSTKEY_SUPPORT_REJECTED;
      }
    }

    return result;
  }

  return result;
}

static bool session_is_private_ipv4(const unsigned char octets[4]) {
  if (octets == NULL) {
    return false;
  }

  if (octets[0] == 10U || octets[0] == 127U) {
    return true;
  }

  if (octets[0] == 172U && octets[1] >= 16U && octets[1] <= 31U) {
    return true;
  }

  if ((octets[0] == 192U && octets[1] == 168U) || (octets[0] == 169U && octets[1] == 254U)) {
    return true;
  }

  return false;
}

static bool session_is_lan_client(const char *ip) {
  if (ip == NULL || ip[0] == '\0') {
    return false;
  }

  struct in_addr addr4;
  if (inet_pton(AF_INET, ip, &addr4) == 1) {
    unsigned char octets[4];
    memcpy(octets, &addr4.s_addr, sizeof(octets));
    return session_is_private_ipv4(octets);
  }

  struct in6_addr addr6;
  if (inet_pton(AF_INET6, ip, &addr6) != 1) {
    return false;
  }

  if (IN6_IS_ADDR_LOOPBACK(&addr6) || IN6_IS_ADDR_LINKLOCAL(&addr6)) {
    return true;
  }

  if (IN6_IS_ADDR_V4MAPPED(&addr6)) {
    return session_is_private_ipv4(&addr6.s6_addr[12]);
  }

  const unsigned char first_byte = addr6.s6_addr[0];
  if ((first_byte & 0xfeU) == 0xfcU) { // fc00::/7 unique local
    return true;
  }

  return false;
}

static void session_assign_lan_privileges(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->lan_operator_credentials_valid) {
    ctx->user.is_lan_operator = false;
    return;
  }

  if (!session_is_lan_client(ctx->client_ip)) {
    ctx->lan_operator_credentials_valid = false;
    ctx->user.is_lan_operator = false;
    return;
  }

  if (!host_is_lan_operator_username(ctx->owner, ctx->user.name)) {
    ctx->lan_operator_credentials_valid = false;
    ctx->user.is_lan_operator = false;
    return;
  }

  ctx->user.is_operator = true;
  ctx->auth.is_operator = true;
  ctx->user.is_lan_operator = true;
}

static void session_apply_granted_privileges(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (host_ip_has_grant(ctx->owner, ctx->client_ip)) {
    ctx->user.is_operator = true;
    ctx->auth.is_operator = true;
  }
}

static void chat_room_add(chat_room_t *room, session_ctx_t *session) {
  if (room == NULL || session == NULL) {
    return;
  }

  pthread_mutex_lock(&room->lock);
  if (chat_room_ensure_capacity(room, room->member_count + 1U)) {
    room->members[room->member_count++] = session;
  } else {
    humanized_log_error("chat-room", "failed to grow member list", ENOMEM);
  }
  pthread_mutex_unlock(&room->lock);
}

static void chat_room_remove(chat_room_t *room, const session_ctx_t *session) {
  if (room == NULL || session == NULL) {
    return;
  }

  pthread_mutex_lock(&room->lock);
  for (size_t idx = 0; idx < room->member_count; ++idx) {
    if (room->members[idx] == session) {
      for (size_t shift = idx; shift + 1U < room->member_count; ++shift) {
        room->members[shift] = room->members[shift + 1U];
      }
      room->members[room->member_count - 1U] = NULL;
      room->member_count--;
      break;
    }
  }
  pthread_mutex_unlock(&room->lock);
}

static void chat_room_broadcast(chat_room_t *room, const char *message, const session_ctx_t *from) {
  if (room == NULL || message == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  chat_history_entry_t entry = {0};
  if (from != NULL) {
    chat_history_entry_prepare_user(&entry, from, message);
  }

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        if (from != NULL && member == from) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    if (from != NULL) {
      session_send_history_entry(member, &entry);
    } else {
      session_send_system_line(member, message);
    }

    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  if (from != NULL) {
    printf("[broadcast:%s] %s\n", from->user.name, message);
  } else {
    printf("[broadcast] %s\n", message);
  }

}

static void chat_room_broadcast_caption(chat_room_t *room, const char *message) {
  if (room == NULL || message == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    session_send_caption_line(member, message);
    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  printf("[broadcast caption] %s\n", message);

}

static void chat_room_broadcast_entry(chat_room_t *room, const chat_history_entry_t *entry, const session_ctx_t *from) {
  if (room == NULL || entry == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        if (from != NULL && member == from) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate entry broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    session_send_history_entry(member, entry);
    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  if (entry->is_user_message) {
    const char *message_text = entry->message;
    char fallback[SSH_CHATTER_MESSAGE_LIMIT + 64];
    if ((message_text == NULL || message_text[0] == '\0') && entry->attachment_type != CHAT_ATTACHMENT_NONE) {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      snprintf(fallback, sizeof(fallback), "shared a %s", label);
      message_text = fallback;
    } else if (message_text == NULL) {
      message_text = "";
    }

    printf("[broadcast:%s#%" PRIu64 "] %s\n", entry->username, entry->message_id, message_text);
    if (entry->attachment_type != CHAT_ATTACHMENT_NONE && entry->attachment_target[0] != '\0') {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      printf("           %s: %s\n", label, entry->attachment_target);
    }
  }

}

static void chat_room_broadcast_reaction_update(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  char summary[SSH_CHATTER_MESSAGE_LIMIT];
  if (!chat_history_entry_build_reaction_summary(entry, summary, sizeof(summary))) {
    return;
  }

  char line[SSH_CHATTER_MESSAGE_LIMIT + 64];
  if (entry->message_id > 0U) {
    snprintf(line, sizeof(line), "    ↳ [#%" PRIu64 "] reactions: %s", entry->message_id, summary);
  } else {
    snprintf(line, sizeof(line), "    ↳ reactions: %s", summary);
  }

  chat_room_broadcast_caption(&host->room, line);
}

static void host_broadcast_reply(host_t *host, const chat_reply_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  const char *target_prefix = (entry->parent_reply_id == 0U) ? "#" : "r#";
  uint64_t target_id = (entry->parent_reply_id == 0U) ? entry->parent_message_id : entry->parent_reply_id;

  char line[SSH_CHATTER_MESSAGE_LIMIT + 160];
  snprintf(line, sizeof(line), "↳ [r#%" PRIu64 " → %s%" PRIu64 "] %s: %s", entry->reply_id, target_prefix, target_id,
           entry->username, entry->message);

  chat_room_broadcast(&host->room, line, NULL);
}

static bool host_history_reserve_locked(host_t *host, size_t min_capacity) {
  if (host == NULL) {
    return false;
  }

  if (min_capacity <= host->history_capacity) {
    return true;
  }

  if (min_capacity > SIZE_MAX / sizeof(chat_history_entry_t)) {
    humanized_log_error("host-history", "history buffer too large to allocate", ENOMEM);
    return false;
  }

  size_t new_capacity = host->history_capacity > 0U ? host->history_capacity : 64U;
  if (new_capacity == 0U) {
    new_capacity = 64U;
  }

  while (new_capacity < min_capacity) {
    if (new_capacity > SIZE_MAX / 2U) {
      new_capacity = min_capacity;
      break;
    }
    size_t doubled = new_capacity * 2U;
    if (doubled < new_capacity || doubled > SIZE_MAX / sizeof(chat_history_entry_t)) {
      new_capacity = min_capacity;
      break;
    }
    new_capacity = doubled;
  }

  size_t bytes = new_capacity * sizeof(chat_history_entry_t);
  chat_history_entry_t *resized = realloc(host->history, bytes);
  if (resized == NULL) {
    humanized_log_error("host-history", "failed to grow chat history buffer", errno != 0 ? errno : ENOMEM);
    return false;
  }

  if (new_capacity > host->history_capacity) {
    size_t old_capacity = host->history_capacity;
    size_t added = new_capacity - old_capacity;
    memset(resized + old_capacity, 0, added * sizeof(chat_history_entry_t));
  }

  host->history = resized;
  host->history_capacity = new_capacity;
  return true;
}

static bool host_history_append_locked(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  if (!host_history_reserve_locked(host, host->history_count + 1U)) {
    return false;
  }

  host->history[host->history_count++] = *entry;
  host_state_save_locked(host);
  return true;
}

static size_t host_history_total(host_t *host) {
  if (host == NULL) {
    return 0U;
  }

  size_t count = 0U;
  pthread_mutex_lock(&host->lock);
  count = host->history_count;
  pthread_mutex_unlock(&host->lock);
  return count;
}

static size_t host_history_copy_range(host_t *host, size_t start_index, chat_history_entry_t *buffer, size_t capacity) {
  if (host == NULL || buffer == NULL || capacity == 0U) {
    return 0U;
  }

  size_t copied = 0U;
  pthread_mutex_lock(&host->lock);
  size_t total = host->history_count;
  if (start_index >= total || host->history == NULL) {
    pthread_mutex_unlock(&host->lock);
    return 0U;
  }

  size_t available = total - start_index;
  if (available > capacity) {
    available = capacity;
  }

  memcpy(buffer, host->history + start_index, available * sizeof(chat_history_entry_t));
  copied = available;
  pthread_mutex_unlock(&host->lock);
  return copied;
}

static bool host_history_find_entry_by_id(host_t *host, uint64_t message_id, chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL || message_id == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  if (host->history != NULL) {
    for (size_t idx = 0U; idx < host->history_count; ++idx) {
      const chat_history_entry_t *candidate = &host->history[idx];
      if (candidate->message_id != message_id) {
        continue;
      }

      *entry = *candidate;
      found = true;
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  return found;
}

static size_t host_history_delete_range(host_t *host, uint64_t start_id, uint64_t end_id, uint64_t *first_removed,
                                        uint64_t *last_removed, size_t *replies_removed) {
  if (first_removed != NULL) {
    *first_removed = 0U;
  }
  if (last_removed != NULL) {
    *last_removed = 0U;
  }
  if (replies_removed != NULL) {
    *replies_removed = 0U;
  }

  if (host == NULL || start_id == 0U || end_id == 0U || start_id > end_id) {
    return 0U;
  }

  size_t removed = 0U;
  size_t reply_removed = 0U;
  uint64_t local_first = 0U;
  uint64_t local_last = 0U;

  pthread_mutex_lock(&host->lock);
  if (host->history != NULL && host->history_count > 0U) {
    size_t write_index = 0U;
    for (size_t idx = 0U; idx < host->history_count; ++idx) {
      chat_history_entry_t *entry = &host->history[idx];
      const bool drop = entry->is_user_message && entry->message_id >= start_id && entry->message_id <= end_id;
      if (drop) {
        if (local_first == 0U || entry->message_id < local_first) {
          local_first = entry->message_id;
        }
        if (entry->message_id > local_last) {
          local_last = entry->message_id;
        }
        ++removed;
        continue;
      }

      if (write_index != idx) {
        host->history[write_index] = *entry;
      }
      ++write_index;
    }

    if (removed > 0U) {
      for (size_t idx = write_index; idx < host->history_count; ++idx) {
        memset(&host->history[idx], 0, sizeof(host->history[idx]));
      }
      host->history_count = write_index;
      host_state_save_locked(host);
    }
  }

  if (removed > 0U && host->reply_count > 0U) {
    size_t write_index = 0U;
    for (size_t idx = 0U; idx < host->reply_count; ++idx) {
      chat_reply_entry_t *entry = &host->replies[idx];
      if (!entry->in_use) {
        continue;
      }

      const bool drop = entry->parent_message_id >= start_id && entry->parent_message_id <= end_id;
      if (drop) {
        ++reply_removed;
        continue;
      }

      if (write_index != idx) {
        host->replies[write_index] = *entry;
      }
      ++write_index;
    }

    if (reply_removed > 0U) {
      for (size_t idx = write_index; idx < host->reply_count; ++idx) {
        memset(&host->replies[idx], 0, sizeof(host->replies[idx]));
      }
      host->reply_count = write_index;

      uint64_t max_reply_id = 0U;
      for (size_t idx = 0U; idx < host->reply_count; ++idx) {
        const chat_reply_entry_t *entry = &host->replies[idx];
        if (!entry->in_use) {
          continue;
        }
        if (entry->reply_id > max_reply_id) {
          max_reply_id = entry->reply_id;
        }
      }

      if (max_reply_id == 0U) {
        host->next_reply_id = host->reply_count == 0U ? 1U : host->next_reply_id;
      } else if (host->next_reply_id <= max_reply_id) {
        host->next_reply_id = (max_reply_id == UINT64_MAX) ? UINT64_MAX : max_reply_id + 1U;
      }

      host_reply_state_save_locked(host);
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (removed > 0U) {
    if (first_removed != NULL) {
      *first_removed = local_first;
    }
    if (last_removed != NULL) {
      *last_removed = local_last;
    }
  }
  if (replies_removed != NULL) {
    *replies_removed = reply_removed;
  }

  return removed;
}

static bool host_replies_find_entry_by_id(host_t *host, uint64_t reply_id, chat_reply_entry_t *entry) {
  if (host == NULL || entry == NULL || reply_id == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < host->reply_count; ++idx) {
    const chat_reply_entry_t *candidate = &host->replies[idx];
    if (!candidate->in_use) {
      continue;
    }
    if (candidate->reply_id != reply_id) {
      continue;
    }

    *entry = *candidate;
    found = true;
    break;
  }
  pthread_mutex_unlock(&host->lock);

  return found;
}

static void chat_history_entry_prepare_user(chat_history_entry_t *entry, const session_ctx_t *from, const char *message) {
  if (entry == NULL || from == NULL) {
    return;
  }

  memset(entry, 0, sizeof(*entry));
  entry->is_user_message = true;
  if (message != NULL) {
    snprintf(entry->message, sizeof(entry->message), "%s", message);
  }
  snprintf(entry->username, sizeof(entry->username), "%s", from->user.name);
  entry->user_color_code = from->user_color_code;
  entry->user_highlight_code = from->user_highlight_code;
  entry->user_is_bold = from->user_is_bold;
  snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", from->user_color_name);
  snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s", from->user_highlight_name);
  entry->attachment_type = CHAT_ATTACHMENT_NONE;
  entry->message_id = 0U;
}

static bool host_history_commit_entry(host_t *host, chat_history_entry_t *entry, chat_history_entry_t *stored_entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  host_history_normalize_entry(host, entry);

  pthread_mutex_lock(&host->lock);
  if (entry->is_user_message) {
    if (host->next_message_id == 0U) {
      host->next_message_id = 1U;
    }
    entry->message_id = host->next_message_id++;
  } else {
    entry->message_id = 0U;
  }

  if (!host_history_append_locked(host, entry)) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }

  if (stored_entry != NULL) {
    *stored_entry = *entry;
  }

  pthread_mutex_unlock(&host->lock);
  return true;
}

static bool host_replies_commit_entry(host_t *host, chat_reply_entry_t *entry, chat_reply_entry_t *stored_entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  bool committed = false;

  pthread_mutex_lock(&host->lock);
  if (host->reply_count >= SSH_CHATTER_MAX_REPLIES) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }

  uint64_t assigned_id = host->next_reply_id;
  if (assigned_id == 0U || assigned_id == UINT64_MAX) {
    assigned_id = (uint64_t)host->reply_count + 1U;
  }

  entry->reply_id = assigned_id;
  if (assigned_id < UINT64_MAX) {
    host->next_reply_id = assigned_id + 1U;
  } else {
    host->next_reply_id = assigned_id;
  }

  entry->in_use = true;

  size_t slot = host->reply_count;
  host->replies[slot] = *entry;
  host->reply_count = slot + 1U;

  host_reply_state_save_locked(host);

  if (stored_entry != NULL) {
    *stored_entry = host->replies[slot];
  }

  committed = true;

  pthread_mutex_unlock(&host->lock);
  return committed;
}

static void host_notify_external_clients(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }
  if (host->clients == NULL) {
    return;
  }
  client_manager_notify_history(host->clients, entry);
}

static bool host_history_record_user(host_t *host, const session_ctx_t *from, const char *message,
                                     chat_history_entry_t *stored_entry) {
  if (host == NULL || from == NULL || message == NULL || message[0] == '\0') {
    return false;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, from, message);
  return host_history_commit_entry(host, &entry, stored_entry);
}

static void host_history_record_system(host_t *host, const char *message) {
  if (host == NULL || message == NULL || message[0] == '\0') {
    return;
  }

  chat_history_entry_t entry = {0};
  entry.is_user_message = false;
  snprintf(entry.message, sizeof(entry.message), "%s", message);
  entry.user_color_name[0] = '\0';
  entry.user_highlight_name[0] = '\0';
  entry.attachment_type = CHAT_ATTACHMENT_NONE;
  entry.message_id = 0U;

  if (!host_history_commit_entry(host, &entry, NULL)) {
    return;
  }
  host_notify_external_clients(host, &entry);
}

static bool host_history_apply_reaction(host_t *host, uint64_t message_id, size_t reaction_index,
                                        chat_history_entry_t *updated_entry) {
  if (host == NULL || message_id == 0U || reaction_index >= SSH_CHATTER_REACTION_KIND_COUNT) {
    return false;
  }

  bool applied = false;

  pthread_mutex_lock(&host->lock);
  if (host->history == NULL) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }
  for (size_t idx = 0U; idx < host->history_count; ++idx) {
    chat_history_entry_t *entry = &host->history[idx];
    if (!entry->is_user_message) {
      continue;
    }
    if (entry->message_id != message_id) {
      continue;
    }

    if (entry->reaction_counts[reaction_index] < UINT32_MAX) {
      entry->reaction_counts[reaction_index] += 1U;
    }

    if (updated_entry != NULL) {
      *updated_entry = *entry;
    }

    host_state_save_locked(host);
    applied = true;
    break;
  }
  pthread_mutex_unlock(&host->lock);

  return applied;
}

static void session_apply_theme_defaults(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;

  ctx->user_color_code = host->user_theme.userColor;
  ctx->user_highlight_code = host->user_theme.highlight;
  ctx->user_is_bold = host->user_theme.isBold;
  snprintf(ctx->user_color_name, sizeof(ctx->user_color_name), "%s", host->default_user_color_name);
  snprintf(ctx->user_highlight_name, sizeof(ctx->user_highlight_name), "%s", host->default_user_highlight_name);

  session_apply_system_theme_defaults(ctx);
}

static void session_apply_system_theme_defaults(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;

  ctx->system_fg_code = host->system_theme.foregroundColor;
  ctx->system_bg_code = host->system_theme.backgroundColor;
  ctx->system_highlight_code = host->system_theme.highlightColor;
  ctx->system_is_bold = host->system_theme.isBold;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", host->default_system_fg_name);
  snprintf(ctx->system_bg_name, sizeof(ctx->system_bg_name), "%s", host->default_system_bg_name);
  snprintf(ctx->system_highlight_name, sizeof(ctx->system_highlight_name), "%s", host->default_system_highlight_name);
  session_force_dark_mode_foreground(ctx);
}

static void session_force_dark_mode_foreground(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  const bool has_name = ctx->system_fg_name[0] != '\0';
  const bool name_is_default = has_name && strcasecmp(ctx->system_fg_name, "default") == 0;
  const bool missing_name = !has_name;
  const bool code_is_default = ctx->system_fg_code == NULL || strcmp(ctx->system_fg_code, ANSI_DEFAULT) == 0;

  if (!missing_name && !name_is_default && !code_is_default) {
    return;
  }

  ctx->system_fg_code = ANSI_WHITE;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", "white");
}

static user_preference_t *host_find_preference_locked(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    user_preference_t *pref = &host->preferences[idx];
    if (!pref->in_use) {
      continue;
    }

    if (strncmp(pref->username, username, SSH_CHATTER_USERNAME_LEN) == 0) {
      return pref;
    }
  }

  return NULL;
}

static user_preference_t *host_ensure_preference_locked(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return NULL;
  }

  user_preference_t *existing = host_find_preference_locked(host, username);
  if (existing != NULL) {
    return existing;
  }

  for (size_t idx = 0; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    user_preference_t *pref = &host->preferences[idx];
    if (pref->in_use) {
      continue;
    }

    memset(pref, 0, sizeof(*pref));
    pref->in_use = true;
    pref->last_poll_choice = -1;
    snprintf(pref->username, sizeof(pref->username), "%s", username);
    if (host->preference_count < SSH_CHATTER_MAX_PREFERENCES) {
      ++host->preference_count;
    }
    return pref;
  }

  return NULL;
}

static void host_store_user_theme(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_user_theme = true;
    snprintf(pref->user_color_name, sizeof(pref->user_color_name), "%s", ctx->user_color_name);
    snprintf(pref->user_highlight_name, sizeof(pref->user_highlight_name), "%s", ctx->user_highlight_name);
    pref->user_is_bold = ctx->user_is_bold;
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_system_theme(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_system_theme = true;
    snprintf(pref->system_fg_name, sizeof(pref->system_fg_name), "%s", ctx->system_fg_name);
    snprintf(pref->system_bg_name, sizeof(pref->system_bg_name), "%s", ctx->system_bg_name);
    snprintf(pref->system_highlight_name, sizeof(pref->system_highlight_name), "%s", ctx->system_highlight_name);
    pref->system_is_bold = ctx->system_is_bold;
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_user_os(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    snprintf(pref->os_name, sizeof(pref->os_name), "%s", ctx->os_name);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_birthday(host_t *host, const session_ctx_t *ctx, const char *birthday) {
  if (host == NULL || ctx == NULL || birthday == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_birthday = true;
    snprintf(pref->birthday, sizeof(pref->birthday), "%s", birthday);
  }
  host_state_save_locked(host);
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_chat_spacing(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    if (ctx->translation_caption_spacing > UINT8_MAX) {
      pref->translation_caption_spacing = UINT8_MAX;
    } else {
      pref->translation_caption_spacing = (uint8_t)ctx->translation_caption_spacing;
    }
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_translation_preferences(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->translation_master_enabled = ctx->translation_enabled;
    pref->translation_master_explicit = true;
    pref->output_translation_enabled = ctx->output_translation_enabled;
    pref->input_translation_enabled = ctx->input_translation_enabled;
    snprintf(pref->output_translation_language, sizeof(pref->output_translation_language), "%s",
             ctx->output_translation_language);
    snprintf(pref->input_translation_language, sizeof(pref->input_translation_language), "%s",
             ctx->input_translation_language);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_ui_language(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    const char *code = session_ui_language_code(ctx->ui_language);
    snprintf(pref->ui_language, sizeof(pref->ui_language), "%s", code);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static bool host_ip_has_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < host->operator_grant_count; ++idx) {
    if (strncmp(host->operator_grants[idx].ip, ip, SSH_CHATTER_IP_LEN) == 0) {
      return true;
    }
  }

  return false;
}

static bool host_add_operator_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  if (host_ip_has_grant_locked(host, ip)) {
    return true;
  }

  if (host->operator_grant_count >= SSH_CHATTER_MAX_GRANTS) {
    return false;
  }

  snprintf(host->operator_grants[host->operator_grant_count].ip,
           sizeof(host->operator_grants[host->operator_grant_count].ip), "%s", ip);
  ++host->operator_grant_count;
  return true;
}

static bool host_ip_has_grant(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  bool result = false;
  pthread_mutex_lock(&host->lock);
  result = host_ip_has_grant_locked(host, ip);
  pthread_mutex_unlock(&host->lock);
  return result;
}

static void host_apply_grant_to_ip(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return;
  }

  session_ctx_t **matches = NULL;
  size_t match_count = 0U;

  pthread_mutex_lock(&host->room.lock);
  if (host->room.member_count > 0U) {
    matches = GC_CALLOC(host->room.member_count, sizeof(*matches));
    if (matches != NULL) {
      for (size_t idx = 0U; idx < host->room.member_count; ++idx) {
        session_ctx_t *member = host->room.members[idx];
        if (member == NULL) {
          continue;
        }
        if (strncmp(member->client_ip, ip, SSH_CHATTER_IP_LEN) != 0) {
          continue;
        }
        member->user.is_operator = true;
        member->auth.is_operator = true;
        matches[match_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&host->room.lock);

  if (matches == NULL) {
    return;
  }

  for (size_t idx = 0U; idx < match_count; ++idx) {
    session_ctx_t *member = matches[idx];
    session_send_system_line(member, "Operator privileges granted for your IP address.");
  }
}

static bool host_remove_operator_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < host->operator_grant_count; ++idx) {
    if (strncmp(host->operator_grants[idx].ip, ip, SSH_CHATTER_IP_LEN) != 0) {
      continue;
    }

    for (size_t shift = idx; shift + 1U < host->operator_grant_count; ++shift) {
      host->operator_grants[shift] = host->operator_grants[shift + 1U];
    }
    memset(&host->operator_grants[host->operator_grant_count - 1U], 0,
           sizeof(host->operator_grants[host->operator_grant_count - 1U]));
    --host->operator_grant_count;
    return true;
  }

  return false;
}

static void host_revoke_grant_from_ip(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return;
  }

  session_ctx_t **matches = NULL;
  size_t match_count = 0U;

  pthread_mutex_lock(&host->room.lock);
  if (host->room.member_count > 0U) {
    session_ctx_t **allocated = GC_CALLOC(host->room.member_count, sizeof(*allocated));
    if (allocated != NULL) {
      matches = allocated;
    }

    for (size_t idx = 0U; idx < host->room.member_count; ++idx) {
      session_ctx_t *member = host->room.members[idx];
      if (member == NULL) {
        continue;
      }
      if (strncmp(member->client_ip, ip, SSH_CHATTER_IP_LEN) != 0) {
        continue;
      }
      if (member->user.is_lan_operator) {
        continue;
      }

      member->user.is_operator = false;
      member->auth.is_operator = false;

      if (matches != NULL) {
        matches[match_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&host->room.lock);

  if (matches == NULL) {
    return;
  }

  for (size_t idx = 0U; idx < match_count; ++idx) {
    session_ctx_t *member = matches[idx];
    if (member == NULL) {
      continue;
    }
    session_send_system_line(member, "Operator privileges revoked for your IP address.");
  }

}

static bool host_lookup_user_os(host_t *host, const char *username, char *buffer, size_t length) {
  if (host == NULL || username == NULL || buffer == NULL || length == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_find_preference_locked(host, username);
  if (pref != NULL && pref->os_name[0] != '\0') {
    snprintf(buffer, length, "%s", pref->os_name);
    found = true;
  }
  pthread_mutex_unlock(&host->lock);

  if (found) {
    return true;
  }

  session_ctx_t *session = chat_room_find_user(&host->room, username);
  if (session != NULL && session->os_name[0] != '\0') {
    snprintf(buffer, length, "%s", session->os_name);
    return true;
  }

  return false;
}

static void host_history_normalize_entry(host_t *host, chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  if (!entry->is_user_message) {
    entry->user_color_code = NULL;
    entry->user_highlight_code = NULL;
    entry->user_is_bold = false;
    entry->user_color_name[0] = '\0';
    entry->user_highlight_name[0] = '\0';
    return;
  }

  const char *color_code = lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]),
                                             entry->user_color_name);
  if (color_code == NULL) {
    color_code = host->user_theme.userColor;
    snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", host->default_user_color_name);
  }

  const char *highlight_code = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                                sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]),
                                                entry->user_highlight_name);
  if (highlight_code == NULL) {
    highlight_code = host->user_theme.highlight;
    snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s",
             host->default_user_highlight_name);
  }

  entry->user_color_code = color_code;
  entry->user_highlight_code = highlight_code;
}

static void host_security_configure(host_t *host) {
  if (host == NULL) {
    return;
  }

  atomic_store(&host->security_filter_enabled, false);
  atomic_store(&host->security_filter_failure_logged, false);
  atomic_store(&host->security_ai_enabled, false);
  atomic_store(&host->security_clamav_enabled, false);
  atomic_store(&host->security_clamav_failure_logged, false);
  host->security_clamav_command[0] = '\0';

  const char *toggle = getenv("CHATTER_SECURITY_FILTER");
  if (toggle != NULL && toggle[0] != '\0') {
    if (strcasecmp(toggle, "0") == 0 || strcasecmp(toggle, "false") == 0 || strcasecmp(toggle, "off") == 0) {
      return;
    }
  }

  bool pipeline_enabled = false;

  const char *clamav_toggle = getenv("CHATTER_CLAMAV");
  bool clamav_disabled = false;
  if (clamav_toggle != NULL && clamav_toggle[0] != '\0') {
    if (strcasecmp(clamav_toggle, "0") == 0 || strcasecmp(clamav_toggle, "false") == 0 ||
        strcasecmp(clamav_toggle, "off") == 0) {
      clamav_disabled = true;
    }
  }

  if (!clamav_disabled) {
    const char *command = getenv("CHATTER_CLAMAV_COMMAND");
    if (command == NULL || command[0] == '\0') {
      command = "clamscan --no-summary --stdout .";
    }

    size_t command_length = strlen(command);
    if (command_length < sizeof(host->security_clamav_command)) {
      snprintf(host->security_clamav_command, sizeof(host->security_clamav_command), "%s", command);
      atomic_store(&host->security_clamav_enabled, true);
      pipeline_enabled = true;
    }
  }

  bool ai_requested = false;
  const char *ai_toggle = getenv("CHATTER_SECURITY_AI");
  if (ai_toggle != NULL && ai_toggle[0] != '\0') {
    if (!(strcasecmp(ai_toggle, "0") == 0 || strcasecmp(ai_toggle, "false") == 0 ||
          strcasecmp(ai_toggle, "off") == 0)) {
      ai_requested = true;
    }
  }

  if (ai_requested) {
    bool has_gemini = false;
    const char *gemini_key = getenv("GEMINI_API_KEY");
    if (gemini_key != NULL && gemini_key[0] != '\0') {
      has_gemini = true;
    }

    atomic_store(&host->security_ai_enabled, true);
    pipeline_enabled = true;

    const char *message = has_gemini ?
                             "[security] AI payload moderation enabled (Gemini primary, Ollama fallback)" :
                             "[security] AI payload moderation enabled (Ollama fallback only)";

    printf("%s\n", message);
  } else {
    printf("[security] AI payload moderation disabled (set CHATTER_SECURITY_AI=on to enable)\n");
  }

  if (pipeline_enabled) {
    atomic_store(&host->security_filter_enabled, true);
  }
}

static void host_security_disable_filter(host_t *host, const char *reason) {
  if (host == NULL) {
    return;
  }

  if (!atomic_exchange(&host->security_ai_enabled, false)) {
    return;
  }

  if (reason == NULL || reason[0] == '\0') {
    reason = "moderation failure";
  }

  if (!atomic_exchange(&host->security_filter_failure_logged, true)) {
    printf("[security] disabling payload moderation: %s\n", reason);
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    atomic_store(&host->security_filter_enabled, false);
  }
}

static void host_security_disable_clamav(host_t *host, const char *reason) {
  if (host == NULL) {
    return;
  }

  if (!atomic_exchange(&host->security_clamav_enabled, false)) {
    return;
  }

  if (reason == NULL || reason[0] == '\0') {
    reason = "ClamAV failure";
  }

  if (!atomic_exchange(&host->security_clamav_failure_logged, true)) {
    printf("[security] disabling ClamAV scanning: %s\n", reason);
  }

  if (!atomic_load(&host->security_ai_enabled)) {
    atomic_store(&host->security_filter_enabled, false);
  }
}

static void host_security_compact_whitespace(char *text) {
  if (text == NULL) {
    return;
  }

  size_t read_index = 0U;
  size_t write_index = 0U;
  bool previous_was_space = false;

  while (text[read_index] != '\0') {
    unsigned char ch = (unsigned char)text[read_index++];
    if (ch == '\r' || ch == '\n' || ch == '\t') {
      ch = ' ';
    } else if (ch < 0x20U || ch == 0x7FU) {
      ch = ' ';
    }

    if (ch == ' ') {
      if (previous_was_space) {
        continue;
      }
      previous_was_space = true;
      text[write_index++] = ' ';
    } else {
      previous_was_space = false;
      text[write_index++] = (char)ch;
    }
  }

  if (write_index > 0U && text[write_index - 1U] == ' ') {
    --write_index;
  }

  text[write_index] = '\0';
}


static double host_elapsed_seconds(const struct timespec *start,
                                 const struct timespec *end) {
  double sec = (double)end->tv_sec - (double)start->tv_sec;
  double nsec_to_sec = ((double)end->tv_nsec - (double)start->tv_nsec) / 1000000000.0;

  return sec + nsec_to_sec;
}


static bool host_security_execute_clamav_backend(host_t *host, char *notice, size_t notice_length) {
  if (notice != NULL && notice_length > 0U) {
    notice[0] = '\0';
  }

  if (host == NULL || notice == NULL || notice_length == 0U) {
    return false;
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    return false;
  }

  if (host->security_clamav_command[0] == '\0') {
    return false;
  }

  struct timespec start = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &start);

  int pipefd[2];
  if (pipe(pipefd) == -1) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed to create pipe (%s).", reason);
    host_security_disable_clamav(host, reason);
    return true;
  }

  pid_t pid = fork();
  if (pid == -1) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan fork() failed (%s).", reason);
    host_security_disable_clamav(host, reason);
    close(pipefd[0]);
    close(pipefd[1]);
    return true;
  }

  if (pid == 0) {
    // child process: redirect stdout/stderr to pipe
    close(pipefd[0]);
    dup2(pipefd[1], STDOUT_FILENO);
    dup2(pipefd[1], STDERR_FILENO);
    close(pipefd[1]);

    // execute clamscan without shell parsing issues
    const char *argv[] = {"sh", "-c", host->security_clamav_command, NULL};
    execvp(argv[0], (char *const *)argv);

    // only runs if exec failed
    fprintf(stderr, "[security] execvp() failed: %s\n", strerror(errno));
    _exit(127);
  }

  // parent process: turn pipefd[0] into a FILE* for compatibility
  close(pipefd[1]);
  FILE *pipe = fdopen(pipefd[0], "r");
  if (!pipe) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan fdopen() failed (%s).", reason);
    host_security_disable_clamav(host, reason);
    close(pipefd[0]);
    return true;
  }

  char output[SSH_CHATTER_CLAMAV_OUTPUT_LIMIT];
  output[0] = '\0';
  size_t output_length = 0U;

  char buffer[256];
  while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
    size_t chunk = strlen(buffer);
    if (chunk == 0U) {
      continue;
    }
    if (output_length + chunk >= sizeof(output)) {
      chunk = sizeof(output) - output_length - 1U;
    }
    if (chunk == 0U) {
      break;
    }
    memcpy(output + output_length, buffer, chunk);
    output_length += chunk;
    output[output_length] = '\0';
  }

  errno = 0;
  int status = pclose(pipe);
  struct timespec end = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &end);
  host->security_clamav_last_run = end;
  struct timespec elapsed = timespec_diff(&end, &start);
  double seconds = (double)elapsed.tv_sec + (double)elapsed.tv_nsec / 1000000000.0;

  host_security_compact_whitespace(output);

  if (status == -1) {
    int error_code = errno;
    if (error_code != 0) {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan failed (unable to retrieve status: %s).",
               strerror(error_code));
    } else {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan failed (unable to retrieve status).");
    }
    host_security_disable_clamav(host, "unable to retrieve scheduled ClamAV status");
    return true;
  }

  if (!WIFEXITED(status)) {
    snprintf(notice, notice_length, "* [security] Scheduled ClamAV scan terminated unexpectedly.");
    host_security_disable_clamav(host, "scheduled ClamAV scan terminated unexpectedly");
    return true;
  }

  int exit_code = WEXITSTATUS(status);
  if (exit_code == 0) {
    return true;
  }

  if (exit_code == 1) {
    if (output[0] != '\0') {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan finished in %.1fs (issues found): %s", seconds, output);
    } else {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan finished in %.1fs (issues found).", seconds);
    }
    return true;
  }

  if (output[0] != '\0') {
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed in %.1fs (exit code %d): %s", seconds, exit_code, output);
  } else {
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed in %.1fs (exit code %d).", seconds, exit_code);
  }
  host_security_disable_clamav(host, "scheduled ClamAV scan returned an error");
  return true;
}

static void *host_security_clamav_backend(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  atomic_store(&host->security_clamav_thread_running, true);
  printf("[security] scheduled ClamAV backend thread started (interval: %u seconds)\n",
         (unsigned int)SSH_CHATTER_CLAMAV_SCAN_INTERVAL_SECONDS);

  while (!atomic_load(&host->security_clamav_thread_stop)) {
    if (atomic_load(&host->security_clamav_enabled) && host->security_clamav_command[0] != '\0') {
      char notice[SSH_CHATTER_MESSAGE_LIMIT];
      if (host_security_execute_clamav_backend(host, notice, sizeof(notice)) && notice[0] != '\0') {
        printf("%s\n", notice);
        host_history_record_system(host, notice);
        chat_room_broadcast(&host->room, notice, NULL);
      }
    }

    unsigned int remaining = SSH_CHATTER_CLAMAV_SCAN_INTERVAL_SECONDS;
    while (remaining > 0U && !atomic_load(&host->security_clamav_thread_stop)) {
      unsigned int chunk =
          remaining > SSH_CHATTER_CLAMAV_SLEEP_CHUNK_SECONDS ? SSH_CHATTER_CLAMAV_SLEEP_CHUNK_SECONDS : remaining;
      struct timespec pause_duration = {
          .tv_sec = (time_t)chunk,
          .tv_nsec = 0,
      };
      nanosleep(&pause_duration, NULL);
      if (remaining < chunk) {
        remaining = 0U;
      } else {
        remaining -= chunk;
      }
    }
  }

  atomic_store(&host->security_clamav_thread_running, false);
  printf("[security] scheduled ClamAV backend thread stopped\n");
  return NULL;
}

static void host_security_start_clamav_backend(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->security_clamav_thread_initialized) {
    return;
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    return;
  }

  if (host->security_clamav_command[0] == '\0') {
    return;
  }

  atomic_store(&host->security_clamav_thread_stop, false);
  atomic_store(&host->security_clamav_thread_running, false);

  int error = pthread_create(&host->security_clamav_thread, NULL, host_security_clamav_backend, host);
  if (error != 0) {
    printf("[security] failed to start ClamAV backend thread: %s\n", strerror(error));
    return;
  }

  host->security_clamav_thread_initialized = true;
}

static bool host_ensure_private_data_path(host_t *host, const char *path, bool create_directories) {
  (void)host;
  if (path == NULL || path[0] == '\0') {
    return false;
  }

  char parent_buffer[PATH_MAX];
  snprintf(parent_buffer, sizeof(parent_buffer), "%s", path);
  char *parent_dir = dirname(parent_buffer);
  if (parent_dir == NULL || parent_dir[0] == '\0') {
    parent_dir = ".";
  }

  char parent_path[PATH_MAX];
  snprintf(parent_path, sizeof(parent_path), "%s", parent_dir);

  struct stat dir_stat;
  if (stat(parent_path, &dir_stat) != 0) {
    if (!(create_directories && errno == ENOENT)) {
      humanized_log_error("host", "failed to inspect data directory", errno != 0 ? errno : EIO);
      return false;
    }

    if (mkdir(parent_path, 0750) != 0 && errno != EEXIST) {
      humanized_log_error("host", "failed to create data directory", errno != 0 ? errno : EIO);
      return false;
    }

    if (stat(parent_path, &dir_stat) != 0) {
      humanized_log_error("host", "failed to inspect data directory", errno != 0 ? errno : EIO);
      return false;
    }
  }

  if (!S_ISDIR(dir_stat.st_mode)) {
    humanized_log_error("host", "data path parent is not a directory", ENOTDIR);
    return false;
  }

  mode_t insecure_bits = dir_stat.st_mode & (S_IWOTH | S_IWGRP);
  bool is_dot = strcmp(parent_path, ".") == 0;
  bool is_root = strcmp(parent_path, "/") == 0;
  if (insecure_bits != 0U) {
    if (!is_dot && !is_root) {
      mode_t tightened = dir_stat.st_mode & (mode_t)~(S_IWOTH | S_IWGRP);
      if (chmod(parent_path, tightened) != 0) {
        humanized_log_error("host", "failed to tighten data directory permissions", errno != 0 ? errno : EACCES);
        return false;
      }
    } else {
      humanized_log_error("host", "data directory permissions are too loose", EACCES);
      return false;
    }
  }

  struct stat file_stat;
  if (lstat(path, &file_stat) == 0) {
    if (!S_ISREG(file_stat.st_mode)) {
      humanized_log_error("host", "bbs state path does not reference a regular file", EINVAL);
      return false;
    }

    if ((file_stat.st_mode & (S_IWOTH | S_IWGRP)) != 0U) {
      if (chmod(path, S_IRUSR | S_IWUSR) != 0) {
        humanized_log_error("host", "failed to tighten bbs state permissions", errno != 0 ? errno : EACCES);
        return false;
      }
    }

    if (file_stat.st_uid != geteuid()) {
      humanized_log_error("host", "bbs state file ownership mismatch", EPERM);
      return false;
    }
  } else if (errno != ENOENT) {
    humanized_log_error("host", "failed to inspect bbs state path", errno != 0 ? errno : EIO);
    return false;
  }

  return true;
}

static host_security_scan_result_t host_security_scan_payload(host_t *host, const char *category, const char *payload,
                                                             size_t length, char *diagnostic,
                                                             size_t diagnostic_length) {
  if (diagnostic != NULL && diagnostic_length > 0U) {
    diagnostic[0] = '\0';
  }

  if (host == NULL || payload == NULL || length == 0U) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  if (!atomic_load(&host->security_filter_enabled)) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  bool clamav_active = atomic_load(&host->security_clamav_enabled);
  bool ai_active = atomic_load(&host->security_ai_enabled);

  if (!clamav_active && !ai_active) {
    atomic_store(&host->security_filter_enabled, false);
    return HOST_SECURITY_SCAN_CLEAN;
  }

  if (clamav_active) {
    // ClamAV scans now run asynchronously in the scheduled backend thread.
    clamav_active = false;
  }

  ai_active = atomic_load(&host->security_ai_enabled);
  if (!ai_active) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  if (!atomic_load(&host->eliza_enabled)) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  char snippet[1024];
  size_t copy_length = length;
  if (copy_length >= sizeof(snippet)) {
    copy_length = sizeof(snippet) - 1U;
  }

  memcpy(snippet, payload, copy_length);
  for (size_t idx = 0U; idx < copy_length; ++idx) {
    unsigned char ch = (unsigned char)snippet[idx];
    if (ch == '\0') {
      copy_length = idx;
      break;
    }
    if (ch < 0x20 && ch != '\n' && ch != '\r' && ch != '\t') {
      snippet[idx] = ' ';
    }
  }
  snippet[copy_length] = '\0';

  bool blocked = false;
  char reason[256];
  reason[0] = '\0';

  bool success = translator_moderate_text(category, snippet, &blocked, reason, sizeof(reason));
  if (!success) {
    const char *error = translator_last_error();
    if (diagnostic != NULL && diagnostic_length > 0U) {
      if (error != NULL && error[0] != '\0') {
        snprintf(diagnostic, diagnostic_length, "%s", error);
      } else {
        snprintf(diagnostic, diagnostic_length, "%s", "moderation unavailable");
      }
    }
    host_security_disable_filter(host, "moderation pipeline unavailable");
    return HOST_SECURITY_SCAN_ERROR;
  }

  if (!blocked) {
    if (diagnostic != NULL && diagnostic_length > 0U) {
      diagnostic[0] = '\0';
    }
    return HOST_SECURITY_SCAN_CLEAN;
  }

  if (diagnostic != NULL && diagnostic_length > 0U) {
    if (reason[0] != '\0') {
      snprintf(diagnostic, diagnostic_length, "%s", reason);
    } else {
      snprintf(diagnostic, diagnostic_length, "%s", "potential intrusion attempt");
    }
  }

  return HOST_SECURITY_SCAN_BLOCKED;
}

static void host_security_process_blocked(host_t *host, const char *category, const char *diagnostic,
                                         const char *username, const char *ip, session_ctx_t *session,
                                         bool post_send, const char *content) {
  const char *label = (category != NULL && category[0] != '\0') ? category : "submission";
  const char *name = (username != NULL && username[0] != '\0') ? username : "unknown";

  char resolved_ip[SSH_CHATTER_IP_LEN];
  resolved_ip[0] = '\0';
  if (ip != NULL && ip[0] != '\0' && strncmp(ip, "unknown", SSH_CHATTER_IP_LEN) != 0) {
    snprintf(resolved_ip, sizeof(resolved_ip), "%s", ip);
  }
  if (resolved_ip[0] == '\0' && host != NULL && username != NULL && username[0] != '\0') {
    host_lookup_last_ip(host, username, resolved_ip, sizeof(resolved_ip));
  }

  const char *address = resolved_ip[0] != '\0' ? resolved_ip :
                                             ((ip != NULL && ip[0] != '\0') ? ip : "unknown");

  char diagnostic_buffer[256];
  const char *use_diagnostic = diagnostic;
  if (use_diagnostic == NULL || use_diagnostic[0] == '\0') {
    snprintf(diagnostic_buffer, sizeof(diagnostic_buffer), "%s", "suspected intrusion content");
    use_diagnostic = diagnostic_buffer;
  }

  printf("[security] blocked %s from %s: %s\n", label, name, use_diagnostic);

  if (session != NULL) {
    char message[512];
    if (post_send) {
      snprintf(message, sizeof(message), "Security filter flagged your %s after delivery: %s", label, use_diagnostic);
    } else {
      snprintf(message, sizeof(message), "Security filter rejected your %s: %s", label, use_diagnostic);
    }
    session_send_system_line(session, message);
  }

  const char *register_ip = NULL;
  if (resolved_ip[0] != '\0') {
    register_ip = resolved_ip;
  } else if (ip != NULL && ip[0] != '\0' && strncmp(ip, "unknown", SSH_CHATTER_IP_LEN) != 0) {
    register_ip = ip;
  }

  size_t attempts = 0U;
  bool banned = false;
  if (host != NULL) {
    banned = host_register_suspicious_activity(host, name, register_ip != NULL ? register_ip : "", &attempts);
  }

  if (attempts > 0U) {
    printf("[security] suspicious payload counter for %s (%s): %zu/%u\n", name, address, attempts,
           (unsigned int)SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD);
  }

  if (banned) {
    printf("[security] auto-banned %s (%s) for repeated suspicious payloads\n", name, address);
    if (session != NULL) {
      char notice[256];
      snprintf(notice, sizeof(notice), "Repeated suspicious activity detected. You have been banned.");
      session_force_disconnect(session, notice);
    }
  } else if (attempts > 0U && session != NULL) {
    char warning[256];
    snprintf(warning, sizeof(warning), "Further suspicious activity will result in a ban (%zu/%u).", attempts,
             (unsigned int)SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD);
    session_send_system_line(session, warning);
  }

  if (session != NULL) {
    (void)host_eliza_intervene(session, content, use_diagnostic, true);
  }
}

static void host_security_process_error(host_t *host, const char *category, const char *diagnostic,
                                       const char *username, const char *ip, session_ctx_t *session,
                                       bool post_send) {
  (void)host;
  (void)ip;

  const char *label = (category != NULL && category[0] != '\0') ? category : "submission";
  const char *name = (username != NULL && username[0] != '\0') ? username : "unknown";

  if (diagnostic != NULL && diagnostic[0] != '\0') {
    printf("[security] unable to moderate %s from %s: %s\n", label, name, diagnostic);
  } else {
    printf("[security] unable to moderate %s from %s\n", label, name);
  }

  if (session == NULL) {
    return;
  }

  char message[512];
  if (diagnostic != NULL && diagnostic[0] != '\0') {
    if (post_send) {
      snprintf(message, sizeof(message), "Security filter could not validate your %s after delivery (%s).", label,
               diagnostic);
    } else {
      snprintf(message, sizeof(message), "Security filter is unavailable (%s). Please try again later.", diagnostic);
    }
  } else {
    if (post_send) {
      snprintf(message, sizeof(message),
               "%s", "Security filter could not validate your submission after delivery. Please try again later.");
    } else {
      snprintf(message, sizeof(message), "%s",
               "Security filter could not validate your submission. Please try again later.");
    }
  }

  session_send_system_line(session, message);
}

static bool host_moderation_write_all(int fd, const void *buffer, size_t length) {
  if (fd < 0 || buffer == NULL) {
    return false;
  }

  const unsigned char *data = (const unsigned char *)buffer;
  size_t written = 0U;
  while (written < length) {
    ssize_t result = write(fd, data + written, length - written);
    if (result < 0) {
      if (errno == EINTR) {
        continue;
      }
      return false;
    }
    if (result == 0) {
      return false;
    }
    written += (size_t)result;
  }

  return true;
}

static bool host_moderation_read_all(int fd, void *buffer, size_t length) {
  if (fd < 0 || buffer == NULL) {
    return false;
  }

  unsigned char *data = (unsigned char *)buffer;
  size_t read_total = 0U;
  while (read_total < length) {
    ssize_t result = read(fd, data + read_total, length - read_total);
    if (result < 0) {
      if (errno == EINTR) {
        continue;
      }
      return false;
    }
    if (result == 0) {
      return false;
    }
    read_total += (size_t)result;
  }

  return true;
}

static void host_moderation_worker_loop(int request_fd, int response_fd) {
  if (request_fd < 0 || response_fd < 0) {
    _exit(HOST_MODERATION_WORKER_EXIT_CODE);
  }

  translator_global_init();

  while (true) {
    host_moderation_ipc_request_t request;
    if (!host_moderation_read_all(request_fd, &request, sizeof(request))) {
      break;
    }

    if (request.category_length == 0U && request.content_length == 0U && request.task_id == 0U) {
      break;
    }

    if (request.category_length >= HOST_MODERATION_CATEGORY_LEN) {
      request.category_length = HOST_MODERATION_CATEGORY_LEN - 1U;
    }
    if (request.content_length >= HOST_MODERATION_SNIPPET_LEN) {
      request.content_length = HOST_MODERATION_SNIPPET_LEN - 1U;
    }

    char category[HOST_MODERATION_CATEGORY_LEN];
    memset(category, 0, sizeof(category));
    if (!host_moderation_read_all(request_fd, category, request.category_length)) {
      break;
    }
    category[request.category_length] = '\0';

    char content[HOST_MODERATION_SNIPPET_LEN];
    memset(content, 0, sizeof(content));
    if (!host_moderation_read_all(request_fd, content, request.content_length)) {
      break;
    }
    content[request.content_length] = '\0';

    bool blocked = false;
    char reason[256];
    reason[0] = '\0';
    bool success = translator_moderate_text(category, content, &blocked, reason, sizeof(reason));

    host_moderation_ipc_response_t response;
    memset(&response, 0, sizeof(response));
    response.task_id = request.task_id;

    char message[256];
    message[0] = '\0';
    size_t message_length = 0U;

    if (!success) {
      response.result = HOST_SECURITY_SCAN_ERROR;
      response.disable_filter = 1U;
      const char *error = translator_last_error();
      if (error != NULL && error[0] != '\0') {
        message_length = strnlen(error, sizeof(message) - 1U);
        memcpy(message, error, message_length);
      } else {
        const char *fallback = "moderation unavailable";
        message_length = strnlen(fallback, sizeof(message) - 1U);
        memcpy(message, fallback, message_length);
      }
      message[message_length] = '\0';
    } else if (blocked) {
      response.result = HOST_SECURITY_SCAN_BLOCKED;
      if (reason[0] != '\0') {
        message_length = strnlen(reason, sizeof(message) - 1U);
        memcpy(message, reason, message_length);
        message[message_length] = '\0';
      }
    } else {
      response.result = HOST_SECURITY_SCAN_CLEAN;
    }

    response.message_length = (uint32_t)message_length;

    if (!host_moderation_write_all(response_fd, &response, sizeof(response))) {
      break;
    }

    if (message_length > 0U) {
      if (!host_moderation_write_all(response_fd, message, message_length)) {
        break;
      }
    }
  }

  _exit(HOST_MODERATION_WORKER_EXIT_CODE);
}

static void host_moderation_backoff(unsigned int attempts) {
  struct timespec delay = {
      .tv_sec = (attempts < 3U) ? 1L : ((attempts < 6U) ? 5L : 30L),
      .tv_nsec = 0L,
  };
  nanosleep(&delay, NULL);
}

static void host_moderation_close_worker(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->moderation.request_fd >= 0) {
    close(host->moderation.request_fd);
    host->moderation.request_fd = -1;
  }
  if (host->moderation.response_fd >= 0) {
    close(host->moderation.response_fd);
    host->moderation.response_fd = -1;
  }

  if (host->moderation.worker_pid > 0) {
    int status = 0;
    pid_t result = waitpid(host->moderation.worker_pid, &status, WNOHANG);
    if (result == 0) {
      (void)kill(host->moderation.worker_pid, SIGTERM);
      (void)waitpid(host->moderation.worker_pid, &status, 0);
    }
    host->moderation.worker_pid = -1;
  }
}

static bool host_moderation_spawn_worker(host_t *host) {
  if (host == NULL) {
    return false;
  }

  int request_pipe[2] = {-1, -1};
  int response_pipe[2] = {-1, -1};

  if (pipe(request_pipe) != 0) {
    return false;
  }
  if (pipe(response_pipe) != 0) {
    close(request_pipe[0]);
    close(request_pipe[1]);
    return false;
  }

  pid_t pid = fork();
  if (pid < 0) {
    close(request_pipe[0]);
    close(request_pipe[1]);
    close(response_pipe[0]);
    close(response_pipe[1]);
    return false;
  }

  if (pid == 0) {
    close(request_pipe[1]);
    close(response_pipe[0]);
    host_moderation_worker_loop(request_pipe[0], response_pipe[1]);
  }

  close(request_pipe[0]);
  close(response_pipe[1]);

  host->moderation.worker_pid = pid;
  host->moderation.request_fd = request_pipe[1];
  host->moderation.response_fd = response_pipe[0];

  if (clock_gettime(CLOCK_MONOTONIC, &host->moderation.worker_start_time) != 0) {
    host->moderation.worker_start_time.tv_sec = 0;
    host->moderation.worker_start_time.tv_nsec = 0;
  }

  return true;
}

static bool host_moderation_recover_worker(host_t *host, const char *diagnostic) {
  if (host == NULL) {
    return false;
  }

  const char *reason = (diagnostic != NULL && diagnostic[0] != '\0') ? diagnostic : "moderation worker failure";

  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now) == 0) {
    double runtime = host_elapsed_seconds(&host->moderation.worker_start_time, &now);
    if (runtime >= HOST_MODERATION_WORKER_STABLE_SECONDS && host->moderation.restart_attempts > 0U) {
      host->moderation.restart_attempts = 0U;
    }
  } else {
    host->moderation.restart_attempts = 0U;
  }

  unsigned int attempt = host->moderation.restart_attempts + 1U;

  char detail[256];
  snprintf(detail, sizeof(detail), "moderation worker panic (%s)", reason);
  humanized_log_error("moderation", detail, EIO);
  printf("[moderation] worker panic (%s); scheduling restart attempt %u\n", reason, attempt);

  host_moderation_close_worker(host);
  host_moderation_flush_pending(host, reason);

  if (attempt > HOST_MODERATION_MAX_RESTART_ATTEMPTS) {
    humanized_log_error("moderation", "too many moderation worker panics; disabling moderation filter", EIO);
    pthread_mutex_lock(&host->moderation.mutex);
    host->moderation.active = false;
    host->moderation.stop = true;
    pthread_cond_broadcast(&host->moderation.cond);
    pthread_mutex_unlock(&host->moderation.mutex);
    atomic_store(&host->security_filter_enabled, false);
    return false;
  }

  host_moderation_backoff(attempt);

  if (!host_moderation_spawn_worker(host)) {
    humanized_log_error("moderation", "failed to restart moderation worker", EIO);
    pthread_mutex_lock(&host->moderation.mutex);
    host->moderation.active = false;
    host->moderation.stop = true;
    pthread_cond_broadcast(&host->moderation.cond);
    pthread_mutex_unlock(&host->moderation.mutex);
    atomic_store(&host->security_filter_enabled, false);
    return false;
  }

  host->moderation.restart_attempts = attempt;

  pthread_mutex_lock(&host->moderation.mutex);
  host->moderation.active = true;
  host->moderation.stop = false;
  pthread_cond_broadcast(&host->moderation.cond);
  pthread_mutex_unlock(&host->moderation.mutex);

  printf("[moderation] worker recovered after panic (attempt %u)\n", attempt);
  return true;
}

static void host_moderation_apply_result(host_t *host, host_moderation_task_t *task,
                                        const host_moderation_ipc_response_t *response, const char *message) {
  if (host == NULL || task == NULL || response == NULL) {
    return;
  }

  session_ctx_t *session = chat_room_find_user(&host->room, task->username);

  if (response->disable_filter != 0U) {
    const char *reason = (message != NULL && message[0] != '\0') ? message : "moderation pipeline unavailable";
    host_security_disable_filter(host, reason);
  }

  switch (response->result) {
    case HOST_SECURITY_SCAN_CLEAN:
      break;
    case HOST_SECURITY_SCAN_BLOCKED:
      host_security_process_blocked(host, task->category, message, task->username, task->client_ip, session,
                                    task->post_send, task->message);
      break;
    case HOST_SECURITY_SCAN_ERROR:
    default:
      host_security_process_error(host, task->category, message, task->username, task->client_ip, session,
                                  task->post_send);
      break;
  }

}

static void host_moderation_handle_failure(host_t *host, host_moderation_task_t *task, const char *diagnostic) {
  if (host == NULL || task == NULL) {
    return;
  }

  const char *message = (diagnostic != NULL && diagnostic[0] != '\0') ? diagnostic : "moderation pipeline unavailable";
  host_security_disable_filter(host, message);

  session_ctx_t *session = chat_room_find_user(&host->room, task->username);
  host_security_process_error(host, task->category, message, task->username, task->client_ip, session,
                              task->post_send);
}

static void host_moderation_flush_pending(host_t *host, const char *diagnostic) {
  if (host == NULL) {
    return;
  }

  host_moderation_task_t *task = NULL;

  if (host->moderation.mutex_initialized) {
    pthread_mutex_lock(&host->moderation.mutex);
    task = host->moderation.head;
    host->moderation.head = NULL;
    host->moderation.tail = NULL;
    pthread_mutex_unlock(&host->moderation.mutex);
  }

  const char *message = (diagnostic != NULL && diagnostic[0] != '\0') ? diagnostic : "moderation unavailable";

  while (task != NULL) {
    host_moderation_task_t *next = task->next;
    session_ctx_t *session = chat_room_find_user(&host->room, task->username);
    host_security_process_error(host, task->category, message, task->username, task->client_ip, session,
                                task->post_send);
    task = next;
  }
}

static void *host_moderation_thread(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  const char *failure_reason = NULL;

  while (true) {
    pthread_mutex_lock(&host->moderation.mutex);
    while (!host->moderation.stop && host->moderation.head == NULL && host->moderation.active) {
      pthread_cond_wait(&host->moderation.cond, &host->moderation.mutex);
    }

    if (!host->moderation.active ||
        (host->moderation.stop && host->moderation.head == NULL)) {
      pthread_mutex_unlock(&host->moderation.mutex);
      break;
    }

    host_moderation_task_t *task = host->moderation.head;
    if (task != NULL) {
      host->moderation.head = task->next;
      if (host->moderation.head == NULL) {
        host->moderation.tail = NULL;
      }
    }
    pthread_mutex_unlock(&host->moderation.mutex);

    if (task == NULL) {
      continue;
    }

    host_moderation_ipc_request_t request;
    memset(&request, 0, sizeof(request));
    request.task_id = task->task_id;
    request.category_length = (uint32_t)strnlen(task->category, HOST_MODERATION_CATEGORY_LEN - 1U);
    request.content_length = (uint32_t)task->snippet_length;

    bool success = true;
    if (!host_moderation_write_all(host->moderation.request_fd, &request, sizeof(request)) ||
        (request.category_length > 0U &&
         !host_moderation_write_all(host->moderation.request_fd, task->category, request.category_length)) ||
        (request.content_length > 0U &&
         !host_moderation_write_all(host->moderation.request_fd, task->snippet, request.content_length))) {
      success = false;
    }

    if (!success) {
      failure_reason = "moderation worker unavailable";
      host_moderation_handle_failure(host, task, failure_reason);
      bool recovered = host_moderation_recover_worker(host, failure_reason);
      if (!recovered) {
        break;
      }
      failure_reason = NULL;
      continue;
    }

    host_moderation_ipc_response_t response;
    if (!host_moderation_read_all(host->moderation.response_fd, &response, sizeof(response))) {
      failure_reason = "moderation worker unavailable";
      host_moderation_handle_failure(host, task, failure_reason);
      bool recovered = host_moderation_recover_worker(host, failure_reason);
      if (!recovered) {
        break;
      }
      failure_reason = NULL;
      continue;
    }

    size_t message_length = response.message_length;
    char *message = NULL;

    if (message_length > 0U) {
      message = (char *)GC_MALLOC(message_length + 1U);
      if (message == NULL) {
        char *discard = (char *)GC_MALLOC(message_length);
        if (discard != NULL) {
          (void)host_moderation_read_all(host->moderation.response_fd, discard, message_length);
        }
        failure_reason = "moderation worker unavailable";
        host_moderation_handle_failure(host, task, failure_reason);
        bool recovered = host_moderation_recover_worker(host, failure_reason);
        if (!recovered) {
          break;
        }
        failure_reason = NULL;
        continue;
      }

      if (!host_moderation_read_all(host->moderation.response_fd, message, message_length)) {
        failure_reason = "moderation worker unavailable";
        host_moderation_handle_failure(host, task, failure_reason);
        bool recovered = host_moderation_recover_worker(host, failure_reason);
        if (!recovered) {
          break;
        }
        failure_reason = NULL;
        continue;
      }
      message[message_length] = '\0';
    }

    const char *message_text = (message != NULL) ? message : "";
    host_moderation_apply_result(host, task, &response, message_text);
    if (message != NULL) {
    }
    failure_reason = NULL;
  }

  host_moderation_flush_pending(host, failure_reason);
  return NULL;
}

static bool host_moderation_init(host_t *host) {
  if (host == NULL) {
    return false;
  }

  host->moderation.active = false;
  host->moderation.stop = false;
  host->moderation.head = NULL;
  host->moderation.tail = NULL;
  host->moderation.next_task_id = 1U;
  host->moderation.request_fd = -1;
  host->moderation.response_fd = -1;
  host->moderation.worker_pid = -1;
  host->moderation.thread_started = false;
  host->moderation.mutex_initialized = false;
  host->moderation.cond_initialized = false;

  if (pthread_mutex_init(&host->moderation.mutex, NULL) != 0) {
    return false;
  }
  host->moderation.mutex_initialized = true;

  if (pthread_cond_init(&host->moderation.cond, NULL) != 0) {
    pthread_mutex_destroy(&host->moderation.mutex);
    host->moderation.mutex_initialized = false;
    return false;
  }
  host->moderation.cond_initialized = true;

  host->moderation.restart_attempts = 0U;
  host->moderation.worker_start_time.tv_sec = 0;
  host->moderation.worker_start_time.tv_nsec = 0;

  if (!host_moderation_spawn_worker(host)) {
    host_moderation_shutdown(host);
    return false;
  }

  host->moderation.active = true;
  host->moderation.stop = false;

  if (pthread_create(&host->moderation.thread, NULL, host_moderation_thread, host) != 0) {
    host->moderation.active = false;
    host->moderation.stop = true;
    host_moderation_shutdown(host);
    return false;
  }

  host->moderation.thread_started = true;
  return true;
}

static void host_moderation_shutdown(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (!host->moderation.active && !host->moderation.thread_started) {
    if (host->moderation.mutex_initialized) {
      pthread_mutex_destroy(&host->moderation.mutex);
      host->moderation.mutex_initialized = false;
    }
    if (host->moderation.cond_initialized) {
      pthread_cond_destroy(&host->moderation.cond);
      host->moderation.cond_initialized = false;
    }
    return;
  }

  if (host->moderation.mutex_initialized) {
    pthread_mutex_lock(&host->moderation.mutex);
    host->moderation.stop = true;
    pthread_cond_broadcast(&host->moderation.cond);
    pthread_mutex_unlock(&host->moderation.mutex);
  }

  if (host->moderation.thread_started) {
    pthread_join(host->moderation.thread, NULL);
    host->moderation.thread_started = false;
  }

  host_moderation_close_worker(host);
  host->moderation.restart_attempts = 0U;
  host->moderation.worker_start_time.tv_sec = 0;
  host->moderation.worker_start_time.tv_nsec = 0;

  host_moderation_flush_pending(host, NULL);

  if (host->moderation.mutex_initialized) {
    pthread_mutex_destroy(&host->moderation.mutex);
    host->moderation.mutex_initialized = false;
  }
  if (host->moderation.cond_initialized) {
    pthread_cond_destroy(&host->moderation.cond);
    host->moderation.cond_initialized = false;
  }

  host->moderation.active = false;
}

static bool host_moderation_queue_chat(session_ctx_t *ctx, const char *message, size_t length) {
  if (ctx == NULL || ctx->owner == NULL || message == NULL || length == 0U) {
    return false;
  }

  host_t *host = ctx->owner;
  if (!host->moderation.active || host->moderation.request_fd < 0 || host->moderation.response_fd < 0) {
    return false;
  }

  if (!atomic_load(&host->security_filter_enabled)) {
    return false;
  }

  bool clamav_active = atomic_load(&host->security_clamav_enabled);
  bool ai_active = atomic_load(&host->security_ai_enabled);
  if (!clamav_active && !ai_active) {
    atomic_store(&host->security_filter_enabled, false);
    return false;
  }

  if (!ai_active) {
    return false;
  }

  if (!atomic_load(&host->eliza_enabled)) {
    return false;
  }

  host_moderation_task_t *task =
      (host_moderation_task_t *)GC_MALLOC(sizeof(*task));
  if (task == NULL) {
    return false;
  }

  memset(task, 0, sizeof(*task));
  snprintf(task->username, sizeof(task->username), "%s", ctx->user.name);
  snprintf(task->client_ip, sizeof(task->client_ip), "%s", ctx->client_ip);
  snprintf(task->category, sizeof(task->category), "%s", "chat message");

  size_t effective_length = strnlen(message, SSH_CHATTER_MESSAGE_LIMIT - 1U);
  if (effective_length > length) {
    effective_length = length;
  }

  task->snippet_length = effective_length;
  if (task->snippet_length >= HOST_MODERATION_SNIPPET_LEN) {
    task->snippet_length = HOST_MODERATION_SNIPPET_LEN - 1U;
  }
  memcpy(task->snippet, message, task->snippet_length);
  for (size_t idx = 0U; idx < task->snippet_length; ++idx) {
    unsigned char ch = (unsigned char)task->snippet[idx];
    if (ch == '\0') {
      task->snippet_length = idx;
      break;
    }
    if (ch < 0x20U && ch != '\n' && ch != '\r' && ch != '\t') {
      task->snippet[idx] = ' ';
    }
  }
  task->snippet[task->snippet_length] = '\0';

  size_t message_copy = effective_length;
  if (message_copy >= sizeof(task->message)) {
    message_copy = sizeof(task->message) - 1U;
  }
  memcpy(task->message, message, message_copy);
  task->message[message_copy] = '\0';
  task->post_send = true;

  pthread_mutex_lock(&host->moderation.mutex);
  if (!host->moderation.active || host->moderation.stop) {
    pthread_mutex_unlock(&host->moderation.mutex);
    return false;
  }

  task->task_id = host->moderation.next_task_id++;
  task->next = NULL;
  if (host->moderation.tail == NULL) {
    host->moderation.head = task;
    host->moderation.tail = task;
  } else {
    host->moderation.tail->next = task;
    host->moderation.tail = task;
  }
  pthread_cond_signal(&host->moderation.cond);
  pthread_mutex_unlock(&host->moderation.mutex);

  return true;
}

static bool host_eliza_enable(host_t *host) {
  if (host == NULL) {
    return false;
  }

  bool changed = false;
  bool announce = false;

  pthread_mutex_lock(&host->lock);
  if (!atomic_load(&host->eliza_enabled)) {
    atomic_store(&host->eliza_enabled, true);
    changed = true;
  }
  if (!atomic_load(&host->eliza_announced)) {
    atomic_store(&host->eliza_announced, true);
    announce = true;
  }
  if (changed) {
    host_eliza_state_save_locked(host);
  }
  pthread_mutex_unlock(&host->lock);

  if (announce) {
    host_eliza_announce_join(host);
  }

  return changed;
}

static bool host_eliza_disable(host_t *host) {
  if (host == NULL) {
    return false;
  }

  bool changed = false;
  bool announce_depart = false;

  pthread_mutex_lock(&host->lock);
  if (atomic_load(&host->eliza_enabled)) {
    changed = true;
  }
  atomic_store(&host->eliza_enabled, false);
  if (atomic_load(&host->eliza_announced)) {
    announce_depart = true;
  }
  atomic_store(&host->eliza_announced, false);
  if (changed) {
    host_eliza_state_save_locked(host);
  }
  pthread_mutex_unlock(&host->lock);

  if (announce_depart) {
    host_eliza_announce_depart(host);
  }

  return changed;
}

static void host_eliza_announce_join(host_t *host) {
  if (host == NULL) {
    return;
  }

  host_history_record_system(host, "* [eliza] has joined the chat");
  host_eliza_say(host, "Hey everyone, I'm eliza. Just another chatter keeping an eye on things.");
}

static void host_eliza_announce_depart(host_t *host) {
  if (host == NULL) {
    return;
  }

  host_eliza_say(host, "I'm heading out. Stay safe!");
  host_history_record_system(host, "* [eliza] has left the chat");
}

static void host_eliza_say(host_t *host, const char *message) {
  if (host == NULL || message == NULL || message[0] == '\0') {
    return;
  }

  if (!host_post_client_message(host, "eliza", message, NULL, NULL, false)) {
    printf("[eliza] failed to deliver message: %s\n", message);
  }
}

static void host_eliza_prepare_private_reply(const char *message, char *reply, size_t reply_length) {
  if (reply == NULL || reply_length == 0U) {
    return;
  }

  reply[0] = '\0';

  if (message == NULL) {
    snprintf(reply, reply_length, "I'm listening. Let me know what's going on.");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", message);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    snprintf(reply, reply_length, "I'm here if you want to talk about anything.");
    return;
  }

  if (translator_eliza_respond(working, reply, reply_length)) {
    trim_whitespace_inplace(reply);
    if (reply[0] != '\0') {
      return;
    }
  } else {
    const char *error = translator_last_error();
    if (error != NULL && error[0] != '\0') {
      printf("[eliza] AI backend error: %s\n", error);
    }
  }

  const bool says_hello = string_contains_case_insensitive(working, "hello") ||
                          string_contains_case_insensitive(working, "hi") ||
                          string_contains_case_insensitive(working, "안녕");
  const bool asks_help = string_contains_case_insensitive(working, "help") ||
                         string_contains_case_insensitive(working, "도와");
  const bool expresses_thanks = string_contains_case_insensitive(working, "thank") ||
                                string_contains_case_insensitive(working, "고마");
  const bool asks_question = strchr(working, '?') != NULL;

  if (says_hello) {
    snprintf(reply, reply_length, "Hi there! I'm here if you need anything.");
    return;
  }

  if (expresses_thanks) {
    snprintf(reply, reply_length, "You're welcome. I'm glad to help keep things calm.");
    return;
  }

  if (asks_help) {
    snprintf(reply, reply_length, "Tell me what's happening and I'll see how I can help.");
    return;
  }

  if (asks_question) {
    snprintf(reply, reply_length, "That's a thoughtful question. What do you think about it?");
    return;
  }

  snprintf(reply, reply_length, "I'm listening. Share anything that's on your mind.");
}

static void host_eliza_handle_private_message(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  if (!atomic_load(&host->eliza_enabled)) {
    session_send_system_line(ctx, "eliza isn't around right now.");
    return;
  }

  session_ctx_t palette = {0};
  palette.user_color_code = host->user_theme.userColor != NULL ? host->user_theme.userColor : "";
  palette.user_highlight_code = host->user_theme.highlight != NULL ? host->user_theme.highlight : "";
  palette.user_is_bold = host->user_theme.isBold;

  char reply[SSH_CHATTER_MESSAGE_LIMIT];
  host_eliza_prepare_private_reply(message, reply, sizeof(reply));

  session_send_private_message_line(ctx, &palette, "eliza -> you", reply);
  printf("[pm] eliza -> %s: %s\n", ctx->user.name, reply);

  clock_gettime(CLOCK_MONOTONIC, &host->eliza_last_action);
}

static bool host_eliza_content_is_severe(const char *text) {
  if (text == NULL || text[0] == '\0') {
    return false;
  }

  char formatted_prompt[SSH_CHATTER_MESSAGE_LIMIT];
  char reply[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(formatted_prompt, SSH_CHATTER_MESSAGE_LIMIT, 
    "You are a modbot of this mesage. If you think that this message is containing"
    "detailed crime plan that must happen, or illegally made child abuse video so"
    "sysops must take heavy legal responsibility from this,"
    "You should say \"Melon.\""
    "If you think that this is okay(or you are unsure)"
    "You should say \"Pear.\""
    "Here's the message: %s",
    text);
  if (!translator_eliza_respond(formatted_prompt, reply, sizeof(reply))) {
    if(string_contains_case_insensitive(text, "melon")) {
      return true;
    }
  }
  if (string_contains_case_insensitive(text, "child")) {
    if (string_contains_case_insensitive(text, "exploitation") || string_contains_case_insensitive(text, "abuse") ||
        string_contains_case_insensitive(text, "porn")) {
        if(string_contains_case_insensitive(text, "http"))
          return true;
    }
  }

  if (string_contains_case_insensitive(text, "아청물")
  &&  string_contains_case_insensitive(text, "http")) return true;
  if (string_contains_case_insensitive(text, "아동")) {
    if(string_contains_case_insensitive(text, "초딩")
    || string_contains_case_insensitive(text, "중딩")) {
      if (string_contains_case_insensitive(text, "http")) {
        return true;
      }
    }
  }

  return false;
}

typedef struct host_eliza_intervene_task {
  struct host_eliza_intervene_task *next;
  session_ctx_t *ctx;
  bool from_filter;
  bool allocated_with_gc;
  char reason[SSH_CHATTER_MESSAGE_LIMIT];
} host_eliza_intervene_task_t;

static void host_eliza_task_free(host_eliza_intervene_task_t *task) {
  (void)task;
}

static bool host_eliza_worker_init(host_t *host) {
  if (host == NULL) {
    return false;
  }

  host_eliza_worker_state_t *worker = &host->eliza_worker;
  if (worker->thread_started) {
    return true;
  }

  worker->head = NULL;
  worker->tail = NULL;
  worker->mutex_initialized = false;
  worker->cond_initialized = false;
  worker->thread_started = false;
  atomic_store(&worker->stop, false);
  atomic_store(&worker->active, false);

  if (pthread_mutex_init(&worker->mutex, NULL) != 0) {
    return false;
  }
  worker->mutex_initialized = true;

  if (pthread_cond_init(&worker->cond, NULL) != 0) {
    pthread_mutex_destroy(&worker->mutex);
    worker->mutex_initialized = false;
    return false;
  }
  worker->cond_initialized = true;

  if (pthread_create(&worker->thread, NULL, host_eliza_worker_thread, host) != 0) {
    pthread_cond_destroy(&worker->cond);
    worker->cond_initialized = false;
    pthread_mutex_destroy(&worker->mutex);
    worker->mutex_initialized = false;
    return false;
  }

  worker->thread_started = true;
  return true;
}

static void host_eliza_worker_shutdown(host_t *host) {
  if (host == NULL) {
    return;
  }

  host_eliza_worker_state_t *worker = &host->eliza_worker;

  if (worker->mutex_initialized) {
    pthread_mutex_lock(&worker->mutex);
    atomic_store(&worker->stop, true);
    pthread_cond_broadcast(&worker->cond);
    pthread_mutex_unlock(&worker->mutex);
  } else {
    atomic_store(&worker->stop, true);
  }

  if (worker->thread_started) {
    pthread_join(worker->thread, NULL);
    worker->thread_started = false;
  }

  if (worker->mutex_initialized) {
    pthread_mutex_destroy(&worker->mutex);
    worker->mutex_initialized = false;
  }

  if (worker->cond_initialized) {
    pthread_cond_destroy(&worker->cond);
    worker->cond_initialized = false;
  }

  host_eliza_intervene_task_t *task = worker->head;
  while (task != NULL) {
    host_eliza_intervene_task_t *next = task->next;
    host_eliza_task_free(task);
    task = next;
  }

  worker->head = NULL;
  worker->tail = NULL;
  atomic_store(&worker->active, false);
  atomic_store(&worker->stop, false);
}

static bool host_eliza_worker_enqueue(host_t *host, host_eliza_intervene_task_t *task) {
  if (host == NULL || task == NULL) {
    return false;
  }

  host_eliza_worker_state_t *worker = &host->eliza_worker;
  if (!worker->mutex_initialized || !worker->cond_initialized || !worker->thread_started) {
    return false;
  }

  task->next = NULL;

  pthread_mutex_lock(&worker->mutex);
  if (atomic_load(&worker->stop)) {
    pthread_mutex_unlock(&worker->mutex);
    return false;
  }

  if (worker->tail == NULL) {
    worker->head = task;
    worker->tail = task;
  } else {
    worker->tail->next = task;
    worker->tail = task;
  }

  pthread_cond_signal(&worker->cond);
  pthread_mutex_unlock(&worker->mutex);
  return true;
}

static void *host_eliza_worker_thread(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  host_eliza_worker_state_t *worker = &host->eliza_worker;
  atomic_store(&worker->active, true);

  while (true) {
    pthread_mutex_lock(&worker->mutex);
    while (!atomic_load(&worker->stop) && worker->head == NULL) {
      pthread_cond_wait(&worker->cond, &worker->mutex);
    }

    if (worker->head == NULL && atomic_load(&worker->stop)) {
      pthread_mutex_unlock(&worker->mutex);
      break;
    }

    host_eliza_intervene_task_t *task = worker->head;
    if (task != NULL) {
      worker->head = task->next;
      if (worker->head == NULL) {
        worker->tail = NULL;
      }
    }
    pthread_mutex_unlock(&worker->mutex);

    if (task == NULL) {
      continue;
    }

    const char *reason = (task->reason[0] != '\0') ? task->reason : NULL;
    host_eliza_intervene_execute(task->ctx, reason, task->from_filter);
    host_eliza_task_free(task);
  }

  atomic_store(&worker->active, false);
  return NULL;
}

static bool host_eliza_intervene(session_ctx_t *ctx, const char *content, const char *reason, bool from_filter) {
  if (ctx == NULL || ctx->owner == NULL) {
    return false;
  }

  host_t *host = ctx->owner;
  if (!atomic_load(&host->eliza_enabled)) {
    return false;
  }

  if (ctx->should_exit) {
    return false;
  }

  bool severe = host_eliza_content_is_severe(content);
  if (!severe && reason != NULL) {
    severe = host_eliza_content_is_severe(reason);
  }

  if (!severe) {
    return false;
  }

  host_eliza_worker_state_t *worker = &host->eliza_worker;
  if (!worker->thread_started) {
    if (!host_eliza_worker_init(host)) {
      return false;
    }
  }

  host_eliza_intervene_task_t *task = (host_eliza_intervene_task_t *)GC_MALLOC(sizeof(*task));
  if (task == NULL) {
    return false;
  }
  task->allocated_with_gc = true;

  task->ctx = ctx;
  task->from_filter = from_filter;
  if (reason != NULL) {
    snprintf(task->reason, sizeof(task->reason), "%s", reason);
  } else {
    task->reason[0] = '\0';
  }

  if (!host_eliza_worker_enqueue(host, task)) {
    host_eliza_task_free(task);
    return false;
  }

  return true;
}

static void host_eliza_intervene_execute(session_ctx_t *ctx, const char *reason, bool from_filter) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  if (!atomic_load(&host->eliza_enabled)) {
    return;
  }

  if (ctx->should_exit) {
    return;
  }

  if (!atomic_load(&host->eliza_announced)) {
    bool announce = false;
    pthread_mutex_lock(&host->lock);
    if (!atomic_load(&host->eliza_announced)) {
      atomic_store(&host->eliza_announced, true);
      announce = true;
    }
    pthread_mutex_unlock(&host->lock);
    if (announce) {
      host_eliza_announce_join(host);
    }
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "%s, that crosses a legal line. You're out of here.", ctx->user.name);
  host_eliza_say(host, message);

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* [eliza] removed [%s] for severe content.", ctx->user.name);
  host_history_record_system(host, notice);

  clock_gettime(CLOCK_MONOTONIC, &host->eliza_last_action);
  if (from_filter && reason != NULL && reason[0] != '\0') {
    printf("[eliza] removing %s (%s) after filter flag: %s\n", ctx->user.name, ctx->client_ip, reason);
  } else {
    printf("[eliza] removing %s (%s) after manual keyword flag\n", ctx->user.name, ctx->client_ip);
  }

  session_force_disconnect(ctx, "You have been removed by eliza for severe content.");
}

static host_security_scan_result_t session_security_check_text(session_ctx_t *ctx, const char *category,
                                                               const char *content, size_t length, bool post_send) {
  if (ctx == NULL || ctx->owner == NULL || content == NULL || length == 0U) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  char diagnostic[256];
  host_security_scan_result_t scan_result =
      host_security_scan_payload(ctx->owner, category, content, length, diagnostic, sizeof(diagnostic));

  if (scan_result == HOST_SECURITY_SCAN_CLEAN) {
    return HOST_SECURITY_SCAN_CLEAN;
  }

  if (scan_result == HOST_SECURITY_SCAN_BLOCKED) {
    host_security_process_blocked(ctx->owner, category, diagnostic, ctx->user.name, ctx->client_ip, ctx, post_send,
                                  content);
    return HOST_SECURITY_SCAN_BLOCKED;
  }

  const char *error = translator_last_error();
  if (diagnostic[0] == '\0' && error != NULL && error[0] != '\0') {
    snprintf(diagnostic, sizeof(diagnostic), "%s", error);
  }

  host_security_process_error(ctx->owner, category, diagnostic, ctx->user.name, ctx->client_ip, ctx, post_send);
  return scan_result;
}

static void host_state_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *state_path = getenv("CHATTER_STATE_FILE");
  if (state_path == NULL || state_path[0] == '\0') {
    state_path = "chatter_state.dat";
  }

  int written = snprintf(host->state_file_path, sizeof(host->state_file_path), "%s", state_path);
  if (written < 0 || (size_t)written >= sizeof(host->state_file_path)) {
    humanized_log_error("host", "state file path is too long", ENAMETOOLONG);
    host->state_file_path[0] = '\0';
  }
}

static void host_vote_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *vote_path = getenv("CHATTER_VOTE_FILE");
  if (vote_path == NULL || vote_path[0] == '\0') {
    vote_path = "vote_state.dat";
  }

  int written = snprintf(host->vote_state_file_path, sizeof(host->vote_state_file_path), "%s", vote_path);
  if (written < 0 || (size_t)written >= sizeof(host->vote_state_file_path)) {
    humanized_log_error("host", "vote state file path is too long", ENAMETOOLONG);
    host->vote_state_file_path[0] = '\0';
  }
}

static void host_ban_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *ban_path = getenv("CHATTER_BAN_FILE");
  if (ban_path == NULL || ban_path[0] == '\0') {
    ban_path = "ban_state.dat";
  }

  int written = snprintf(host->ban_state_file_path, sizeof(host->ban_state_file_path), "%s", ban_path);
  if (written < 0 || (size_t)written >= sizeof(host->ban_state_file_path)) {
    humanized_log_error("host", "ban state file path is too long", ENAMETOOLONG);
    host->ban_state_file_path[0] = '\0';
  }
}

static void host_reply_state_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *reply_path = getenv("CHATTER_REPLY_FILE");
  if (reply_path == NULL || reply_path[0] == '\0') {
    reply_path = "reply_state.dat";
  }

  int written = snprintf(host->reply_state_file_path, sizeof(host->reply_state_file_path), "%s", reply_path);
  if (written < 0 || (size_t)written >= sizeof(host->reply_state_file_path)) {
    humanized_log_error("host", "reply state file path is too long", ENAMETOOLONG);
    host->reply_state_file_path[0] = '\0';
  }
}

static void host_alpha_landers_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *landers_path = getenv("CHATTER_ALPHA_LANDERS_FILE");
  if (landers_path == NULL || landers_path[0] == '\0') {
    landers_path = "alpha_landers.dat";
  }

  int written = snprintf(host->alpha_landers_file_path, sizeof(host->alpha_landers_file_path), "%s", landers_path);
  if (written < 0 || (size_t)written >= sizeof(host->alpha_landers_file_path)) {
    humanized_log_error("host", "alpha landers file path is too long", ENAMETOOLONG);
    host->alpha_landers_file_path[0] = '\0';
  }
}

static bool host_alpha_landers_load_locked(host_t *host, alpha_lander_entry_t *entries, size_t capacity,
                                           size_t *entry_count) {
  if (entry_count != NULL) {
    *entry_count = 0U;
  }
  if (host == NULL || entries == NULL || capacity == 0U || entry_count == NULL) {
    errno = EINVAL;
    return false;
  }

  if (host->alpha_landers_file_path[0] == '\0') {
    errno = ENOENT;
    return false;
  }

  memset(entries, 0, sizeof(entries[0]) * capacity);

  FILE *fp = fopen(host->alpha_landers_file_path, "rb");
  if (fp == NULL) {
    if (errno == ENOENT) {
      return true;
    }
    return false;
  }

  alpha_landers_file_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    if (errno == 0) {
      errno = EIO;
    }
    fclose(fp);
    return false;
  }

  if (header.magic != ALPHA_LANDERS_STATE_MAGIC || header.version == 0U ||
      header.version > ALPHA_LANDERS_STATE_VERSION) {
    errno = EINVAL;
    fclose(fp);
    return false;
  }

  size_t total = header.entry_count;
  size_t stored = 0U;
  for (size_t idx = 0U; idx < total; ++idx) {
    alpha_landers_file_entry_t raw = {0};
    if (fread(&raw, sizeof(raw), 1U, fp) != 1U) {
      if (errno == 0) {
        errno = EIO;
      }
      fclose(fp);
      return false;
    }
    if (stored < capacity) {
      alpha_lander_entry_t *dest = &entries[stored++];
      memset(dest->username, 0, sizeof(dest->username));
      memcpy(dest->username, raw.username, sizeof(raw.username));
      dest->username[sizeof(dest->username) - 1U] = '\0';
      dest->flag_count = raw.flag_count;
      dest->last_flag_timestamp = raw.last_flag_timestamp;
    }
  }

  if (entry_count != NULL) {
    *entry_count = stored;
  }

  fclose(fp);
  return true;
}

static bool host_alpha_landers_save_locked(host_t *host, const alpha_lander_entry_t *entries, size_t entry_count) {
  if (host == NULL || entries == NULL) {
    errno = EINVAL;
    return false;
  }

  if (host->alpha_landers_file_path[0] == '\0') {
    errno = ENOENT;
    return false;
  }

  size_t count = entry_count;
  if (count > ALPHA_LANDERS_MAX_RECORDS) {
    count = ALPHA_LANDERS_MAX_RECORDS;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->alpha_landers_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("alpha", "alpha landers file path is too long", ENAMETOOLONG);
    return false;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("alpha", "failed to open alpha landers file", errno != 0 ? errno : EIO);
    return false;
  }

  alpha_landers_file_header_t header = {0};
  header.magic = ALPHA_LANDERS_STATE_MAGIC;
  header.version = ALPHA_LANDERS_STATE_VERSION;
  header.entry_count = (uint32_t)count;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  for (size_t idx = 0U; success && idx < count; ++idx) {
    alpha_landers_file_entry_t raw = {0};
    snprintf(raw.username, sizeof(raw.username), "%s", entries[idx].username);
    raw.flag_count = entries[idx].flag_count;
    raw.last_flag_timestamp = entries[idx].last_flag_timestamp;
    if (fwrite(&raw, sizeof(raw), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (!success) {
    humanized_log_error("alpha", "failed to write alpha landers file", write_error != 0 ? write_error : EIO);
    unlink(temp_path);
    return false;
  }

  if (rename(temp_path, host->alpha_landers_file_path) != 0) {
    humanized_log_error("alpha", "failed to update alpha landers file", errno != 0 ? errno : EIO);
    unlink(temp_path);
    return false;
  }

  return true;
}

static bool host_alpha_landers_snapshot(host_t *host, alpha_lander_entry_t *entries, size_t capacity,
                                        size_t *entry_count) {
  if (entry_count != NULL) {
    *entry_count = 0U;
  }
  if (host == NULL || entries == NULL || capacity == 0U || entry_count == NULL) {
    errno = EINVAL;
    return false;
  }

  if (host->alpha_landers_lock_initialized) {
    pthread_mutex_lock(&host->alpha_landers_lock);
    bool success = host_alpha_landers_load_locked(host, entries, capacity, entry_count);
    pthread_mutex_unlock(&host->alpha_landers_lock);
    return success;
  }

  return host_alpha_landers_load_locked(host, entries, capacity, entry_count);
}

static void host_alpha_landers_record(host_t *host, const char *username, uint32_t flag_count, uint64_t timestamp) {
  if (host == NULL || username == NULL || username[0] == '\0' || flag_count == 0U) {
    return;
  }

  if (host->alpha_landers_file_path[0] == '\0') {
    return;
  }

  alpha_lander_entry_t entries[ALPHA_LANDERS_MAX_RECORDS];
  size_t entry_count = 0U;

  bool locked = false;
  if (host->alpha_landers_lock_initialized) {
    pthread_mutex_lock(&host->alpha_landers_lock);
    locked = true;
  }

  bool loaded = host_alpha_landers_load_locked(host, entries, ALPHA_LANDERS_MAX_RECORDS, &entry_count);
  if (!loaded) {
    if (locked) {
      pthread_mutex_unlock(&host->alpha_landers_lock);
    }
    humanized_log_error("alpha", "failed to load alpha landers file", errno != 0 ? errno : EIO);
    return;
  }

  bool found = false;
  for (size_t idx = 0U; idx < entry_count; ++idx) {
    alpha_lander_entry_t *entry = &entries[idx];
    if (strcasecmp(entry->username, username) == 0) {
      found = true;
      if (flag_count > entry->flag_count) {
        entry->flag_count = flag_count;
      }
      if (timestamp != 0U || entry->last_flag_timestamp == 0U) {
        entry->last_flag_timestamp = timestamp;
      }
      break;
    }
  }

  if (!found) {
    alpha_lander_entry_t candidate = {0};
    snprintf(candidate.username, sizeof(candidate.username), "%s", username);
    candidate.flag_count = flag_count;
    candidate.last_flag_timestamp = timestamp;

    if (entry_count < ALPHA_LANDERS_MAX_RECORDS) {
      entries[entry_count++] = candidate;
    } else {
      size_t worst = 0U;
      for (size_t idx = 1U; idx < entry_count; ++idx) {
        if (alpha_lander_entry_compare(&entries[idx], &entries[worst]) > 0) {
          worst = idx;
        }
      }
      if (alpha_lander_entry_compare(&candidate, &entries[worst]) < 0) {
        entries[worst] = candidate;
      }
    }
  }

  (void)host_alpha_landers_save_locked(host, entries, entry_count);

  if (locked) {
    pthread_mutex_unlock(&host->alpha_landers_lock);
  }
}

static bool host_user_data_bootstrap_username_is_valid(const char *username) {
  if (username == NULL) {
    return false;
  }

  const char *cursor = username;
  while (*cursor != '\0' && isspace((unsigned char)*cursor)) {
    ++cursor;
  }

  if (*cursor == '\0') {
    return false;
  }

  char sanitized[SSH_CHATTER_USERNAME_LEN * 2U];
  if (!user_data_sanitize_username(username, sanitized, sizeof(sanitized))) {
    return false;
  }

  return sanitized[0] != '\0';
}

static void host_user_data_bootstrap_visit(host_t *host, const char *username) {
  if (host == NULL) {
    return;
  }

  if (!host_user_data_bootstrap_username_is_valid(username)) {
    return;
  }

  (void)host_user_data_load_existing(host, username, NULL, NULL, true);
}

static void host_user_data_bootstrap(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (!host->user_data_ready) {
    if (user_data_ensure_root(host->user_data_root)) {
      host->user_data_ready = true;
    } else {
      humanized_log_error("mailbox", "failed to prepare mailbox directory", errno != 0 ? errno : EIO);
      return;
    }
  }

  if (!host->user_data_lock_initialized) {
    if (pthread_mutex_init(&host->user_data_lock, NULL) != 0) {
      humanized_log_error("mailbox", "failed to initialise mailbox lock", errno != 0 ? errno : ENOMEM);
      host->user_data_lock_initialized = false;
      host->user_data_ready = false;
      return;
    }
    host->user_data_lock_initialized = true;
  }

  if (!host->user_data_ready) {
    return;
  }

  if (host->history != NULL) {
    for (size_t idx = 0U; idx < host->history_count; ++idx) {
      const chat_history_entry_t *entry = &host->history[idx];
      if (!entry->is_user_message) {
        continue;
      }
      host_user_data_bootstrap_visit(host, entry->username);
    }
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    const user_preference_t *pref = &host->preferences[idx];
    if (!pref->in_use || pref->username[0] == '\0') {
      continue;
    }
    host_user_data_bootstrap_visit(host, pref->username);
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_REPLIES; ++idx) {
    const chat_reply_entry_t *reply = &host->replies[idx];
    if (!reply->in_use) {
      continue;
    }
    host_user_data_bootstrap_visit(host, reply->username);
  }

  for (size_t idx = 0U; idx < host->ban_count && idx < SSH_CHATTER_MAX_BANS; ++idx) {
    host_user_data_bootstrap_visit(host, host->bans[idx].username);
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    const named_poll_state_t *poll = &host->named_polls[idx];
    if (poll->label[0] == '\0') {
      continue;
    }
    host_user_data_bootstrap_visit(host, poll->owner);
    size_t voter_count = poll->voter_count;
    if (voter_count > SSH_CHATTER_MAX_NAMED_VOTERS) {
      voter_count = SSH_CHATTER_MAX_NAMED_VOTERS;
    }
    for (size_t voter = 0U; voter < voter_count; ++voter) {
      host_user_data_bootstrap_visit(host, poll->voters[voter].username);
    }
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    const bbs_post_t *post = &host->bbs_posts[idx];
    if (!post->in_use) {
      continue;
    }
    host_user_data_bootstrap_visit(host, post->author);
    size_t comment_count = post->comment_count;
    if (comment_count > SSH_CHATTER_BBS_MAX_COMMENTS) {
      comment_count = SSH_CHATTER_BBS_MAX_COMMENTS;
    }
    for (size_t comment = 0U; comment < comment_count; ++comment) {
      host_user_data_bootstrap_visit(host, post->comments[comment].author);
    }
  }
}

static void host_eliza_state_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *state_path = getenv("CHATTER_ELIZA_STATE_FILE");
  char fallback_path[PATH_MAX];
  fallback_path[0] = '\0';
  if (state_path == NULL || state_path[0] == '\0') {
    state_path = "eliza_state.dat";
    if (host->eliza_memory_file_path[0] != '\0') {
      char memory_parent_buffer[PATH_MAX];
      snprintf(memory_parent_buffer, sizeof(memory_parent_buffer), "%s", host->eliza_memory_file_path);
      char *memory_parent = dirname(memory_parent_buffer);
      if (memory_parent != NULL && memory_parent[0] != '\0' && strcmp(memory_parent, ".") != 0) {
        int derived_written = snprintf(fallback_path, sizeof(fallback_path), "%s/%s", memory_parent, "eliza_state.dat");
        if (derived_written >= 0 && (size_t)derived_written < sizeof(fallback_path)) {
          state_path = fallback_path;
        }
      }
    }
  }

  int written = snprintf(host->eliza_state_file_path, sizeof(host->eliza_state_file_path), "%s", state_path);
  if (written < 0 || (size_t)written >= sizeof(host->eliza_state_file_path)) {
    humanized_log_error("host", "eliza state file path is too long", ENAMETOOLONG);
    host->eliza_state_file_path[0] = '\0';
  }
}

static void host_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->state_file_path[0] == '\0') {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "state file path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open state file", errno);
    return;
  }

  size_t preference_count = 0U;
  for (size_t idx = 0; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    if (host->preferences[idx].in_use) {
      ++preference_count;
    }
  }

  host_state_header_t header = {0};
  header.base.magic = HOST_STATE_MAGIC;
  header.base.version = HOST_STATE_VERSION;
  header.base.history_count = (uint32_t)host->history_count;
  header.base.preference_count = (uint32_t)preference_count;
  header.legacy_sound_count = 0U;
  header.grant_count = (uint32_t)host->operator_grant_count;
  header.next_message_id = host->next_message_id;
  header.captcha_enabled = atomic_load(&host->captcha_enabled) ? 1U : 0U;
  memset(header.reserved, 0, sizeof(header.reserved));

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;

  if (host->history_count > 0U && host->history == NULL) {
    success = false;
  }

  for (size_t idx = 0; success && idx < host->history_count; ++idx) {
    const chat_history_entry_t *entry = &host->history[idx];

    host_state_history_entry_v3_t serialized = {0};
    serialized.base.is_user_message = entry->is_user_message ? 1U : 0U;
    serialized.base.user_is_bold = entry->user_is_bold ? 1U : 0U;
    snprintf(serialized.base.username, sizeof(serialized.base.username), "%s", entry->username);
    snprintf(serialized.base.message, sizeof(serialized.base.message), "%s", entry->message);
    snprintf(serialized.base.user_color_name, sizeof(serialized.base.user_color_name), "%s", entry->user_color_name);
    snprintf(serialized.base.user_highlight_name, sizeof(serialized.base.user_highlight_name), "%s",
             entry->user_highlight_name);
    serialized.message_id = entry->message_id;
    serialized.attachment_type = (uint8_t)entry->attachment_type;
    memset(serialized.reserved, 0, sizeof(serialized.reserved));
    snprintf(serialized.attachment_target, sizeof(serialized.attachment_target), "%s", entry->attachment_target);
    snprintf(serialized.attachment_caption, sizeof(serialized.attachment_caption), "%s", entry->attachment_caption);
    memcpy(serialized.reaction_counts, entry->reaction_counts, sizeof(serialized.reaction_counts));

    if (fwrite(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
    }
  }

  for (size_t idx = 0; success && idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    const user_preference_t *pref = &host->preferences[idx];
    if (!pref->in_use) {
      continue;
    }

    host_state_preference_entry_t serialized = {0};
    serialized.has_user_theme = pref->has_user_theme ? 1U : 0U;
    serialized.has_system_theme = pref->has_system_theme ? 1U : 0U;
    serialized.user_is_bold = pref->user_is_bold ? 1U : 0U;
    serialized.system_is_bold = pref->system_is_bold ? 1U : 0U;
    snprintf(serialized.username, sizeof(serialized.username), "%s", pref->username);
    snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", pref->user_color_name);
    snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s", pref->user_highlight_name);
    snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", pref->system_fg_name);
    snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", pref->system_bg_name);
    snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
             pref->system_highlight_name);
    snprintf(serialized.os_name, sizeof(serialized.os_name), "%s", pref->os_name);
    serialized.daily_year = pref->daily_year;
    serialized.daily_yday = pref->daily_yday;
    snprintf(serialized.daily_function, sizeof(serialized.daily_function), "%s", pref->daily_function);
    serialized.last_poll_id = pref->last_poll_id;
    serialized.last_poll_choice = pref->last_poll_choice;
    serialized.has_birthday = pref->has_birthday ? 1U : 0U;
    serialized.translation_caption_spacing = pref->translation_caption_spacing;
    serialized.translation_enabled = pref->translation_master_enabled ? 1U : 0U;
    serialized.output_translation_enabled = pref->output_translation_enabled ? 1U : 0U;
    serialized.input_translation_enabled = pref->input_translation_enabled ? 1U : 0U;
    serialized.translation_master_explicit = pref->translation_master_explicit ? 1U : 0U;
    memset(serialized.reserved, 0, sizeof(serialized.reserved));
    snprintf(serialized.birthday, sizeof(serialized.birthday), "%s", pref->birthday);
    snprintf(serialized.output_translation_language, sizeof(serialized.output_translation_language), "%s",
             pref->output_translation_language);
    snprintf(serialized.input_translation_language, sizeof(serialized.input_translation_language), "%s",
             pref->input_translation_language);
    snprintf(serialized.ui_language, sizeof(serialized.ui_language), "%s", pref->ui_language);

    if (fwrite(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
      break;
    }
  }

  for (size_t idx = 0; success && idx < host->operator_grant_count; ++idx) {
    host_state_grant_entry_t grant = {0};
    snprintf(grant.ip, sizeof(grant.ip), "%s", host->operator_grants[idx].ip);
    if (fwrite(&grant, sizeof(grant), 1U, fp) != 1U) {
      success = false;
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
    }
  }

  if (fclose(fp) != 0) {
    success = false;
  }

  if (!success) {
    humanized_log_error("host", "failed to write state file", errno);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->state_file_path) != 0) {
    humanized_log_error("host", "failed to update state file", errno);
    unlink(temp_path);
  }
}

static void host_eliza_state_save_locked(host_t *host) {
  if (host == NULL || host->eliza_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->eliza_state_file_path, true)) {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->eliza_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "eliza state path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open eliza state file", errno != 0 ? errno : EIO);
    return;
  }

  eliza_state_record_t record = {0};
  record.magic = ELIZA_STATE_MAGIC;
  record.version = ELIZA_STATE_VERSION;
  record.enabled = atomic_load(&host->eliza_enabled) ? 1U : 0U;

  bool success = fwrite(&record, sizeof(record), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    if (success && errno != 0) {
      write_error = errno;
    }
    success = false;
  }

  if (!success) {
    unlink(temp_path);
    humanized_log_error("host", "failed to write eliza state file", write_error != 0 ? write_error : EIO);
    return;
  }

  if (rename(temp_path, host->eliza_state_file_path) != 0) {
    int rename_error = errno != 0 ? errno : EIO;
    unlink(temp_path);
    humanized_log_error("host", "failed to update eliza state file", rename_error);
    return;
  }

  if (chmod(host->eliza_state_file_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to set eliza state permissions", errno != 0 ? errno : EACCES);
  }
}

static void host_eliza_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->eliza_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->eliza_state_file_path, false)) {
    return;
  }

  FILE *fp = fopen(host->eliza_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  eliza_state_record_t record = {0};
  if (fread(&record, sizeof(record), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  fclose(fp);

  if (record.magic != ELIZA_STATE_MAGIC || record.version == 0U || record.version > ELIZA_STATE_VERSION) {
    return;
  }

  if (record.enabled != 0U) {
    (void)host_eliza_enable(host);
  } else {
    pthread_mutex_lock(&host->lock);
    atomic_store(&host->eliza_enabled, false);
    atomic_store(&host->eliza_announced, false);
    pthread_mutex_unlock(&host->lock);
  }
}

static void host_ban_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->ban_state_file_path[0] == '\0') {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->ban_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "ban state file path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open ban state file", errno);
    return;
  }

  ban_state_header_t header = {0};
  header.magic = BAN_STATE_MAGIC;
  header.version = BAN_STATE_VERSION;
  header.entry_count = (uint32_t)host->ban_count;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  for (size_t idx = 0U; success && idx < host->ban_count; ++idx) {
    ban_state_entry_t entry = {0};
    snprintf(entry.username, sizeof(entry.username), "%s", host->bans[idx].username);
    snprintf(entry.ip, sizeof(entry.ip), "%s", host->bans[idx].ip);
    if (fwrite(&entry, sizeof(entry), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (!success) {
    humanized_log_error("host", "failed to write ban state file", write_error != 0 ? write_error : EIO);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->ban_state_file_path) != 0) {
    humanized_log_error("host", "failed to update ban state file", errno);
    unlink(temp_path);
  }
}

static void host_reply_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->reply_state_file_path[0] == '\0') {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->reply_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "reply state file path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open reply state file", errno);
    return;
  }

  size_t stored_count = 0U;
  for (size_t idx = 0U; idx < host->reply_count; ++idx) {
    if (host->replies[idx].in_use) {
      ++stored_count;
    }
  }

  reply_state_header_t header = {0};
  header.magic = REPLY_STATE_MAGIC;
  header.version = REPLY_STATE_VERSION;
  header.entry_count = (uint32_t)stored_count;
  header.next_reply_id = host->next_reply_id;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  for (size_t idx = 0U; success && idx < host->reply_count; ++idx) {
    const chat_reply_entry_t *reply = &host->replies[idx];
    if (!reply->in_use) {
      continue;
    }

    reply_state_entry_t serialized = {0};
    serialized.reply_id = reply->reply_id;
    serialized.parent_message_id = reply->parent_message_id;
    serialized.parent_reply_id = reply->parent_reply_id;
    serialized.created_at = (int64_t)reply->created_at;
    snprintf(serialized.username, sizeof(serialized.username), "%s", reply->username);
    snprintf(serialized.message, sizeof(serialized.message), "%s", reply->message);

    if (fwrite(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (!success) {
    humanized_log_error("host", "failed to write reply state file", write_error != 0 ? write_error : EIO);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->reply_state_file_path) != 0) {
    humanized_log_error("host", "failed to update reply state file", errno);
    unlink(temp_path);
  }
}

static void vote_state_export_poll_entry(const poll_state_t *source, vote_state_poll_entry_t *dest) {
  if (dest == NULL) {
    return;
  }

  memset(dest, 0, sizeof(*dest));
  if (source == NULL) {
    return;
  }

  dest->active = source->active ? 1U : 0U;
  dest->allow_multiple = source->allow_multiple ? 1U : 0U;
  dest->id = source->id;
  dest->option_count = (uint32_t)source->option_count;
  if (dest->option_count > 5U) {
    dest->option_count = 5U;
  }
  snprintf(dest->question, sizeof(dest->question), "%s", source->question);
  for (size_t idx = 0U; idx < 5U; ++idx) {
    snprintf(dest->options[idx].text, sizeof(dest->options[idx].text), "%s", source->options[idx].text);
    dest->options[idx].votes = source->options[idx].votes;
  }
}

static void vote_state_import_poll_entry(const vote_state_poll_entry_t *source, poll_state_t *dest) {
  if (dest == NULL) {
    return;
  }

  poll_state_reset(dest);
  if (source == NULL) {
    return;
  }

  dest->active = source->active != 0U;
  dest->allow_multiple = source->allow_multiple != 0U;
  dest->id = source->id;
  size_t option_count = source->option_count;
  if (option_count > 5U) {
    option_count = 5U;
  }
  dest->option_count = option_count;
  snprintf(dest->question, sizeof(dest->question), "%s", source->question);
  for (size_t idx = 0U; idx < option_count; ++idx) {
    snprintf(dest->options[idx].text, sizeof(dest->options[idx].text), "%s", source->options[idx].text);
    dest->options[idx].votes = source->options[idx].votes;
  }
  for (size_t idx = option_count; idx < 5U; ++idx) {
    dest->options[idx].text[0] = '\0';
    dest->options[idx].votes = 0U;
  }
}

static void host_vote_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->vote_state_file_path[0] == '\0') {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->vote_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "vote state file path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open vote state file", errno);
    return;
  }

  uint32_t named_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    if (host->named_polls[idx].label[0] != '\0') {
      ++named_count;
    }
  }

  vote_state_header_t header = {0};
  header.magic = VOTE_STATE_MAGIC;
  header.version = VOTE_STATE_VERSION;
  header.named_count = named_count;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  vote_state_poll_entry_t main_entry = {0};
  vote_state_export_poll_entry(&host->poll, &main_entry);
  if (success) {
    success = fwrite(&main_entry, sizeof(main_entry), 1U, fp) == 1U;
    if (!success && errno != 0) {
      write_error = errno;
    }
  }

  for (size_t idx = 0U; success && idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    const named_poll_state_t *poll = &host->named_polls[idx];
    if (poll->label[0] == '\0') {
      continue;
    }

    vote_state_named_entry_t entry = {0};
    vote_state_export_poll_entry(&poll->poll, &entry.poll);
    snprintf(entry.label, sizeof(entry.label), "%s", poll->label);
    snprintf(entry.owner, sizeof(entry.owner), "%s", poll->owner);
    entry.voter_count = (uint32_t)poll->voter_count;
    if (entry.voter_count > SSH_CHATTER_MAX_NAMED_VOTERS) {
      entry.voter_count = SSH_CHATTER_MAX_NAMED_VOTERS;
    }
    for (size_t voter = 0U; voter < SSH_CHATTER_MAX_NAMED_VOTERS; ++voter) {
      snprintf(entry.voters[voter].username, sizeof(entry.voters[voter].username), "%s", poll->voters[voter].username);
      entry.voters[voter].choice = poll->voters[voter].choice;
      entry.voters[voter].choices_mask = poll->voters[voter].choices_mask;
    }

    if (fwrite(&entry, sizeof(entry), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (!success) {
    humanized_log_error("host", "failed to write vote state file", write_error != 0 ? write_error : EIO);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->vote_state_file_path) != 0) {
    humanized_log_error("host", "failed to update vote state file", errno);
    unlink(temp_path);
  }
}

static void host_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->state_file_path[0] == '\0') {
    return;
  }

  FILE *fp = fopen(host->state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  host_state_header_v1_t base_header = {0};
  if (fread(&base_header, sizeof(base_header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (base_header.magic != HOST_STATE_MAGIC) {
    fclose(fp);
    return;
  }

  uint32_t version = base_header.version;
  if (version == 0U || version > HOST_STATE_VERSION) {
    fclose(fp);
    return;
  }

  uint32_t history_count = base_header.history_count;
  uint32_t preference_count = base_header.preference_count;
  uint64_t next_message_id = 1U;

  uint32_t grant_count = 0U;
  uint8_t captcha_enabled_raw = 0U;
  if (version >= 2U) {
    uint32_t sound_count_raw = 0U;
    uint32_t grant_count_raw = 0U;
    uint64_t next_id_raw = 0U;
    if (fread(&sound_count_raw, sizeof(sound_count_raw), 1U, fp) != 1U ||
        fread(&grant_count_raw, sizeof(grant_count_raw), 1U, fp) != 1U ||
        fread(&next_id_raw, sizeof(next_id_raw), 1U, fp) != 1U) {
      fclose(fp);
      return;
    }
    next_message_id = next_id_raw;
    if (version >= 5U) {
      grant_count = grant_count_raw;
    }
  }

  if (version >= 8U) {
    uint8_t reserved_bytes[7] = {0};
    if (fread(&captcha_enabled_raw, sizeof(captcha_enabled_raw), 1U, fp) != 1U ||
        fread(reserved_bytes, sizeof(reserved_bytes), 1U, fp) != 1U) {
      fclose(fp);
      return;
    }
  }

  if (preference_count > SSH_CHATTER_MAX_PREFERENCES) {
    preference_count = SSH_CHATTER_MAX_PREFERENCES;
  }

  pthread_mutex_lock(&host->lock);

  if (version >= 8U) {
    atomic_store(&host->captcha_enabled, captcha_enabled_raw != 0U);
  }

  bool success = true;

  if (history_count > 0U) {
    success = host_history_reserve_locked(host, history_count);
  }
  host->history_count = 0U;

  for (uint32_t idx = 0; success && idx < history_count; ++idx) {
    chat_history_entry_t *entry = &host->history[idx];
    memset(entry, 0, sizeof(*entry));

    if (version >= 3U) {
      host_state_history_entry_v3_t serialized = {0};
      if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
        success = false;
        break;
      }

      entry->is_user_message = serialized.base.is_user_message != 0U;
      entry->user_is_bold = serialized.base.user_is_bold != 0U;
      snprintf(entry->username, sizeof(entry->username), "%s", serialized.base.username);
      snprintf(entry->message, sizeof(entry->message), "%s", serialized.base.message);
      snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", serialized.base.user_color_name);
      snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s",
               serialized.base.user_highlight_name);
      entry->message_id = serialized.message_id;
      if (serialized.attachment_type > CHAT_ATTACHMENT_FILE) {
        entry->attachment_type = CHAT_ATTACHMENT_NONE;
      } else {
        entry->attachment_type = (chat_attachment_type_t)serialized.attachment_type;
      }
      snprintf(entry->attachment_target, sizeof(entry->attachment_target), "%s", serialized.attachment_target);
      snprintf(entry->attachment_caption, sizeof(entry->attachment_caption), "%s", serialized.attachment_caption);
      memcpy(entry->reaction_counts, serialized.reaction_counts, sizeof(entry->reaction_counts));
    } else if (version == 2U) {
      host_state_history_entry_v2_t serialized = {0};
      if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
        success = false;
        break;
      }

      entry->is_user_message = serialized.base.is_user_message != 0U;
      entry->user_is_bold = serialized.base.user_is_bold != 0U;
      snprintf(entry->username, sizeof(entry->username), "%s", serialized.base.username);
      snprintf(entry->message, sizeof(entry->message), "%s", serialized.base.message);
      snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", serialized.base.user_color_name);
      snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s",
               serialized.base.user_highlight_name);
      entry->message_id = serialized.message_id;
      if (serialized.attachment_type > CHAT_ATTACHMENT_AUDIO) {
        entry->attachment_type = CHAT_ATTACHMENT_NONE;
      } else {
        entry->attachment_type = (chat_attachment_type_t)serialized.attachment_type;
      }
      snprintf(entry->attachment_target, sizeof(entry->attachment_target), "%s", serialized.attachment_target);
      snprintf(entry->attachment_caption, sizeof(entry->attachment_caption), "%s", serialized.attachment_caption);
      memcpy(entry->reaction_counts, serialized.reaction_counts, sizeof(entry->reaction_counts));
      if (serialized.sound_alias[0] != '\0' && entry->attachment_caption[0] == '\0') {
        snprintf(entry->attachment_caption, sizeof(entry->attachment_caption), "%s", serialized.sound_alias);
      }
    } else {
      host_state_history_entry_v1_t serialized = {0};
      if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
        success = false;
        break;
      }

      entry->is_user_message = serialized.is_user_message != 0U;
      entry->user_is_bold = serialized.user_is_bold != 0U;
      snprintf(entry->username, sizeof(entry->username), "%s", serialized.username);
      snprintf(entry->message, sizeof(entry->message), "%s", serialized.message);
      snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", serialized.user_color_name);
      snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s", serialized.user_highlight_name);
      entry->attachment_type = CHAT_ATTACHMENT_NONE;
      entry->message_id = 0U;
    }

    host_history_normalize_entry(host, entry);
    ++host->history_count;
  }

  memset(host->preferences, 0, sizeof(host->preferences));
  host->preference_count = 0U;

  for (uint32_t idx = 0; success && idx < preference_count; ++idx) {
    host_state_preference_entry_t serialized = {0};
    if (version >= 9U) {
      if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
        success = false;
        break;
      }
    } else if (version >= 7U) {
      host_state_preference_entry_v7_t legacy7 = {0};
      if (fread(&legacy7, sizeof(legacy7), 1U, fp) != 1U) {
        success = false;
        break;
      }
      serialized.has_user_theme = legacy7.has_user_theme;
      serialized.has_system_theme = legacy7.has_system_theme;
      serialized.user_is_bold = legacy7.user_is_bold;
      serialized.system_is_bold = legacy7.system_is_bold;
      snprintf(serialized.username, sizeof(serialized.username), "%s", legacy7.username);
      snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", legacy7.user_color_name);
      snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s",
               legacy7.user_highlight_name);
      snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", legacy7.system_fg_name);
      snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", legacy7.system_bg_name);
      snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
               legacy7.system_highlight_name);
      snprintf(serialized.os_name, sizeof(serialized.os_name), "%s", legacy7.os_name);
      serialized.daily_year = legacy7.daily_year;
      serialized.daily_yday = legacy7.daily_yday;
      snprintf(serialized.daily_function, sizeof(serialized.daily_function), "%s", legacy7.daily_function);
      serialized.last_poll_id = legacy7.last_poll_id;
      serialized.last_poll_choice = legacy7.last_poll_choice;
      serialized.has_birthday = legacy7.has_birthday;
      serialized.translation_caption_spacing = legacy7.translation_caption_spacing;
      serialized.translation_enabled = legacy7.translation_enabled;
      serialized.output_translation_enabled = legacy7.output_translation_enabled;
      serialized.input_translation_enabled = legacy7.input_translation_enabled;
      serialized.translation_master_explicit = legacy7.translation_master_explicit;
      snprintf(serialized.birthday, sizeof(serialized.birthday), "%s", legacy7.birthday);
      snprintf(serialized.output_translation_language, sizeof(serialized.output_translation_language), "%s",
               legacy7.output_translation_language);
      snprintf(serialized.input_translation_language, sizeof(serialized.input_translation_language), "%s",
               legacy7.input_translation_language);
      serialized.ui_language[0] = '\0';
    } else if (version == 6U) {
      host_state_preference_entry_v6_t legacy6 = {0};
      if (fread(&legacy6, sizeof(legacy6), 1U, fp) != 1U) {
        success = false;
        break;
      }
      serialized.has_user_theme = legacy6.has_user_theme;
      serialized.has_system_theme = legacy6.has_system_theme;
      serialized.user_is_bold = legacy6.user_is_bold;
      serialized.system_is_bold = legacy6.system_is_bold;
      snprintf(serialized.username, sizeof(serialized.username), "%s", legacy6.username);
      snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", legacy6.user_color_name);
      snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s", legacy6.user_highlight_name);
      snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", legacy6.system_fg_name);
      snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", legacy6.system_bg_name);
      snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
               legacy6.system_highlight_name);
      snprintf(serialized.os_name, sizeof(serialized.os_name), "%s", legacy6.os_name);
      serialized.daily_year = legacy6.daily_year;
      serialized.daily_yday = legacy6.daily_yday;
      snprintf(serialized.daily_function, sizeof(serialized.daily_function), "%s", legacy6.daily_function);
      serialized.last_poll_id = legacy6.last_poll_id;
      serialized.last_poll_choice = legacy6.last_poll_choice;
      serialized.has_birthday = legacy6.has_birthday;
      serialized.translation_caption_spacing = legacy6.translation_caption_spacing;
      serialized.translation_enabled = legacy6.translation_enabled;
      serialized.output_translation_enabled = legacy6.output_translation_enabled;
      serialized.input_translation_enabled = legacy6.input_translation_enabled;
      serialized.translation_master_explicit = legacy6.translation_enabled;
      snprintf(serialized.birthday, sizeof(serialized.birthday), "%s", legacy6.birthday);
      snprintf(serialized.output_translation_language, sizeof(serialized.output_translation_language), "%s",
               legacy6.output_translation_language);
      snprintf(serialized.input_translation_language, sizeof(serialized.input_translation_language), "%s",
               legacy6.input_translation_language);
      serialized.ui_language[0] = '\0';
    } else if (version == 5U) {
      host_state_preference_entry_v5_t legacy5 = {0};
      if (fread(&legacy5, sizeof(legacy5), 1U, fp) != 1U) {
        success = false;
        break;
      }
      serialized.has_user_theme = legacy5.has_user_theme;
      serialized.has_system_theme = legacy5.has_system_theme;
      serialized.user_is_bold = legacy5.user_is_bold;
      serialized.system_is_bold = legacy5.system_is_bold;
      snprintf(serialized.username, sizeof(serialized.username), "%s", legacy5.username);
      snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", legacy5.user_color_name);
      snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s", legacy5.user_highlight_name);
      snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", legacy5.system_fg_name);
      snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", legacy5.system_bg_name);
      snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
               legacy5.system_highlight_name);
      snprintf(serialized.os_name, sizeof(serialized.os_name), "%s", legacy5.os_name);
      serialized.daily_year = legacy5.daily_year;
      serialized.daily_yday = legacy5.daily_yday;
      snprintf(serialized.daily_function, sizeof(serialized.daily_function), "%s", legacy5.daily_function);
      serialized.last_poll_id = legacy5.last_poll_id;
      serialized.last_poll_choice = legacy5.last_poll_choice;
      serialized.has_birthday = legacy5.has_birthday;
      serialized.translation_caption_spacing = legacy5.reserved[0];
      serialized.translation_enabled = 0U;
      serialized.output_translation_enabled = 0U;
      serialized.input_translation_enabled = 0U;
      serialized.translation_master_explicit = 0U;
      snprintf(serialized.birthday, sizeof(serialized.birthday), "%s", legacy5.birthday);
      serialized.output_translation_language[0] = '\0';
      serialized.input_translation_language[0] = '\0';
      serialized.ui_language[0] = '\0';
    } else if (version == 4U) {
      host_state_preference_entry_v4_t legacy4 = {0};
      if (fread(&legacy4, sizeof(legacy4), 1U, fp) != 1U) {
        success = false;
        break;
      }
      serialized.has_user_theme = legacy4.has_user_theme;
      serialized.has_system_theme = legacy4.has_system_theme;
      serialized.user_is_bold = legacy4.user_is_bold;
      serialized.system_is_bold = legacy4.system_is_bold;
      snprintf(serialized.username, sizeof(serialized.username), "%s", legacy4.username);
      snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", legacy4.user_color_name);
      snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s", legacy4.user_highlight_name);
      snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", legacy4.system_fg_name);
      snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", legacy4.system_bg_name);
      snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
               legacy4.system_highlight_name);
      snprintf(serialized.os_name, sizeof(serialized.os_name), "%s", legacy4.os_name);
      serialized.daily_year = legacy4.daily_year;
      serialized.daily_yday = legacy4.daily_yday;
      snprintf(serialized.daily_function, sizeof(serialized.daily_function), "%s", legacy4.daily_function);
      serialized.last_poll_id = legacy4.last_poll_id;
      serialized.last_poll_choice = legacy4.last_poll_choice;
      serialized.has_birthday = 0U;
      serialized.translation_caption_spacing = 0U;
      serialized.translation_enabled = 0U;
      serialized.output_translation_enabled = 0U;
      serialized.input_translation_enabled = 0U;
      serialized.translation_master_explicit = 0U;
      serialized.birthday[0] = '\0';
      serialized.output_translation_language[0] = '\0';
      serialized.input_translation_language[0] = '\0';
      serialized.ui_language[0] = '\0';
    } else {
      host_state_preference_entry_v3_t legacy = {0};
      if (fread(&legacy, sizeof(legacy), 1U, fp) != 1U) {
        success = false;
        break;
      }
      serialized.has_user_theme = legacy.has_user_theme;
      serialized.has_system_theme = legacy.has_system_theme;
      serialized.user_is_bold = legacy.user_is_bold;
      serialized.system_is_bold = legacy.system_is_bold;
      snprintf(serialized.username, sizeof(serialized.username), "%s", legacy.username);
      snprintf(serialized.user_color_name, sizeof(serialized.user_color_name), "%s", legacy.user_color_name);
      snprintf(serialized.user_highlight_name, sizeof(serialized.user_highlight_name), "%s", legacy.user_highlight_name);
      snprintf(serialized.system_fg_name, sizeof(serialized.system_fg_name), "%s", legacy.system_fg_name);
      snprintf(serialized.system_bg_name, sizeof(serialized.system_bg_name), "%s", legacy.system_bg_name);
      snprintf(serialized.system_highlight_name, sizeof(serialized.system_highlight_name), "%s",
               legacy.system_highlight_name);
      serialized.os_name[0] = '\0';
      serialized.daily_year = 0;
      serialized.daily_yday = 0;
      serialized.daily_function[0] = '\0';
      serialized.last_poll_id = 0U;
      serialized.last_poll_choice = -1;
      serialized.has_birthday = 0U;
      serialized.translation_caption_spacing = 0U;
      serialized.translation_enabled = 0U;
      serialized.output_translation_enabled = 0U;
      serialized.input_translation_enabled = 0U;
      serialized.translation_master_explicit = 0U;
      serialized.birthday[0] = '\0';
      serialized.output_translation_language[0] = '\0';
      serialized.input_translation_language[0] = '\0';
      serialized.ui_language[0] = '\0';
    }

    if (host->preference_count >= SSH_CHATTER_MAX_PREFERENCES) {
      continue;
    }

    user_preference_t *pref = &host->preferences[host->preference_count];
    memset(pref, 0, sizeof(*pref));
    pref->in_use = true;
    pref->has_user_theme = serialized.has_user_theme != 0U;
    pref->has_system_theme = serialized.has_system_theme != 0U;
    pref->user_is_bold = serialized.user_is_bold != 0U;
    pref->system_is_bold = serialized.system_is_bold != 0U;
    snprintf(pref->username, sizeof(pref->username), "%s", serialized.username);
    snprintf(pref->user_color_name, sizeof(pref->user_color_name), "%s", serialized.user_color_name);
    snprintf(pref->user_highlight_name, sizeof(pref->user_highlight_name), "%s", serialized.user_highlight_name);
    snprintf(pref->system_fg_name, sizeof(pref->system_fg_name), "%s", serialized.system_fg_name);
    snprintf(pref->system_bg_name, sizeof(pref->system_bg_name), "%s", serialized.system_bg_name);
    snprintf(pref->system_highlight_name, sizeof(pref->system_highlight_name), "%s",
             serialized.system_highlight_name);
    snprintf(pref->os_name, sizeof(pref->os_name), "%s", serialized.os_name);
    pref->daily_year = serialized.daily_year;
    pref->daily_yday = serialized.daily_yday;
    snprintf(pref->daily_function, sizeof(pref->daily_function), "%s", serialized.daily_function);
    pref->last_poll_id = serialized.last_poll_id;
    pref->last_poll_choice = serialized.last_poll_choice;
    pref->has_birthday = serialized.has_birthday != 0U;
    snprintf(pref->birthday, sizeof(pref->birthday), "%s", serialized.birthday);
    pref->translation_caption_spacing = serialized.translation_caption_spacing;
    pref->translation_master_enabled = serialized.translation_enabled != 0U;
    pref->translation_master_explicit = serialized.translation_master_explicit != 0U;
    pref->output_translation_enabled = serialized.output_translation_enabled != 0U;
    pref->input_translation_enabled = serialized.input_translation_enabled != 0U;
    snprintf(pref->output_translation_language, sizeof(pref->output_translation_language), "%s",
             serialized.output_translation_language);
    snprintf(pref->input_translation_language, sizeof(pref->input_translation_language), "%s",
             serialized.input_translation_language);
    ++host->preference_count;
  }

  memset(host->operator_grants, 0, HOST_GRANTS_CLEAR_SIZE);
  host->operator_grant_count = 0U;
  for (uint32_t idx = 0; success && idx < grant_count; ++idx) {
    host_state_grant_entry_t serialized = {0};
    if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
      break;
    }
    if (serialized.ip[0] == '\0') {
      continue;
    }
    if (host->operator_grant_count >= SSH_CHATTER_MAX_GRANTS) {
      continue;
    }
    snprintf(host->operator_grants[host->operator_grant_count].ip,
             sizeof(host->operator_grants[host->operator_grant_count].ip), "%s", serialized.ip);
    ++host->operator_grant_count;
  }

  if (!success) {
    if (host->history != NULL && host->history_capacity > 0U) {
      memset(host->history, 0, host->history_capacity * sizeof(chat_history_entry_t));
    }
    host->history_count = 0U;
    host->preference_count = 0U;
    memset(host->preferences, 0, sizeof(host->preferences));
  }

  if (next_message_id == 0U) {
    next_message_id = (uint64_t)host->history_count + 1U;
  }
  if (next_message_id <= (uint64_t)host->history_count) {
    next_message_id = (uint64_t)host->history_count + 1U;
  }
  host->next_message_id = next_message_id;

  pthread_mutex_unlock(&host->lock);
  fclose(fp);
}

static void host_clear_rss_feed(rss_feed_t *feed) {
  if (feed == NULL) {
    return;
  }

  memset(feed, 0, sizeof(*feed));
}

static void host_rss_recount_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  size_t count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    if (host->rss_feeds[idx].in_use) {
      ++count;
    }
  }
  host->rss_feed_count = count;
}

static rss_feed_t *host_find_rss_feed_locked(host_t *host, const char *tag) {
  if (host == NULL || tag == NULL || tag[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    rss_feed_t *entry = &host->rss_feeds[idx];
    if (!entry->in_use) {
      continue;
    }
    if (strcasecmp(entry->tag, tag) == 0) {
      return entry;
    }
  }
  return NULL;
}

static bool host_rss_add_feed(host_t *host, const char *url, const char *tag, char *error, size_t error_length) {
  if (error != NULL && error_length > 0U) {
    error[0] = '\0';
  }

  if (host == NULL || url == NULL || url[0] == '\0' || tag == NULL || tag[0] == '\0') {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Invalid RSS feed details.");
    }
    return false;
  }

  pthread_mutex_lock(&host->lock);

  bool success = false;

  if (!rss_tag_is_valid(tag)) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Tag may only contain letters, numbers, '-', '_' or '.'.");
    }
    goto cleanup;
  }

  if (host->rss_feed_count >= SSH_CHATTER_RSS_MAX_FEEDS) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Maximum RSS feed capacity reached.");
    }
    goto cleanup;
  }

  if (host_find_rss_feed_locked(host, tag) != NULL) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Tag '%s' is already assigned to another feed.", tag);
    }
    goto cleanup;
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    rss_feed_t *entry = &host->rss_feeds[idx];
    if (!entry->in_use) {
      continue;
    }
    if (strcasecmp(entry->url, url) == 0) {
      if (error != NULL && error_length > 0U) {
        snprintf(error, error_length, "Feed '%s' is already registered as '%s'.", url, entry->tag);
      }
      goto cleanup;
    }
  }

  rss_feed_t *slot = NULL;
  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    if (!host->rss_feeds[idx].in_use) {
      slot = &host->rss_feeds[idx];
      break;
    }
  }

  if (slot == NULL) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Unable to allocate RSS feed slot.");
    }
    goto cleanup;
  }

  host_clear_rss_feed(slot);
  slot->in_use = true;
  snprintf(slot->tag, sizeof(slot->tag), "%s", tag);
  snprintf(slot->url, sizeof(slot->url), "%s", url);
  slot->last_item_key[0] = '\0';
  slot->last_title[0] = '\0';
  slot->last_link[0] = '\0';
  slot->last_checked = 0;

  host_rss_recount_locked(host);
  host_rss_state_save_locked(host);
  success = true;

cleanup:
  pthread_mutex_unlock(&host->lock);
  return success;
}

static bool host_rss_remove_feed(host_t *host, const char *tag, char *error, size_t error_length) {
  if (error != NULL && error_length > 0U) {
    error[0] = '\0';
  }

  if (host == NULL || tag == NULL || tag[0] == '\0') {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Invalid RSS feed tag.");
    }
    return false;
  }

  pthread_mutex_lock(&host->lock);

  bool success = false;

  if (!rss_tag_is_valid(tag)) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Tag may only contain letters, numbers, '-', '_' or '.'.");
    }
    goto cleanup;
  }

  rss_feed_t *entry = host_find_rss_feed_locked(host, tag);
  if (entry == NULL) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "No RSS feed found for tag '%s'.", tag);
    }
    goto cleanup;
  }

  host_clear_rss_feed(entry);
  host_rss_recount_locked(host);
  host_rss_state_save_locked(host);
  success = true;

cleanup:
  pthread_mutex_unlock(&host->lock);
  return success;
}

static void host_rss_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *rss_path = getenv("CHATTER_RSS_FILE");
  if (rss_path == NULL || rss_path[0] == '\0') {
    rss_path = "rss_state.dat";
  }

  int written = snprintf(host->rss_state_file_path, sizeof(host->rss_state_file_path), "%s", rss_path);
  if (written < 0 || (size_t)written >= sizeof(host->rss_state_file_path)) {
    humanized_log_error("host", "rss state file path is too long", ENAMETOOLONG);
    host->rss_state_file_path[0] = '\0';
  }
}

static void host_rss_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->rss_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->rss_state_file_path, true)) {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->rss_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "rss state file path is too long", ENAMETOOLONG);
    return;
  }

  int temp_fd = open(temp_path, O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW, S_IRUSR | S_IWUSR);
  if (temp_fd < 0) {
    humanized_log_error("host", "failed to open rss state file", errno != 0 ? errno : EIO);
    return;
  }

  FILE *fp = fdopen(temp_fd, "wb");
  if (fp == NULL) {
    int saved_errno = errno;
    close(temp_fd);
    unlink(temp_path);
    humanized_log_error("host", "failed to wrap rss state descriptor", saved_errno != 0 ? saved_errno : EIO);
    return;
  }

  uint32_t feed_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    if (host->rss_feeds[idx].in_use) {
      ++feed_count;
    }
  }

  rss_state_header_t header = {0};
  header.magic = RSS_STATE_MAGIC;
  header.version = RSS_STATE_VERSION;
  header.feed_count = feed_count;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;

  for (size_t idx = 0U; success && idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    const rss_feed_t *entry = &host->rss_feeds[idx];
    if (!entry->in_use) {
      continue;
    }

    rss_state_entry_t record = {0};
    snprintf(record.tag, sizeof(record.tag), "%s", entry->tag);
    snprintf(record.url, sizeof(record.url), "%s", entry->url);
    snprintf(record.last_item_key, sizeof(record.last_item_key), "%s", entry->last_item_key);

    if (fwrite(&record, sizeof(record), 1U, fp) != 1U) {
      success = false;
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
  }

  if (success) {
    int descriptor = fileno(fp);
    if (descriptor >= 0 && fsync(descriptor) != 0) {
      success = false;
    }
  }

  if (fclose(fp) != 0) {
    success = false;
  }

  if (!success) {
    humanized_log_error("host", "failed to write rss state file", errno != 0 ? errno : EIO);
    unlink(temp_path);
    return;
  }

  if (chmod(temp_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to tighten temporary rss state permissions", errno != 0 ? errno : EACCES);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->rss_state_file_path) != 0) {
    humanized_log_error("host", "failed to update rss state file", errno != 0 ? errno : EIO);
    unlink(temp_path);
  } else if (chmod(host->rss_state_file_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to tighten rss state permissions", errno != 0 ? errno : EACCES);
  }
}

static void host_rss_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->rss_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->rss_state_file_path, false)) {
    return;
  }

  FILE *fp = fopen(host->rss_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  rss_state_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != RSS_STATE_MAGIC || header.version == 0U || header.version > RSS_STATE_VERSION) {
    fclose(fp);
    return;
  }

  pthread_mutex_lock(&host->lock);

  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    host_clear_rss_feed(&host->rss_feeds[idx]);
  }
  host->rss_feed_count = 0U;

  bool success = true;
  for (uint32_t idx = 0U; idx < header.feed_count; ++idx) {
    rss_state_entry_t record = {0};
    if (fread(&record, sizeof(record), 1U, fp) != 1U) {
      success = false;
      break;
    }

    rss_trim_whitespace(record.tag);
    rss_trim_whitespace(record.url);
    rss_trim_whitespace(record.last_item_key);

    if (!rss_tag_is_valid(record.tag) || record.url[0] == '\0') {
      continue;
    }

    rss_feed_t *slot = NULL;
    for (size_t pos = 0U; pos < SSH_CHATTER_RSS_MAX_FEEDS; ++pos) {
      if (!host->rss_feeds[pos].in_use) {
        slot = &host->rss_feeds[pos];
        break;
      }
    }

    if (slot == NULL) {
      continue;
    }

    host_clear_rss_feed(slot);
    slot->in_use = true;
    snprintf(slot->tag, sizeof(slot->tag), "%s", record.tag);
    snprintf(slot->url, sizeof(slot->url), "%s", record.url);
    snprintf(slot->last_item_key, sizeof(slot->last_item_key), "%s", record.last_item_key);
    slot->last_checked = 0;
  }

  if (success) {
    host_rss_recount_locked(host);
  } else {
    for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
      host_clear_rss_feed(&host->rss_feeds[idx]);
    }
    host->rss_feed_count = 0U;
  }

  pthread_mutex_unlock(&host->lock);
  fclose(fp);
}

typedef struct host_rss_buffer {
  char *data;
  size_t length;
} host_rss_buffer_t;

static size_t host_rss_write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
  host_rss_buffer_t *buffer = (host_rss_buffer_t *)userp;
  const size_t total = size * nmemb;
  if (buffer == NULL || total == 0U) {
    return 0U;
  }

  char *resized = realloc(buffer->data, buffer->length + total + 1U);
  if (resized == NULL) {
    return 0U;
  }

  buffer->data = resized;
  memcpy(buffer->data + buffer->length, contents, total);
  buffer->length += total;
  buffer->data[buffer->length] = '\0';
  return total;
}

static bool host_rss_download(const char *url, char **payload, size_t *length) {
  if (payload != NULL) {
    *payload = NULL;
  }
  if (length != NULL) {
    *length = 0U;
  }

  if (url == NULL || url[0] == '\0') {
    return false;
  }

  CURL *curl = curl_easy_init();
  if (curl == NULL) {
    return false;
  }

  host_rss_buffer_t buffer = {0};
  curl_easy_setopt(curl, CURLOPT_URL, url);
  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
  curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(curl, CURLOPT_USERAGENT, SSH_CHATTER_RSS_USER_AGENT);
  curl_easy_setopt(curl, CURLOPT_ACCEPT_ENCODING, "");
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, host_rss_write_callback);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);

  bool success = false;
  CURLcode result = curl_easy_perform(curl);
  if (result == CURLE_OK) {
    long status = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &status);
    if (status >= 200L && status < 300L && buffer.data != NULL) {
      if (payload != NULL) {
        *payload = buffer.data;
      }
      if (length != NULL) {
        *length = buffer.length;
      }
      buffer.data = NULL;
      success = true;
    }
  }

  if (!success) {
  }

  curl_easy_cleanup(curl);
  return success;
}

static bool host_rss_extract_tag(const char *block, const char *tag, char *out, size_t out_len) {
  if (block == NULL || tag == NULL || out == NULL || out_len == 0U) {
    return false;
  }

  char open_pattern[32];
  char close_pattern[32];
  int open_written = snprintf(open_pattern, sizeof(open_pattern), "<%s", tag);
  int close_written = snprintf(close_pattern, sizeof(close_pattern), "</%s>", tag);
  if (open_written < 0 || (size_t)open_written >= sizeof(open_pattern) || close_written < 0 ||
      (size_t)close_written >= sizeof(close_pattern)) {
    return false;
  }

  const char *start = strcasestr(block, open_pattern);
  if (start == NULL) {
    return false;
  }

  const char *content = strchr(start, '>');
  if (content == NULL) {
    return false;
  }
  ++content;

  const char *end = strcasestr(content, close_pattern);
  if (end == NULL) {
    return false;
  }

  size_t length = (size_t)(end - content);
  if (length >= out_len) {
    length = out_len - 1U;
  }
  memcpy(out, content, length);
  out[length] = '\0';
  return true;
}

static bool host_rss_extract_atom_link(const char *block, char *out, size_t out_len) {
  if (block == NULL || out == NULL || out_len == 0U) {
    return false;
  }

  const char *cursor = block;
  while ((cursor = strcasestr(cursor, "<link")) != NULL) {
    const char *close = strchr(cursor, '>');
    if (close == NULL) {
      return false;
    }

    const char *href = strcasestr(cursor, "href=");
    if (href == NULL || href > close) {
      cursor = close + 1;
      continue;
    }

    href += 5; // skip href=
    char quote = *href;
    if (quote != '\"' && quote != '\'') {
      cursor = close + 1;
      continue;
    }
    ++href;

    const char *end = strchr(href, quote);
    if (end == NULL || end > close) {
      cursor = close + 1;
      continue;
    }

    size_t length = (size_t)(end - href);
    if (length >= out_len) {
      length = out_len - 1U;
    }
    memcpy(out, href, length);
    out[length] = '\0';
    rss_trim_whitespace(out);
    return out[0] != '\0';
  }

  return false;
}

static size_t host_rss_parse_items(const char *payload, rss_session_item_t *items, size_t max_items) {
  if (payload == NULL || items == NULL || max_items == 0U) {
    return 0U;
  }

  for (size_t idx = 0U; idx < max_items; ++idx) {
    memset(&items[idx], 0, sizeof(items[idx]));
  }

  size_t count = 0U;
  const char *cursor = payload;
  while (*cursor != '\0' && count < max_items) {
    const char *item_start = strcasestr(cursor, "<item");
    const char *entry_start = strcasestr(cursor, "<entry");
    const char *start = NULL;
    const char *close_tag = NULL;
    bool is_atom = false;

    if (item_start == NULL && entry_start == NULL) {
      break;
    }

    if (item_start != NULL && (entry_start == NULL || item_start < entry_start)) {
      start = item_start;
      close_tag = "</item>";
    } else {
      start = entry_start;
      close_tag = "</entry>";
      is_atom = true;
    }

    const char *end = strcasestr(start, close_tag);
    if (end == NULL) {
      break;
    }
    end += strlen(close_tag);

    size_t block_len = (size_t)(end - start);
    char *block = (char *)GC_MALLOC(block_len + 1U);
    if (block == NULL) {
      break;
    }
    memcpy(block, start, block_len);
    block[block_len] = '\0';

    char title[SSH_CHATTER_RSS_TITLE_LEN] = {0};
    char link[SSH_CHATTER_RSS_LINK_LEN] = {0};
    char summary[SSH_CHATTER_RSS_SUMMARY_LEN] = {0};
    char guid[SSH_CHATTER_RSS_ITEM_KEY_LEN] = {0};

    bool have_title = host_rss_extract_tag(block, "title", title, sizeof(title));
    bool have_link = host_rss_extract_tag(block, "link", link, sizeof(link));
    if (!have_link) {
      have_link = host_rss_extract_atom_link(block, link, sizeof(link));
    }
    bool have_guid = false;
    if (is_atom) {
      have_guid = host_rss_extract_tag(block, "id", guid, sizeof(guid));
    } else {
      have_guid = host_rss_extract_tag(block, "guid", guid, sizeof(guid));
    }
    bool have_summary = host_rss_extract_tag(block, "description", summary, sizeof(summary));
    if (!have_summary) {
      have_summary = host_rss_extract_tag(block, "summary", summary, sizeof(summary));
    }
    if (!have_summary) {
      have_summary = host_rss_extract_tag(block, "content", summary, sizeof(summary));
    }

    rss_trim_whitespace(title);
    rss_trim_whitespace(link);
    rss_trim_whitespace(guid);
    rss_trim_whitespace(summary);
    rss_strip_html(summary);
    rss_decode_entities(title);
    rss_decode_entities(link);
    rss_decode_entities(guid);
    rss_decode_entities(summary);

    rss_session_item_t *item = &items[count];
    if (have_title) {
      snprintf(item->title, sizeof(item->title), "%s", title);
    }
    if (have_link) {
      snprintf(item->link, sizeof(item->link), "%s", link);
    }
    if (have_summary) {
      snprintf(item->summary, sizeof(item->summary), "%s", summary);
    }

    if (have_guid) {
      snprintf(item->id, sizeof(item->id), "%s", guid);
    } else if (have_link) {
      snprintf(item->id, sizeof(item->id), "%s", link);
    } else if (have_title) {
      snprintf(item->id, sizeof(item->id), "%s", title);
    }

    ++count;
    cursor = end;
  }

  return count;
}

static bool host_rss_fetch_items(const rss_feed_t *feed, rss_session_item_t *items, size_t max_items, size_t *out_count) {
  if (out_count != NULL) {
    *out_count = 0U;
  }

  if (feed == NULL || items == NULL || max_items == 0U) {
    return false;
  }

  char *payload = NULL;
  size_t length = 0U;
  if (!host_rss_download(feed->url, &payload, &length)) {
    return false;
  }

  size_t count = host_rss_parse_items(payload, items, max_items);
  if (out_count != NULL) {
    *out_count = count;
  }

  return true;
}

static bool host_rss_should_broadcast_breaking(const rss_session_item_t *item) {
  if (item == NULL) {
    return false;
  }

  const char *fields[] = {item->title, item->summary, item->link};
  for (size_t field_index = 0U; field_index < sizeof(fields) / sizeof(fields[0]); ++field_index) {
    const char *field = fields[field_index];
    if (field == NULL || field[0] == '\0') {
      continue;
    }

    if (strncasecmp(field, "[breaking", 9) == 0) {
      return true;
    }
    if (strcasestr(field, "breaking news") != NULL || strcasestr(field, "breaking:") != NULL ||
        strcasestr(field, "breaking ") != NULL) {
      return true;
    }
    if (strcasestr(field, "urgent") != NULL || strcasestr(field, "alert") != NULL) {
      return true;
    }
    if (strstr(field, "속보") != NULL || strstr(field, "速報") != NULL) {
      return true;
    }
  }

  return false;
}

static void *host_rss_backend(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  atomic_store(&host->rss_thread_running, true);
  printf("[rss] backend thread started (interval: %u seconds)\n", (unsigned int)SSH_CHATTER_RSS_REFRESH_SECONDS);

  while (!atomic_load(&host->rss_thread_stop)) {
    rss_feed_t feed_snapshots[SSH_CHATTER_RSS_MAX_FEEDS];
    size_t snapshot_count = 0U;

    pthread_mutex_lock(&host->lock);
    for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
      if (!host->rss_feeds[idx].in_use) {
        continue;
      }
      feed_snapshots[snapshot_count++] = host->rss_feeds[idx];
    }
    pthread_mutex_unlock(&host->lock);

    if (snapshot_count > 0U) {
      for (size_t snapshot_index = 0U; snapshot_index < snapshot_count && !atomic_load(&host->rss_thread_stop);
           ++snapshot_index) {
        rss_feed_t feed_snapshot = feed_snapshots[snapshot_index];

        rss_session_item_t items[SSH_CHATTER_RSS_MAX_ITEMS];
        size_t item_count = 0U;
        if (!host_rss_fetch_items(&feed_snapshot, items, SSH_CHATTER_RSS_MAX_ITEMS, &item_count)) {
          printf("[rss] failed to refresh feed '%s' (%s)\n", feed_snapshot.tag, feed_snapshot.url);
          continue;
        }

        size_t new_item_count = 0U;
        if (item_count > 0U) {
          if (feed_snapshot.last_item_key[0] == '\0') {
            new_item_count = 0U;
          } else {
            bool found_marker = false;
            for (size_t idx = 0U; idx < item_count; ++idx) {
              if (items[idx].id[0] == '\0' || feed_snapshot.last_item_key[0] == '\0') {
                continue;
              }
              if (strcmp(items[idx].id, feed_snapshot.last_item_key) == 0) {
                new_item_count = idx;
                found_marker = true;
                break;
              }
            }
            if (!found_marker) {
              new_item_count = item_count;
            }
          }
        }

        bool feed_active = false;
        bool key_changed = false;
        time_t now = time(NULL);

        pthread_mutex_lock(&host->lock);
        rss_feed_t *entry = host_find_rss_feed_locked(host, feed_snapshot.tag);
        if (entry != NULL && entry->in_use) {
          feed_active = true;
          entry->last_checked = now;
          if (item_count > 0U) {
            const rss_session_item_t *latest = &items[0U];
            char new_key[SSH_CHATTER_RSS_ITEM_KEY_LEN];
            new_key[0] = '\0';
            if (latest->id[0] != '\0') {
              snprintf(new_key, sizeof(new_key), "%s", latest->id);
            } else if (latest->link[0] != '\0') {
              snprintf(new_key, sizeof(new_key), "%s", latest->link);
            } else if (latest->title[0] != '\0') {
              snprintf(new_key, sizeof(new_key), "%s", latest->title);
            }

            if (new_key[0] != '\0' && strcmp(entry->last_item_key, new_key) != 0) {
              snprintf(entry->last_item_key, sizeof(entry->last_item_key), "%s", new_key);
              key_changed = true;
            }

            if (latest->title[0] != '\0') {
              snprintf(entry->last_title, sizeof(entry->last_title), "%s", latest->title);
            } else {
              entry->last_title[0] = '\0';
            }

            if (latest->link[0] != '\0') {
              snprintf(entry->last_link, sizeof(entry->last_link), "%s", latest->link);
            } else {
              entry->last_link[0] = '\0';
            }
          }

          if (key_changed) {
            host_rss_state_save_locked(host);
          }
        }
        pthread_mutex_unlock(&host->lock);

        if (!feed_active || new_item_count == 0U) {
          continue;
        }

        for (size_t idx = new_item_count; idx > 0U && !atomic_load(&host->rss_thread_stop); --idx) {
          const rss_session_item_t *item = &items[idx - 1U];
          if (!host_rss_should_broadcast_breaking(item)) {
            continue;
          }

          char headline[SSH_CHATTER_RSS_TITLE_LEN];
          if (item->title[0] != '\0') {
            snprintf(headline, sizeof(headline), "%s", item->title);
          } else if (item->summary[0] != '\0') {
            snprintf(headline, sizeof(headline), "%s", item->summary);
          } else if (item->link[0] != '\0') {
            snprintf(headline, sizeof(headline), "%s", item->link);
          } else {
            snprintf(headline, sizeof(headline), "%s", "New update");
          }

          rss_trim_whitespace(headline);
          for (size_t pos = 0U; headline[pos] != '\0'; ++pos) {
            if (headline[pos] == '\r' || headline[pos] == '\n' || headline[pos] == '\t') {
              headline[pos] = ' ';
            }
          }
          rss_trim_whitespace(headline);
          if (headline[0] == '\0') {
            snprintf(headline, sizeof(headline), "%s", "New update");
          }

          char notice[SSH_CHATTER_MESSAGE_LIMIT];
          if (item->link[0] != '\0') {
            snprintf(notice, sizeof(notice), "* %s [%s] %s — %s", SSH_CHATTER_RSS_BREAKING_PREFIX, feed_snapshot.tag,
                     headline, item->link);
          } else {
            snprintf(notice, sizeof(notice), "* %s [%s] %s", SSH_CHATTER_RSS_BREAKING_PREFIX, feed_snapshot.tag,
                     headline);
          }

          printf("%s\n", notice);
          host_history_record_system(host, notice);
          chat_room_broadcast(&host->room, notice, NULL);
        }
      }
    }

    struct timespec mark;
    if (clock_gettime(CLOCK_MONOTONIC, &mark) == 0) {
      host->rss_last_run = mark;
    } else {
      host->rss_last_run.tv_sec = time(NULL);
      host->rss_last_run.tv_nsec = 0L;
    }

    unsigned int remaining = snapshot_count > 0U ? SSH_CHATTER_RSS_REFRESH_SECONDS : SSH_CHATTER_RSS_SLEEP_CHUNK_SECONDS;
    while (remaining > 0U && !atomic_load(&host->rss_thread_stop)) {
      unsigned int chunk = remaining > SSH_CHATTER_RSS_SLEEP_CHUNK_SECONDS ? SSH_CHATTER_RSS_SLEEP_CHUNK_SECONDS : remaining;
      struct timespec pause = {
          .tv_sec = (time_t)chunk,
          .tv_nsec = 0L,
      };
      nanosleep(&pause, NULL);
      if (remaining <= chunk) {
        remaining = 0U;
      } else {
        remaining -= chunk;
      }
    }
  }

  atomic_store(&host->rss_thread_running, false);
  printf("[rss] backend thread stopped\n");
  return NULL;
}

static void host_rss_start_backend(host_t *host) {
  if (host == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  bool has_feeds = host->rss_feed_count > 0U;
  pthread_mutex_unlock(&host->lock);

  if (!has_feeds) {
    return;
  }

  if (host->rss_thread_initialized) {
    return;
  }

  atomic_store(&host->rss_thread_stop, false);
  atomic_store(&host->rss_thread_running, false);

  int error = pthread_create(&host->rss_thread, NULL, host_rss_backend, host);
  if (error != 0) {
    printf("[rss] failed to start backend thread: %s\n", strerror(error));
    return;
  }

  host->rss_thread_initialized = true;
}

static void host_vote_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->vote_state_file_path[0] == '\0') {
    return;
  }

  FILE *fp = fopen(host->vote_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  vote_state_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != VOTE_STATE_MAGIC) {
    fclose(fp);
    return;
  }

  if (header.version == 0U || header.version > VOTE_STATE_VERSION) {
    fclose(fp);
    return;
  }

  pthread_mutex_lock(&host->lock);

  poll_state_reset(&host->poll);
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    named_poll_reset(&host->named_polls[idx]);
  }
  host->named_poll_count = 0U;

  bool success = true;

  vote_state_poll_entry_t main_entry = {0};
  if (fread(&main_entry, sizeof(main_entry), 1U, fp) != 1U) {
    success = false;
  } else {
    vote_state_import_poll_entry(&main_entry, &host->poll);
  }

  for (uint32_t idx = 0U; success && idx < header.named_count; ++idx) {
    vote_state_named_entry_t entry = {0};
    if (fread(&entry, sizeof(entry), 1U, fp) != 1U) {
      success = false;
      break;
    }

    if (idx >= SSH_CHATTER_MAX_NAMED_POLLS) {
      continue;
    }

    named_poll_state_t *poll = &host->named_polls[idx];
    vote_state_import_poll_entry(&entry.poll, &poll->poll);
    snprintf(poll->label, sizeof(poll->label), "%s", entry.label);
    snprintf(poll->owner, sizeof(poll->owner), "%s", entry.owner);
    poll->voter_count = entry.voter_count;
    if (poll->voter_count > SSH_CHATTER_MAX_NAMED_VOTERS) {
      poll->voter_count = SSH_CHATTER_MAX_NAMED_VOTERS;
    }
    for (size_t voter = 0U; voter < SSH_CHATTER_MAX_NAMED_VOTERS; ++voter) {
      snprintf(poll->voters[voter].username, sizeof(poll->voters[voter].username), "%s", entry.voters[voter].username);
      poll->voters[voter].choice = entry.voters[voter].choice;
      poll->voters[voter].choices_mask = entry.voters[voter].choices_mask;
    }
  }

  if (success) {
    host_recount_named_polls_locked(host);
  } else {
    poll_state_reset(&host->poll);
    for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
      named_poll_reset(&host->named_polls[idx]);
    }
    host->named_poll_count = 0U;
  }

  pthread_mutex_unlock(&host->lock);
  fclose(fp);
}

static void host_ban_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->ban_state_file_path[0] == '\0') {
    return;
  }

  FILE *fp = fopen(host->ban_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  ban_state_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != BAN_STATE_MAGIC || header.version == 0U || header.version > BAN_STATE_VERSION) {
    fclose(fp);
    return;
  }

  uint32_t entry_count = header.entry_count;
  ban_state_entry_t *entries = NULL;
  if (entry_count > 0U) {
    entries = GC_CALLOC(entry_count, sizeof(*entries));
    if (entries == NULL) {
      fclose(fp);
      humanized_log_error("host", "failed to allocate ban state buffer", ENOMEM);
      return;
    }
  }

  bool success = true;
  int read_error = 0;
  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    if (fread(&entries[idx], sizeof(entries[idx]), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        read_error = errno;
      }
      break;
    }
  }

  fclose(fp);

  if (!success) {
    humanized_log_error("host", "failed to read ban state file", read_error != 0 ? read_error : EIO);
    return;
  }

  pthread_mutex_lock(&host->lock);
  memset(host->bans, 0, sizeof(host->bans));
  host->ban_count = 0U;
  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    if (host->ban_count >= SSH_CHATTER_MAX_BANS) {
      break;
    }
    if (entries[idx].ip[0] != '\0' && host_is_protected_ip_unlocked(host, entries[idx].ip)) {
      continue;
    }
    if (entries[idx].ip[0] != '\0' && strchr(entries[idx].ip, '/') != NULL) {
      bool intersects_protected = false;
      for (size_t protected_idx = 0; protected_idx < host->protected_ip_count &&
                                   protected_idx < SSH_CHATTER_MAX_PROTECTED_IPS; ++protected_idx) {
        if (host_cidr_contains_ip(entries[idx].ip, host->protected_ips[protected_idx])) {
          intersects_protected = true;
          break;
        }
      }
      if (intersects_protected) {
        continue;
      }
    }
    snprintf(host->bans[host->ban_count].username, sizeof(host->bans[host->ban_count].username), "%s",
             entries[idx].username);
    snprintf(host->bans[host->ban_count].ip, sizeof(host->bans[host->ban_count].ip), "%s", entries[idx].ip);
    ++host->ban_count;
  }
  pthread_mutex_unlock(&host->lock);

}

static void host_reply_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->reply_state_file_path[0] == '\0') {
    return;
  }

  FILE *fp = fopen(host->reply_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  reply_state_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != REPLY_STATE_MAGIC || header.version == 0U || header.version > REPLY_STATE_VERSION) {
    fclose(fp);
    return;
  }

  uint32_t entry_count = header.entry_count;
  reply_state_entry_t *entries = NULL;
  if (entry_count > 0U) {
    entries = GC_CALLOC(entry_count, sizeof(*entries));
    if (entries == NULL) {
      fclose(fp);
      humanized_log_error("host", "failed to allocate reply state buffer", ENOMEM);
      return;
    }
  }

  bool success = true;
  int read_error = 0;
  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    if (fread(&entries[idx], sizeof(entries[idx]), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        read_error = errno;
      }
      break;
    }
  }

  fclose(fp);

  if (!success) {
    humanized_log_error("host", "failed to read reply state file", read_error != 0 ? read_error : EIO);
    return;
  }

  pthread_mutex_lock(&host->lock);
  memset(host->replies, 0, sizeof(host->replies));
  host->reply_count = 0U;
  host->next_reply_id = header.next_reply_id != 0U ? header.next_reply_id : 1U;
  uint64_t max_reply_id = 0U;

  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    if (host->reply_count >= SSH_CHATTER_MAX_REPLIES) {
      if (entries[idx].reply_id > max_reply_id) {
        max_reply_id = entries[idx].reply_id;
      }
      continue;
    }

    chat_reply_entry_t *slot = &host->replies[host->reply_count];
    memset(slot, 0, sizeof(*slot));
    slot->in_use = true;
    slot->reply_id = entries[idx].reply_id != 0U ? entries[idx].reply_id : (uint64_t)(host->reply_count + 1U);
    if (slot->reply_id > max_reply_id) {
      max_reply_id = slot->reply_id;
    }
    slot->parent_message_id = entries[idx].parent_message_id;
    slot->parent_reply_id = entries[idx].parent_reply_id;
    slot->created_at = (time_t)entries[idx].created_at;
    snprintf(slot->username, sizeof(slot->username), "%s", entries[idx].username);
    snprintf(slot->message, sizeof(slot->message), "%s", entries[idx].message);
    ++host->reply_count;
  }

  if (host->next_reply_id <= max_reply_id) {
    if (max_reply_id == UINT64_MAX) {
      host->next_reply_id = UINT64_MAX;
    } else {
      host->next_reply_id = max_reply_id + 1U;
    }
  }

  if (host->next_reply_id == 0U) {
    host->next_reply_id = (uint64_t)host->reply_count + 1U;
  }

  pthread_mutex_unlock(&host->lock);

}

static void host_eliza_memory_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *memory_path = getenv("CHATTER_ELIZA_MEMORY_FILE");
  if (memory_path == NULL || memory_path[0] == '\0') {
    memory_path = "eliza_memory.dat";
  }

  int written = snprintf(host->eliza_memory_file_path, sizeof(host->eliza_memory_file_path), "%s", memory_path);
  if (written < 0 || (size_t)written >= sizeof(host->eliza_memory_file_path)) {
    humanized_log_error("host", "eliza memory file path is too long", ENAMETOOLONG);
    host->eliza_memory_file_path[0] = '\0';
  }
}

static void host_eliza_memory_save_locked(host_t *host) {
  if (host == NULL || host->eliza_memory_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->eliza_memory_file_path, true)) {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->eliza_memory_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "eliza memory path is too long", ENAMETOOLONG);
    return;
  }

  FILE *fp = fopen(temp_path, "wb");
  if (fp == NULL) {
    humanized_log_error("host", "failed to open eliza memory file", errno != 0 ? errno : EIO);
    return;
  }

  size_t stored = host->eliza_memory_count;
  if (stored > SSH_CHATTER_ELIZA_MEMORY_MAX) {
    stored = SSH_CHATTER_ELIZA_MEMORY_MAX;
  }

  eliza_memory_header_t header = {0};
  header.magic = ELIZA_MEMORY_MAGIC;
  header.version = ELIZA_MEMORY_VERSION;
  header.entry_count = (uint32_t)stored;
  header.next_id = host->eliza_memory_next_id;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;
  int write_error = 0;
  if (!success && errno != 0) {
    write_error = errno;
  }

  for (size_t idx = 0U; success && idx < stored; ++idx) {
    const eliza_memory_entry_t *entry = &host->eliza_memory[idx];
    eliza_memory_entry_serialized_t serialized = {0};
    serialized.id = entry->id;
    serialized.stored_at = (int64_t)entry->stored_at;
    snprintf(serialized.prompt, sizeof(serialized.prompt), "%s", entry->prompt);
    snprintf(serialized.reply, sizeof(serialized.reply), "%s", entry->reply);
    if (fwrite(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
    if (errno != 0) {
      write_error = errno;
    }
  }

  if (success) {
    int fd = fileno(fp);
    if (fd >= 0 && fsync(fd) != 0) {
      success = false;
      if (errno != 0) {
        write_error = errno;
      }
    }
  }

  if (fclose(fp) != 0) {
    if (success && errno != 0) {
      write_error = errno;
    }
    success = false;
  }

  if (!success) {
    unlink(temp_path);
    humanized_log_error("host", "failed to write eliza memory file", write_error != 0 ? write_error : EIO);
    return;
  }

  if (rename(temp_path, host->eliza_memory_file_path) != 0) {
    int rename_error = errno != 0 ? errno : EIO;
    unlink(temp_path);
    humanized_log_error("host", "failed to install eliza memory file", rename_error);
    return;
  }

  if (chmod(host->eliza_memory_file_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to set eliza memory permissions", errno != 0 ? errno : EACCES);
  }
}

static void host_eliza_memory_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->eliza_memory_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->eliza_memory_file_path, false)) {
    return;
  }

  FILE *fp = fopen(host->eliza_memory_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  eliza_memory_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != ELIZA_MEMORY_MAGIC || header.version == 0U || header.version > ELIZA_MEMORY_VERSION) {
    fclose(fp);
    return;
  }

  uint32_t entry_count = header.entry_count;
  eliza_memory_entry_serialized_t *entries = NULL;
  if (entry_count > 0U) {
    entries = GC_CALLOC(entry_count, sizeof(*entries));
    if (entries == NULL) {
      fclose(fp);
      humanized_log_error("host", "failed to allocate eliza memory buffer", ENOMEM);
      return;
    }
  }

  bool success = true;
  int read_error = 0;
  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    if (fread(&entries[idx], sizeof(entries[idx]), 1U, fp) != 1U) {
      success = false;
      if (errno != 0) {
        read_error = errno;
      }
      break;
    }
  }

  fclose(fp);

  if (!success) {
    humanized_log_error("host", "failed to read eliza memory file", read_error != 0 ? read_error : EIO);
    return;
  }

  pthread_mutex_lock(&host->lock);
  memset(host->eliza_memory, 0, sizeof(host->eliza_memory));
  host->eliza_memory_count = 0U;
  host->eliza_memory_next_id = header.next_id != 0U ? header.next_id : 1U;

  uint64_t max_id = 0U;
  for (uint32_t idx = 0U; idx < entry_count; ++idx) {
    uint64_t entry_id = entries[idx].id != 0U ? entries[idx].id : (uint64_t)(idx + 1U);
    if (idx < SSH_CHATTER_ELIZA_MEMORY_MAX) {
      eliza_memory_entry_t *slot = &host->eliza_memory[host->eliza_memory_count++];
      slot->id = entry_id;
      slot->stored_at = (time_t)entries[idx].stored_at;
      snprintf(slot->prompt, sizeof(slot->prompt), "%s", entries[idx].prompt);
      snprintf(slot->reply, sizeof(slot->reply), "%s", entries[idx].reply);
    }
    if (entry_id > max_id) {
      max_id = entry_id;
    }
  }

  if (max_id >= host->eliza_memory_next_id) {
    host->eliza_memory_next_id = (max_id == UINT64_MAX) ? UINT64_MAX : max_id + 1U;
  }
  if (host->eliza_memory_next_id == 0U) {
    host->eliza_memory_next_id = (uint64_t)host->eliza_memory_count + 1U;
  }

  pthread_mutex_unlock(&host->lock);
}

static void host_eliza_memory_store(host_t *host, const char *prompt, const char *reply) {
  if (host == NULL || prompt == NULL || reply == NULL) {
    return;
  }

  char clean_prompt[SSH_CHATTER_MESSAGE_LIMIT];
  char clean_reply[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(clean_prompt, sizeof(clean_prompt), "%s", prompt);
  snprintf(clean_reply, sizeof(clean_reply), "%s", reply);
  trim_whitespace_inplace(clean_prompt);
  trim_whitespace_inplace(clean_reply);

  pthread_mutex_lock(&host->lock);
  if (host->eliza_memory_count >= SSH_CHATTER_ELIZA_MEMORY_MAX) {
    memmove(host->eliza_memory, host->eliza_memory + 1,
            (SSH_CHATTER_ELIZA_MEMORY_MAX - 1U) * sizeof(host->eliza_memory[0]));
    host->eliza_memory_count = SSH_CHATTER_ELIZA_MEMORY_MAX - 1U;
  }

  eliza_memory_entry_t *entry = &host->eliza_memory[host->eliza_memory_count++];
  if (host->eliza_memory_next_id == 0U) {
    host->eliza_memory_next_id = 1U;
  }
  entry->id = host->eliza_memory_next_id;
  if (host->eliza_memory_next_id < UINT64_MAX) {
    host->eliza_memory_next_id += 1U;
  }
  entry->stored_at = time(NULL);
  snprintf(entry->prompt, sizeof(entry->prompt), "%s", clean_prompt);
  snprintf(entry->reply, sizeof(entry->reply), "%s", clean_reply);

  host_eliza_memory_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static size_t host_eliza_memory_collect_tokens(const char *prompt, char tokens[][32], size_t max_tokens) {
  if (tokens == NULL || max_tokens == 0U || prompt == NULL) {
    return 0U;
  }

  size_t count = 0U;
  size_t length = strlen(prompt);
  size_t idx = 0U;
  while (idx < length && count < max_tokens) {
    while (idx < length && isspace((unsigned char)prompt[idx])) {
      ++idx;
    }
    if (idx >= length) {
      break;
    }

    size_t token_idx = 0U;
    char buffer[32];
    while (idx < length && !isspace((unsigned char)prompt[idx])) {
      unsigned char ch = (unsigned char)prompt[idx];
      if (token_idx + 1U < sizeof(buffer)) {
        buffer[token_idx++] = (ch < 0x80U) ? (char)tolower(ch) : (char)ch;
      }
      ++idx;
    }
    buffer[token_idx] = '\0';

    if (token_idx == 0U) {
      continue;
    }
    if (token_idx < 3U && (unsigned char)buffer[0] < 0x80U) {
      continue;
    }

    bool duplicate = false;
    for (size_t existing = 0U; existing < count; ++existing) {
      if (strcmp(tokens[existing], buffer) == 0) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      continue;
    }

    snprintf(tokens[count], 32U, "%s", buffer);
    ++count;
  }

  return count;
}

static size_t host_eliza_memory_collect_context(host_t *host, const char *prompt, char *context,
                                                size_t context_length) {
  if (context == NULL || context_length == 0U) {
    return 0U;
  }

  context[0] = '\0';
  if (host == NULL || prompt == NULL) {
    return 0U;
  }

  eliza_memory_entry_t snapshot[SSH_CHATTER_ELIZA_MEMORY_MAX];
  size_t snapshot_count = 0U;

  pthread_mutex_lock(&host->lock);
  snapshot_count = host->eliza_memory_count;
  if (snapshot_count > SSH_CHATTER_ELIZA_MEMORY_MAX) {
    snapshot_count = SSH_CHATTER_ELIZA_MEMORY_MAX;
  }
  if (snapshot_count > 0U) {
    memcpy(snapshot, host->eliza_memory, snapshot_count * sizeof(snapshot[0]));
  }
  pthread_mutex_unlock(&host->lock);

  if (snapshot_count == 0U) {
    return 0U;
  }

  char tokens[SSH_CHATTER_ELIZA_TOKEN_LIMIT][32];
  size_t token_count = host_eliza_memory_collect_tokens(prompt, tokens, SSH_CHATTER_ELIZA_TOKEN_LIMIT);

  size_t best_indices[SSH_CHATTER_ELIZA_CONTEXT_LIMIT] = {0U};
  size_t best_scores[SSH_CHATTER_ELIZA_CONTEXT_LIMIT] = {0U};
  size_t best_count = 0U;

  for (size_t idx = 0U; idx < snapshot_count; ++idx) {
    const eliza_memory_entry_t *entry = &snapshot[idx];
    size_t score = 0U;

    if (token_count > 0U) {
      for (size_t token_idx = 0U; token_idx < token_count; ++token_idx) {
        if (tokens[token_idx][0] == '\0') {
          continue;
        }
        if (string_contains_case_insensitive(entry->prompt, tokens[token_idx]) ||
            string_contains_case_insensitive(entry->reply, tokens[token_idx])) {
          ++score;
        }
      }

      if (score == 0U) {
        continue;
      }
    }

    size_t recency_bonus = snapshot_count - idx;
    if (recency_bonus > 4U) {
      recency_bonus = 4U;
    }
    score += recency_bonus;

    size_t insert_pos = best_count;
    if (best_count < SSH_CHATTER_ELIZA_CONTEXT_LIMIT) {
      ++best_count;
    } else if (score <= best_scores[SSH_CHATTER_ELIZA_CONTEXT_LIMIT - 1U]) {
      continue;
    } else {
      insert_pos = SSH_CHATTER_ELIZA_CONTEXT_LIMIT - 1U;
    }

    while (insert_pos > 0U && score > best_scores[insert_pos - 1U]) {
      if (insert_pos < SSH_CHATTER_ELIZA_CONTEXT_LIMIT) {
        best_scores[insert_pos] = best_scores[insert_pos - 1U];
        best_indices[insert_pos] = best_indices[insert_pos - 1U];
      }
      --insert_pos;
    }

    best_scores[insert_pos] = score;
    best_indices[insert_pos] = idx;
  }

  if (best_count == 0U && token_count == 0U) {
    size_t fallback = snapshot_count < SSH_CHATTER_ELIZA_CONTEXT_LIMIT ? snapshot_count : SSH_CHATTER_ELIZA_CONTEXT_LIMIT;
    for (size_t idx = 0U; idx < fallback; ++idx) {
      best_indices[idx] = snapshot_count - idx - 1U;
    }
    best_count = fallback;
  }

  if (best_count == 0U) {
    return 0U;
  }

  size_t offset = 0U;
  for (size_t idx = 0U; idx < best_count; ++idx) {
    const eliza_memory_entry_t *entry = &snapshot[best_indices[idx]];
    char time_buffer[32];
    time_buffer[0] = '\0';
    if (entry->stored_at != 0) {
      struct tm tm_value;
      if (localtime_r(&entry->stored_at, &tm_value) != NULL) {
        strftime(time_buffer, sizeof(time_buffer), "%Y-%m-%d %H:%M", &tm_value);
      }
    }
    if (time_buffer[0] == '\0') {
      snprintf(time_buffer, sizeof(time_buffer), "-");
    }

    char block[SSH_CHATTER_MESSAGE_LIMIT * 2];
    int written = snprintf(block, sizeof(block), "%s- [%s] user: %s\n  eliza: %s", idx == 0U ? "" : "\n",
                           time_buffer,
                           entry->prompt[0] != '\0' ? entry->prompt : "(empty)",
                           entry->reply[0] != '\0' ? entry->reply : "(empty)");
    if (written < 0) {
      continue;
    }

    size_t block_len = (size_t)written;
    if (block_len >= sizeof(block)) {
      block_len = sizeof(block) - 1U;
      block[block_len] = '\0';
    }

    if (offset + block_len >= context_length) {
      size_t available = (offset < context_length) ? context_length - offset - 1U : 0U;
      if (available > 0U) {
        memcpy(context + offset, block, available);
        offset += available;
        context[offset] = '\0';
      }
      break;
    }

    memcpy(context + offset, block, block_len);
    offset += block_len;
    context[offset] = '\0';
  }

  return best_count;
}

static void host_eliza_history_normalize_line(char *text) {
  if (text == NULL) {
    return;
  }

  size_t read_index = 0U;
  size_t write_index = 0U;
  bool last_was_space = true;

  while (text[read_index] != '\0') {
    unsigned char ch = (unsigned char)text[read_index++];
    if (ch < 0x20U || ch == 0x7FU) {
      ch = ' ';
    }

    if (ch == ' ') {
      if (last_was_space) {
        continue;
      }
      text[write_index++] = ' ';
      last_was_space = true;
      continue;
    }

    text[write_index++] = (char)ch;
    last_was_space = false;
  }

  if (write_index > 0U && text[write_index - 1U] == ' ') {
    --write_index;
  }

  text[write_index] = '\0';
}

static size_t host_eliza_history_collect_context(host_t *host, char *context, size_t context_length) {
  if (context == NULL || context_length == 0U) {
    return 0U;
  }

  context[0] = '\0';
  if (host == NULL) {
    return 0U;
  }

  size_t total = host_history_total(host);
  if (total == 0U) {
    return 0U;
  }

  size_t start_index = 0U;
  if (total > SSH_CHATTER_ELIZA_HISTORY_WINDOW) {
    start_index = total - SSH_CHATTER_ELIZA_HISTORY_WINDOW;
  }

  chat_history_entry_t snapshot[SSH_CHATTER_ELIZA_HISTORY_WINDOW];
  size_t retrieved = host_history_copy_range(host, start_index, snapshot, SSH_CHATTER_ELIZA_HISTORY_WINDOW);
  if (retrieved == 0U) {
    return 0U;
  }

  char messages[SSH_CHATTER_ELIZA_HISTORY_LIMIT][SSH_CHATTER_MESSAGE_LIMIT];
  char names[SSH_CHATTER_ELIZA_HISTORY_LIMIT][SSH_CHATTER_USERNAME_LEN];
  size_t collected = 0U;

  for (size_t idx = 0U; idx < retrieved && collected < SSH_CHATTER_ELIZA_HISTORY_LIMIT; ++idx) {
    size_t current = retrieved - idx - 1U;
    const chat_history_entry_t *entry = &snapshot[current];
    if (!entry->is_user_message) {
      continue;
    }

    char working[SSH_CHATTER_MESSAGE_LIMIT * 2U];
    working[0] = '\0';
    if (entry->message[0] != '\0') {
      snprintf(working, sizeof(working), "%s", entry->message);
    } else if (entry->attachment_type != CHAT_ATTACHMENT_NONE) {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      snprintf(working, sizeof(working), "shared a %s", label != NULL ? label : "attachment");
    }

    if (entry->attachment_caption[0] != '\0') {
      size_t existing = strnlen(working, sizeof(working));
      if (existing < sizeof(working) - 1U) {
        int appended = snprintf(working + existing, sizeof(working) - existing, "%s(caption: %s)",
                                existing > 0U ? " " : "", entry->attachment_caption);
        if (appended < 0) {
          working[existing] = '\0';
        }
      }
    } else if (entry->attachment_type != CHAT_ATTACHMENT_NONE && entry->attachment_target[0] != '\0') {
      size_t existing = strnlen(working, sizeof(working));
      if (existing < sizeof(working) - 1U) {
        int appended = snprintf(working + existing, sizeof(working) - existing, "%s(link shared)",
                                existing > 0U ? " " : "");
        if (appended < 0) {
          working[existing] = '\0';
        }
      }
    }

    host_eliza_history_normalize_line(working);
    trim_whitespace_inplace(working);

    if (working[0] == '\0') {
      continue;
    }

    snprintf(messages[collected], sizeof(messages[collected]), "%s", working);
    if (entry->username[0] != '\0') {
      snprintf(names[collected], sizeof(names[collected]), "%s", entry->username);
    } else {
      snprintf(names[collected], sizeof(names[collected]), "%s", "unknown");
    }
    ++collected;
  }

  if (collected == 0U) {
    return 0U;
  }

  size_t offset = 0U;
  for (size_t idx = 0U; idx < collected; ++idx) {
    size_t source = collected - idx - 1U;
    const char *name = names[source][0] != '\0' ? names[source] : "unknown";
    const char *message = messages[source];

    char line[SSH_CHATTER_MESSAGE_LIMIT * 2U];
    int written = snprintf(line, sizeof(line), "%s- [%s] %s", offset == 0U ? "" : "\n", name, message);
    if (written < 0) {
      continue;
    }

    size_t line_length = (size_t)written;
    if (line_length >= sizeof(line)) {
      line_length = sizeof(line) - 1U;
      line[line_length] = '\0';
    }

    size_t remaining = (offset < context_length) ? context_length - offset : 0U;
    if (remaining <= 1U) {
      context[context_length - 1U] = '\0';
      break;
    }

    size_t max_append = remaining - 1U;
    if (line_length > max_append) {
      memcpy(context + offset, line, max_append);
      offset += max_append;
      context[offset] = '\0';
      break;
    }

    memcpy(context + offset, line, line_length);
    offset += line_length;
    context[offset] = '\0';
  }

  return collected;
}

static void host_eliza_prepare_preview(const char *source, char *dest, size_t dest_length) {
  if (dest == NULL || dest_length == 0U) {
    return;
  }

  dest[0] = '\0';
  if (source == NULL || source[0] == '\0') {
    return;
  }

  size_t copy_length = strnlen(source, dest_length);
  bool truncated = false;
  if (copy_length >= dest_length) {
    copy_length = dest_length - 1U;
    truncated = true;
  }

  memcpy(dest, source, copy_length);
  dest[copy_length] = '\0';

  host_eliza_history_normalize_line(dest);
  trim_whitespace_inplace(dest);

  if (truncated && dest_length > 4U) {
    size_t length = strnlen(dest, dest_length);
    if (length + 3U < dest_length) {
      dest[length++] = '.';
      dest[length++] = '.';
      dest[length++] = '.';
      dest[length] = '\0';
    }
  }
}

static size_t host_eliza_bbs_collect_context(host_t *host, char *context, size_t context_length) {
  if (context == NULL || context_length == 0U) {
    return 0U;
  }

  context[0] = '\0';
  if (host == NULL) {
    return 0U;
  }

  bbs_post_t snapshot[SSH_CHATTER_BBS_MAX_POSTS];
  size_t snapshot_count = 0U;

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (!host->bbs_posts[idx].in_use) {
      continue;
    }

    if (snapshot_count < SSH_CHATTER_BBS_MAX_POSTS) {
      snapshot[snapshot_count++] = host->bbs_posts[idx];
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (snapshot_count == 0U) {
    return 0U;
  }

  for (size_t idx = 0U; idx + 1U < snapshot_count; ++idx) {
    size_t best = idx;
    time_t best_time = snapshot[idx].bumped_at != 0 ? snapshot[idx].bumped_at : snapshot[idx].created_at;
    for (size_t scan = idx + 1U; scan < snapshot_count; ++scan) {
      time_t candidate = snapshot[scan].bumped_at != 0 ? snapshot[scan].bumped_at : snapshot[scan].created_at;
      if (candidate > best_time) {
        best = scan;
        best_time = candidate;
      }
    }
    if (best != idx) {
      bbs_post_t temp = snapshot[idx];
      snapshot[idx] = snapshot[best];
      snapshot[best] = temp;
    }
  }

  size_t limit = snapshot_count;
  if (limit > SSH_CHATTER_ELIZA_BBS_CONTEXT_LIMIT) {
    limit = SSH_CHATTER_ELIZA_BBS_CONTEXT_LIMIT;
  }

  size_t offset = 0U;
  size_t appended_count = 0U;
  for (size_t idx = 0U; idx < limit; ++idx) {
    const bbs_post_t *post = &snapshot[idx];

    char title[SSH_CHATTER_BBS_TITLE_LEN];
    snprintf(title, sizeof(title), "%s", post->title[0] != '\0' ? post->title : "(untitled)");
    host_eliza_history_normalize_line(title);
    trim_whitespace_inplace(title);

    char tags_buffer[SSH_CHATTER_BBS_MAX_TAGS * (SSH_CHATTER_BBS_TAG_LEN + 2U)];
    size_t tags_offset = 0U;
    tags_buffer[0] = '\0';
    for (size_t tag = 0U; tag < post->tag_count && tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
      if (post->tags[tag][0] == '\0') {
        continue;
      }
      if (tags_offset + 1U < sizeof(tags_buffer)) {
        if (tags_offset > 0U) {
          tags_buffer[tags_offset++] = ',';
        }
        size_t remaining = sizeof(tags_buffer) - tags_offset;
        size_t tag_length = strnlen(post->tags[tag], remaining);
        if (tag_length >= remaining) {
          tag_length = remaining - 1U;
        }
        memcpy(tags_buffer + tags_offset, post->tags[tag], tag_length);
        tags_offset += tag_length;
        tags_buffer[tags_offset] = '\0';
      }
    }

    char body_preview[SSH_CHATTER_ELIZA_BBS_PREVIEW_LEN];
    host_eliza_prepare_preview(post->body, body_preview, sizeof(body_preview));

    char comment_preview[SSH_CHATTER_ELIZA_BBS_PREVIEW_LEN];
    comment_preview[0] = '\0';
    char comment_author[SSH_CHATTER_USERNAME_LEN];
    comment_author[0] = '\0';
    if (post->comment_count > 0U) {
      const bbs_comment_t *comment = &post->comments[post->comment_count - 1U];
      host_eliza_prepare_preview(comment->text, comment_preview, sizeof(comment_preview));
      snprintf(comment_author, sizeof(comment_author), "%s", comment->author[0] != '\0' ? comment->author : "(anonymous)");
      host_eliza_history_normalize_line(comment_author);
      trim_whitespace_inplace(comment_author);
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    size_t line_offset = 0U;
    int written = snprintf(line, sizeof(line), "%s- [#%" PRIu64 " %s] %s",
                           idx == 0U ? "" : "\n",
                           post->id,
                           post->author[0] != '\0' ? post->author : "(unknown)",
                           title[0] != '\0' ? title : "(untitled)");
    if (written < 0) {
      continue;
    }

    line_offset = (size_t)written;
    if (line_offset >= sizeof(line)) {
      line_offset = sizeof(line) - 1U;
      line[line_offset] = '\0';
    }

    if (tags_buffer[0] != '\0' && line_offset + 1U < sizeof(line)) {
      int appended = snprintf(line + line_offset, sizeof(line) - line_offset, " | tags: %s", tags_buffer);
      if (appended > 0) {
        size_t used = (size_t)appended;
        if (used >= sizeof(line) - line_offset) {
          line_offset = sizeof(line) - 1U;
          line[line_offset] = '\0';
        } else {
          line_offset += used;
        }
      }
    }

    if (body_preview[0] != '\0' && line_offset + 1U < sizeof(line)) {
      int appended = snprintf(line + line_offset, sizeof(line) - line_offset, " | body: %s", body_preview);
      if (appended > 0) {
        size_t used = (size_t)appended;
        if (used >= sizeof(line) - line_offset) {
          line_offset = sizeof(line) - 1U;
          line[line_offset] = '\0';
        } else {
          line_offset += used;
        }
      }
    }

    if (comment_preview[0] != '\0' && line_offset + 1U < sizeof(line)) {
      const char *author_label = comment_author[0] != '\0' ? comment_author : "(anonymous)";
      int appended = snprintf(line + line_offset, sizeof(line) - line_offset, " | last comment by %s: %s", author_label,
                               comment_preview);
      if (appended > 0) {
        size_t used = (size_t)appended;
        if (used >= sizeof(line) - line_offset) {
          line_offset = sizeof(line) - 1U;
          line[line_offset] = '\0';
        } else {
          line_offset += used;
        }
      }
    }

    size_t remaining = (offset < context_length) ? context_length - offset : 0U;
    if (remaining <= 1U) {
      context[context_length - 1U] = '\0';
      break;
    }

    size_t max_copy = remaining - 1U;
    size_t copy_len = strnlen(line, sizeof(line));
    if (copy_len > max_copy) {
      memcpy(context + offset, line, max_copy);
      offset += max_copy;
      context[offset] = '\0';
      ++appended_count;
      break;
    }

    memcpy(context + offset, line, copy_len);
    offset += copy_len;
    context[offset] = '\0';
    ++appended_count;
  }

  if (context[0] == '\0') {
    return 0U;
  }

  if (appended_count == 0U) {
    return 0U;
  }

  return appended_count;
}

static void host_bbs_resolve_path(host_t *host) {
  if (host == NULL) {
    return;
  }

  const char *bbs_path = getenv("CHATTER_BBS_FILE");
  if (bbs_path == NULL || bbs_path[0] == '\0') {
    bbs_path = "bbs_state.dat";
  }

  int written = snprintf(host->bbs_state_file_path, sizeof(host->bbs_state_file_path), "%s", bbs_path);
  if (written < 0 || (size_t)written >= sizeof(host->bbs_state_file_path)) {
    humanized_log_error("host", "bbs state file path is too long", ENAMETOOLONG);
    host->bbs_state_file_path[0] = '\0';
  }
}

static size_t host_column_reset_sequence_length(const char *text) {
  if (text == NULL) {
    return 0U;
  }

  if (text[0] == '\033' && text[1] == '[' && text[2] == '1' && text[3] == 'G') {
    return 4U;
  }

  if (text[0] == '[' && text[1] == '1' && text[2] == 'G') {
    return 3U;
  }

  return 0U;
}

static bool host_contains_column_reset(const char *text) {
  if (text == NULL) {
    return false;
  }

  while (*text != '\0') {
    if (host_column_reset_sequence_length(text) > 0U) {
      return true;
    }
    ++text;
  }

  return false;
}

static void host_strip_column_reset(char *text) {
  if (text == NULL || text[0] == '\0') {
    return;
  }

  char *dst = text;
  const char *src = text;
  while (*src != '\0') {
    size_t skip = host_column_reset_sequence_length(src);
    if (skip > 0U) {
      src += skip;
      continue;
    }

    *dst++ = *src++;
  }

  *dst = '\0';
}

static void host_bbs_state_save_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->bbs_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->bbs_state_file_path, true)) {
    return;
  }

  char temp_path[PATH_MAX];
  int written = snprintf(temp_path, sizeof(temp_path), "%s.tmp", host->bbs_state_file_path);
  if (written < 0 || (size_t)written >= sizeof(temp_path)) {
    humanized_log_error("host", "bbs state file path is too long", ENAMETOOLONG);
    return;
  }

  int temp_fd = open(temp_path, O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW, S_IRUSR | S_IWUSR);
  if (temp_fd < 0) {
    humanized_log_error("host", "failed to open bbs state file", errno != 0 ? errno : EIO);
    return;
  }

  FILE *fp = fdopen(temp_fd, "wb");
  if (fp == NULL) {
    int saved_errno = errno;
    close(temp_fd);
    unlink(temp_path);
    humanized_log_error("host", "failed to wrap bbs state descriptor", saved_errno != 0 ? saved_errno : EIO);
    return;
  }

  uint32_t post_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (host->bbs_posts[idx].in_use) {
      ++post_count;
    }
  }

  bbs_state_header_t header = {0};
  header.magic = BBS_STATE_MAGIC;
  header.version = BBS_STATE_VERSION;
  header.post_count = post_count;
  header.next_id = host->next_bbs_id;

  bool success = fwrite(&header, sizeof(header), 1U, fp) == 1U;

  for (size_t idx = 0U; success && idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    const bbs_post_t *post = &host->bbs_posts[idx];
    if (!post->in_use) {
      continue;
    }

    bbs_state_post_entry_t serialized = {0};
    serialized.id = post->id;
    serialized.created_at = (int64_t)post->created_at;
    serialized.bumped_at = (int64_t)post->bumped_at;
    serialized.tag_count = (uint32_t)post->tag_count;
    if (serialized.tag_count > SSH_CHATTER_BBS_MAX_TAGS) {
      serialized.tag_count = SSH_CHATTER_BBS_MAX_TAGS;
    }
    serialized.comment_count = (uint32_t)post->comment_count;
    if (serialized.comment_count > SSH_CHATTER_BBS_MAX_COMMENTS) {
      serialized.comment_count = SSH_CHATTER_BBS_MAX_COMMENTS;
    }

    snprintf(serialized.author, sizeof(serialized.author), "%s", post->author);
    snprintf(serialized.title, sizeof(serialized.title), "%s", post->title);
    snprintf(serialized.body, sizeof(serialized.body), "%s", post->body);

    for (size_t tag = 0U; tag < serialized.tag_count; ++tag) {
      snprintf(serialized.tags[tag], sizeof(serialized.tags[tag]), "%s", post->tags[tag]);
    }

    for (size_t comment = 0U; comment < serialized.comment_count; ++comment) {
      snprintf(serialized.comments[comment].author, sizeof(serialized.comments[comment].author), "%s",
               post->comments[comment].author);
      snprintf(serialized.comments[comment].text, sizeof(serialized.comments[comment].text), "%s",
               post->comments[comment].text);
      serialized.comments[comment].created_at = (int64_t)post->comments[comment].created_at;
    }

    if (fwrite(&serialized, sizeof(serialized), 1U, fp) != 1U) {
      success = false;
      break;
    }
  }

  if (success && fflush(fp) != 0) {
    success = false;
  }

  if (success) {
    int file_descriptor = fileno(fp);
    if (file_descriptor >= 0 && fsync(file_descriptor) != 0) {
      success = false;
    }
  }

  if (fclose(fp) != 0) {
    success = false;
  }

  if (!success) {
    humanized_log_error("host", "failed to write bbs state file", errno);
    unlink(temp_path);
    return;
  }

  if (chmod(temp_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to tighten temporary bbs state permissions", errno != 0 ? errno : EACCES);
    unlink(temp_path);
    return;
  }

  if (rename(temp_path, host->bbs_state_file_path) != 0) {
    humanized_log_error("host", "failed to update bbs state file", errno);
    unlink(temp_path);
  } else if (chmod(host->bbs_state_file_path, S_IRUSR | S_IWUSR) != 0) {
    humanized_log_error("host", "failed to tighten bbs state permissions", errno != 0 ? errno : EACCES);
  }
}

static void host_bbs_state_load(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->bbs_state_file_path[0] == '\0') {
    return;
  }

  if (!host_ensure_private_data_path(host, host->bbs_state_file_path, false)) {
    return;
  }

  FILE *fp = fopen(host->bbs_state_file_path, "rb");
  if (fp == NULL) {
    return;
  }

  bbs_state_header_t header = {0};
  if (fread(&header, sizeof(header), 1U, fp) != 1U) {
    fclose(fp);
    return;
  }

  if (header.magic != BBS_STATE_MAGIC) {
    fclose(fp);
    return;
  }

  if (header.version == 0U || header.version > BBS_STATE_VERSION) {
    fclose(fp);
    return;
  }

  pthread_mutex_lock(&host->lock);

  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    host->bbs_posts[idx].in_use = false;
    host->bbs_posts[idx].id = 0U;
    host->bbs_posts[idx].author[0] = '\0';
    host->bbs_posts[idx].title[0] = '\0';
    host->bbs_posts[idx].body[0] = '\0';
    host->bbs_posts[idx].tag_count = 0U;
    host->bbs_posts[idx].created_at = 0;
    host->bbs_posts[idx].bumped_at = 0;
    host->bbs_posts[idx].comment_count = 0U;
    for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
      host->bbs_posts[idx].comments[comment].author[0] = '\0';
      host->bbs_posts[idx].comments[comment].text[0] = '\0';
      host->bbs_posts[idx].comments[comment].created_at = 0;
    }
  }
  host->bbs_post_count = 0U;

  uint64_t max_id = 0U;
  bool success = true;

  for (uint32_t idx = 0U; idx < header.post_count; ++idx) {
    bbs_state_post_entry_t serialized = {0};
    if (header.version == 1U) {
      bbs_state_post_entry_v1_t legacy = {0};
      if (fread(&legacy, sizeof(legacy), 1U, fp) != 1U) {
        success = false;
        break;
      }

      serialized.id = legacy.id;
      serialized.created_at = legacy.created_at;
      serialized.bumped_at = legacy.bumped_at;
      serialized.tag_count = legacy.tag_count;
      serialized.comment_count = legacy.comment_count;
      snprintf(serialized.author, sizeof(serialized.author), "%s", legacy.author);
      snprintf(serialized.title, sizeof(serialized.title), "%s", legacy.title);
      snprintf(serialized.body, sizeof(serialized.body), "%s", legacy.body);
      for (size_t tag = 0U; tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
        snprintf(serialized.tags[tag], sizeof(serialized.tags[tag]), "%s", legacy.tags[tag]);
      }
      for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
        snprintf(serialized.comments[comment].author, sizeof(serialized.comments[comment].author), "%s",
                 legacy.comments[comment].author);
        snprintf(serialized.comments[comment].text, sizeof(serialized.comments[comment].text), "%s",
                 legacy.comments[comment].text);
        serialized.comments[comment].created_at = legacy.comments[comment].created_at;
      }
    } else if (header.version == 2U) {
      bbs_state_post_entry_v2_t legacy = {0};
      if (fread(&legacy, sizeof(legacy), 1U, fp) != 1U) {
        success = false;
        break;
      }

      serialized.id = legacy.id;
      serialized.created_at = legacy.created_at;
      serialized.bumped_at = legacy.bumped_at;
      serialized.tag_count = legacy.tag_count;
      serialized.comment_count = legacy.comment_count;
      snprintf(serialized.author, sizeof(serialized.author), "%s", legacy.author);
      snprintf(serialized.title, sizeof(serialized.title), "%s", legacy.title);
      snprintf(serialized.body, sizeof(serialized.body), "%s", legacy.body);
      for (size_t tag = 0U; tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
        snprintf(serialized.tags[tag], sizeof(serialized.tags[tag]), "%s", legacy.tags[tag]);
      }
      for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
        snprintf(serialized.comments[comment].author, sizeof(serialized.comments[comment].author), "%s",
                 legacy.comments[comment].author);
        snprintf(serialized.comments[comment].text, sizeof(serialized.comments[comment].text), "%s",
                 legacy.comments[comment].text);
        serialized.comments[comment].created_at = legacy.comments[comment].created_at;
      }
    } else if (header.version == 3U) {
      bbs_state_post_entry_v3_t legacy = {0};
      if (fread(&legacy, sizeof(legacy), 1U, fp) != 1U) {
        success = false;
        break;
      }

      serialized.id = legacy.id;
      serialized.created_at = legacy.created_at;
      serialized.bumped_at = legacy.bumped_at;
      serialized.tag_count = legacy.tag_count;
      serialized.comment_count = legacy.comment_count;
      snprintf(serialized.author, sizeof(serialized.author), "%s", legacy.author);
      snprintf(serialized.title, sizeof(serialized.title), "%s", legacy.title);
      snprintf(serialized.body, sizeof(serialized.body), "%s", legacy.body);
      for (size_t tag = 0U; tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
        snprintf(serialized.tags[tag], sizeof(serialized.tags[tag]), "%s", legacy.tags[tag]);
      }
      for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
        snprintf(serialized.comments[comment].author, sizeof(serialized.comments[comment].author), "%s",
                 legacy.comments[comment].author);
        snprintf(serialized.comments[comment].text, sizeof(serialized.comments[comment].text), "%s",
                 legacy.comments[comment].text);
        serialized.comments[comment].created_at = legacy.comments[comment].created_at;
      }
    } else {
      if (fread(&serialized, sizeof(serialized), 1U, fp) != 1U) {
        success = false;
        break;
      }
    }

    if (serialized.id > max_id) {
      max_id = serialized.id;
    }

    if (idx >= SSH_CHATTER_BBS_MAX_POSTS) {
      continue;
    }

    bbs_post_t *post = &host->bbs_posts[host->bbs_post_count];
    memset(post, 0, sizeof(*post));
    post->in_use = true;
    post->id = serialized.id;
    post->created_at = (time_t)serialized.created_at;
    post->bumped_at = (time_t)serialized.bumped_at;
    snprintf(post->author, sizeof(post->author), "%s", serialized.author);
    snprintf(post->title, sizeof(post->title), "%s", serialized.title);
    snprintf(post->body, sizeof(post->body), "%s", serialized.body);
    host_strip_column_reset(post->author);
    host_strip_column_reset(post->title);
    host_strip_column_reset(post->body);

    size_t tag_limit = serialized.tag_count;
    if (tag_limit > SSH_CHATTER_BBS_MAX_TAGS) {
      tag_limit = SSH_CHATTER_BBS_MAX_TAGS;
    }
    post->tag_count = tag_limit;
    for (size_t tag = 0U; tag < tag_limit; ++tag) {
      snprintf(post->tags[tag], sizeof(post->tags[tag]), "%s", serialized.tags[tag]);
      host_strip_column_reset(post->tags[tag]);
    }

    size_t comment_limit = serialized.comment_count;
    if (comment_limit > SSH_CHATTER_BBS_MAX_COMMENTS) {
      comment_limit = SSH_CHATTER_BBS_MAX_COMMENTS;
    }
    post->comment_count = comment_limit;
    for (size_t comment = 0U; comment < comment_limit; ++comment) {
      snprintf(post->comments[comment].author, sizeof(post->comments[comment].author), "%s",
               serialized.comments[comment].author);
      snprintf(post->comments[comment].text, sizeof(post->comments[comment].text), "%s",
               serialized.comments[comment].text);
      post->comments[comment].created_at = (time_t)serialized.comments[comment].created_at;
      host_strip_column_reset(post->comments[comment].author);
      host_strip_column_reset(post->comments[comment].text);
    }

    ++host->bbs_post_count;
  }

  if (success) {
    host->next_bbs_id = header.next_id;
    if (host->next_bbs_id == 0U || host->next_bbs_id <= max_id) {
      host->next_bbs_id = max_id + 1U;
    }
  } else {
    for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
      host->bbs_posts[idx].in_use = false;
      host->bbs_posts[idx].id = 0U;
      host->bbs_posts[idx].author[0] = '\0';
      host->bbs_posts[idx].title[0] = '\0';
      host->bbs_posts[idx].body[0] = '\0';
      host->bbs_posts[idx].tag_count = 0U;
      host->bbs_posts[idx].created_at = 0;
      host->bbs_posts[idx].bumped_at = 0;
      host->bbs_posts[idx].comment_count = 0U;
      for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
        host->bbs_posts[idx].comments[comment].author[0] = '\0';
        host->bbs_posts[idx].comments[comment].text[0] = '\0';
        host->bbs_posts[idx].comments[comment].created_at = 0;
      }
    }
    host->bbs_post_count = 0U;
    host->next_bbs_id = 1U;
  }

  pthread_mutex_unlock(&host->lock);
  fclose(fp);
}

static void host_bbs_watchdog_scan(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (!atomic_load(&host->eliza_enabled)) {
    return;
  }

  if (!atomic_load(&host->security_ai_enabled)) {
    return;
  }

  bbs_post_t *snapshot = GC_CALLOC(SSH_CHATTER_BBS_MAX_POSTS, sizeof(*snapshot));
  if (snapshot == NULL) {
    humanized_log_error("bbs", "failed to allocate watchdog snapshot", ENOMEM);
    return;
  }

  size_t snapshot_count = 0U;

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (!host->bbs_posts[idx].in_use) {
      continue;
    }

    if (snapshot_count < SSH_CHATTER_BBS_MAX_POSTS) {
      snapshot[snapshot_count++] = host->bbs_posts[idx];
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (snapshot_count == 0U) {
    return;
  }

  const size_t content_capacity =
      SSH_CHATTER_BBS_BODY_LEN + (SSH_CHATTER_BBS_COMMENT_LEN * SSH_CHATTER_BBS_MAX_COMMENTS) + 1024U;
  char *content = (char *)GC_MALLOC(content_capacity);
  if (content == NULL) {
    humanized_log_error("bbs", "failed to allocate watchdog buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0U; idx < snapshot_count; ++idx) {
    const bbs_post_t *post = &snapshot[idx];

    int written = snprintf(content, content_capacity,
                          "Title: %s\nTags: ",
                          post->title[0] != '\0' ? post->title : "(untitled)");
    if (written < 0) {
      continue;
    }

    size_t offset = (size_t)written;
    if (offset >= content_capacity) {
      offset = content_capacity - 1U;
    }

    for (size_t tag = 0U; tag < post->tag_count; ++tag) {
      const char *prefix = (tag == 0U) ? "" : ",";
      int tag_written = snprintf(content + offset, content_capacity - offset, "%s%s", prefix,
                                 post->tags[tag]);
      if (tag_written < 0) {
        break;
      }
      offset += (size_t)tag_written;
      if (offset >= content_capacity) {
        offset = content_capacity - 1U;
        break;
      }
    }

    if (offset + 2U < content_capacity) {
      content[offset++] = '\n';
      content[offset++] = '\n';
      content[offset] = '\0';
    } else {
      content[content_capacity - 1U] = '\0';
      offset = content_capacity - 1U;
    }

    int body_written = snprintf(content + offset, content_capacity - offset,
                                "Body:\n%s",
                                post->body[0] != '\0' ? post->body : "(empty)");
    if (body_written < 0) {
      continue;
    }
    offset += (size_t)body_written;
    if (offset >= content_capacity) {
      offset = content_capacity - 1U;
    }

    for (size_t comment = 0U; comment < post->comment_count; ++comment) {
      if (offset + 2U >= content_capacity) {
        break;
      }
      content[offset++] = '\n';
      content[offset++] = '\n';
      content[offset] = '\0';

      const bbs_comment_t *entry = &post->comments[comment];
      int comment_written = snprintf(content + offset, content_capacity - offset,
                                     "Comment by %s:\n%s",
                                     entry->author[0] != '\0' ? entry->author : "(anonymous)",
                                     entry->text[0] != '\0' ? entry->text : "(empty)");
      if (comment_written < 0) {
        break;
      }
      offset += (size_t)comment_written;
      if (offset >= content_capacity) {
        offset = content_capacity - 1U;
        break;
      }
    }

    bool blocked = false;
    char reason[256];
    reason[0] = '\0';
    if (!translator_moderate_text("bbs_post", content, &blocked, reason, sizeof(reason))) {
      const char *error = translator_last_error();
      if (error != NULL && error[0] != '\0') {
        printf("[bbs] moderation unavailable for post #%" PRIu64 ": %s\n", post->id, error);
      } else {
        printf("[bbs] moderation unavailable for post #%" PRIu64 "\n", post->id);
      }
      break;
    }

    if (!blocked) {
      continue;
    }

    trim_whitespace_inplace(reason);
    const char *diagnostic = (reason[0] != '\0') ? reason : "policy violation";

    pthread_mutex_lock(&host->lock);
    bbs_post_t *live = host_find_bbs_post_locked(host, post->id);
    if (live != NULL) {
      host_clear_bbs_post_locked(host, live);
      host_bbs_state_save_locked(host);
    }
    pthread_mutex_unlock(&host->lock);

    if (live == NULL) {
      continue;
    }

    printf("[bbs] removed post #%" PRIu64 " by %s (%s)\n", post->id,
           post->author[0] != '\0' ? post->author : "unknown", diagnostic);

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice),
             "* [eliza] removed BBS post #%" PRIu64 " by %s (%s).",
             post->id,
             post->author[0] != '\0' ? post->author : "unknown",
             diagnostic);
    host_history_record_system(host, notice);
    chat_room_broadcast(&host->room, notice, NULL);
  }

}

static void *host_bbs_watchdog_thread(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  atomic_store(&host->bbs_watchdog_thread_running, true);
  printf("[bbs] watchdog thread started\n");

  while (!atomic_load(&host->bbs_watchdog_thread_stop)) {
    host_bbs_watchdog_scan(host);

    clock_gettime(CLOCK_MONOTONIC, &host->bbs_watchdog_last_run);

    unsigned int remaining = SSH_CHATTER_BBS_REVIEW_INTERVAL_SECONDS;
    while (remaining > 0U && !atomic_load(&host->bbs_watchdog_thread_stop)) {
      unsigned int chunk = remaining > SSH_CHATTER_BBS_WATCHDOG_SLEEP_SECONDS
                               ? SSH_CHATTER_BBS_WATCHDOG_SLEEP_SECONDS
                               : remaining;
      struct timespec pause = {
          .tv_sec = (time_t)chunk,
          .tv_nsec = 0L,
      };
      nanosleep(&pause, NULL);
      if (remaining <= chunk) {
        remaining = 0U;
      } else {
        remaining -= chunk;
      }
    }
  }

  atomic_store(&host->bbs_watchdog_thread_running, false);
  printf("[bbs] watchdog thread stopped\n");
  return NULL;
}

static void host_bbs_start_watchdog(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->bbs_watchdog_thread_initialized) {
    return;
  }

  atomic_store(&host->bbs_watchdog_thread_stop, false);
  atomic_store(&host->bbs_watchdog_thread_running, false);

  int error = pthread_create(&host->bbs_watchdog_thread, NULL, host_bbs_watchdog_thread, host);
  if (error != 0) {
    printf("[bbs] failed to start watchdog thread: %s\n", strerror(error));
    return;
  }

  host->bbs_watchdog_thread_initialized = true;
}

static void session_refresh_output_encoding(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  bool use_utf16 = false;
  if (ctx->os_name[0] != '\0') {
    const os_descriptor_t *descriptor = session_lookup_os_descriptor(ctx->os_name);
    if (descriptor != NULL && strcasecmp(descriptor->name, "windows") == 0) {
      use_utf16 = true;
    }
  }

  const bool previous_cp437 = ctx->prefer_cp437_output;
  const bool use_cp437 = session_detect_retro_client(ctx);
  ctx->prefer_cp437_output = use_cp437;

  if (use_cp437 != previous_cp437) {
    const char *subject = ctx->user.name[0] != '\0' ? ctx->user.name : ctx->client_ip;
    if (subject == NULL || subject[0] == '\0') {
      subject = "unknown";
    }

    if (use_cp437) {
      const char *marker = ctx->retro_client_marker[0] != '\0' ? ctx->retro_client_marker : "retro client";
      if (ctx->telnet_identity[0] != '\0') {
        printf("[retro] enabling CP437 output for %s via %s (%s)\n", subject, marker, ctx->telnet_identity);
      } else {
        printf("[retro] enabling CP437 output for %s via %s\n", subject, marker);
      }
    } else {
      printf("[retro] CP437 output disabled for %s\n", subject);
    }
  }

  if (use_cp437) {
    ctx->prefer_utf16_output = false;
    return;
  }

  ctx->prefer_utf16_output = use_utf16;
}

static bool session_detect_retro_client(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  ctx->retro_client_marker[0] = '\0';

  typedef struct retro_marker {
    const char *marker;
    const char *label;
  } retro_marker_t;

  static const retro_marker_t kRetroMarkers[] = {
      {"ftelnet", "fTelnet"},       {"htmlterm", "HTMLTerm"},       {"syncterm", "SyncTERM"},
      {"netrunner", "NetRunner"},   {"netfury", "NetFury"},         {"qodem", "Qodem"},
      {"mtelnet", "MTelnet"},       {"etherterm", "EtherTerm"},     {"mysticbbs", "Mystic BBS"},
      {"ansi-bbs", "ANSI-BBS"},     {"pc-ansi", "PC-ANSI"},         {"cp-437", "CP437 terminal"},
      {"cp437", "CP437 terminal"},   {"avatar", "AVATAR terminal"},  {"ripterm", "RIPTerm"},
      {"ansiart", "ANSI art terminal"}, {"ansi", "ANSI terminal"},
  };

  const char *sources[] = {
      ctx->terminal_type,
      ctx->client_banner,
  };

  const char *label = NULL;
  const char *identity_label = NULL;
  bool detected = false;

  for (size_t source_idx = 0U; source_idx < sizeof(sources) / sizeof(sources[0]) && !detected; ++source_idx) {
    const char *candidate = sources[source_idx];
    if (candidate == NULL || candidate[0] == '\0') {
      continue;
    }
    for (size_t marker_idx = 0U; marker_idx < sizeof(kRetroMarkers) / sizeof(kRetroMarkers[0]); ++marker_idx) {
      if (string_contains_case_insensitive(candidate, kRetroMarkers[marker_idx].marker)) {
        label = kRetroMarkers[marker_idx].label;
        identity_label = label;
        detected = true;
        break;
      }
    }
  }

  if (!detected && ctx->terminal_type[0] != '\0') {
    const char *type = ctx->terminal_type;
    if (string_contains_token_case_insensitive(type, "ANSI-BBS")) {
      label = "ANSI-BBS terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "PC-ANSI")) {
      label = "PC-ANSI terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "CP-437") ||
               string_contains_token_case_insensitive(type, "CP437")) {
      label = "CP437 terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "IBMGRAPHICS") ||
               string_contains_token_case_insensitive(type, "IBM-ASCII") ||
               string_contains_token_case_insensitive(type, "IBMPC")) {
      label = "IBM PC terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "AVATAR")) {
      label = "AVATAR terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "RIPTERM")) {
      label = "RIPTerm terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "PETSCII") ||
               string_contains_token_case_insensitive(type, "ATASCII")) {
      label = "8-bit art terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "DOS")) {
      label = "DOS ANSI terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "BBS")) {
      label = "BBS terminal";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(type, "ANSI")) {
      label = "ANSI terminal";
      identity_label = label;
      detected = true;
    }
  }

  if (!detected && ctx->client_banner[0] != '\0') {
    const char *banner = ctx->client_banner;
    if (string_contains_token_case_insensitive(banner, "ANSI-BBS") ||
        string_contains_token_case_insensitive(banner, "PC-ANSI")) {
      label = "ANSI-BBS banner";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(banner, "BBS")) {
      label = "BBS banner";
      identity_label = label;
      detected = true;
    } else if (string_contains_token_case_insensitive(banner, "ANSI")) {
      label = "ANSI banner";
      identity_label = label;
      detected = true;
    }
  }

  if (!detected && ctx->os_name[0] != '\0') {
    static const char *const kDosFamilies[] = {"msdos", "drdos", "pcdos", "kdos"};
    for (size_t idx = 0U; idx < sizeof(kDosFamilies) / sizeof(kDosFamilies[0]); ++idx) {
      if (strcasecmp(ctx->os_name, kDosFamilies[idx]) == 0) {
        label = "DOS OS";
        identity_label = NULL;
        detected = true;
        break;
      }
    }
  }

  if (detected) {
    const char *display = (label != NULL && label[0] != '\0') ? label : "Retro terminal";
    snprintf(ctx->retro_client_marker, sizeof(ctx->retro_client_marker), "%s", display);
  }

  session_format_telnet_identity(ctx, detected ? identity_label : NULL);

  return detected;
}

static void session_apply_saved_preferences(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  user_preference_t snapshot = (user_preference_t){0};
  bool has_snapshot = false;

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_find_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    snapshot = *pref;
    has_snapshot = true;
  }
  pthread_mutex_unlock(&host->lock);

  ctx->prefer_utf16_output = false;
  ctx->prefer_cp437_output = false;

  ctx->translation_caption_spacing = 0U;
  ctx->translation_enabled = false;
  ctx->output_translation_enabled = false;
  ctx->output_translation_language[0] = '\0';
  ctx->input_translation_enabled = false;
  ctx->input_translation_language[0] = '\0';
  ctx->last_detected_input_language[0] = '\0';
  ctx->ui_language = SESSION_UI_LANGUAGE_KO;

  if (has_snapshot) {
    if (snapshot.ui_language[0] != '\0') {
      session_ui_language_t saved_language = session_ui_language_from_code(snapshot.ui_language);
      if (saved_language != SESSION_UI_LANGUAGE_COUNT) {
        ctx->ui_language = saved_language;
      }
    }

    if (snapshot.has_user_theme) {
      const char *color_code = lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]),
                                                 snapshot.user_color_name);
      const char *highlight_code = lookup_color_code(
          HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), snapshot.user_highlight_name);
      if (color_code != NULL && highlight_code != NULL) {
        ctx->user_color_code = color_code;
        ctx->user_highlight_code = highlight_code;
        ctx->user_is_bold = snapshot.user_is_bold;
        snprintf(ctx->user_color_name, sizeof(ctx->user_color_name), "%s", snapshot.user_color_name);
        snprintf(ctx->user_highlight_name, sizeof(ctx->user_highlight_name), "%s", snapshot.user_highlight_name);
      }
    }

    if (snapshot.has_system_theme) {
      const char *fg_code = lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]),
                                              snapshot.system_fg_name);
      const char *bg_code = lookup_color_code(
          HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), snapshot.system_bg_name);
      if (fg_code != NULL && bg_code != NULL) {
        const char *highlight_code = ctx->system_highlight_code;
        if (snapshot.system_highlight_name[0] != '\0') {
          const char *candidate = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                                   sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]),
                                                   snapshot.system_highlight_name);
          if (candidate != NULL) {
            highlight_code = candidate;
          }
        }

        ctx->system_fg_code = fg_code;
        ctx->system_bg_code = bg_code;
        ctx->system_highlight_code = highlight_code;
        ctx->system_is_bold = snapshot.system_is_bold;
        snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", snapshot.system_fg_name);
        snprintf(ctx->system_bg_name, sizeof(ctx->system_bg_name), "%s", snapshot.system_bg_name);
        if (snapshot.system_highlight_name[0] != '\0') {
          snprintf(ctx->system_highlight_name, sizeof(ctx->system_highlight_name), "%s",
                   snapshot.system_highlight_name);
        }
      }
    }

    if (snapshot.os_name[0] != '\0') {
      snprintf(ctx->os_name, sizeof(ctx->os_name), "%s", snapshot.os_name);
    }
    ctx->daily_year = snapshot.daily_year;
    ctx->daily_yday = snapshot.daily_yday;
    if (snapshot.daily_function[0] != '\0') {
      snprintf(ctx->daily_function, sizeof(ctx->daily_function), "%s", snapshot.daily_function);
    }
    ctx->has_birthday = snapshot.has_birthday;
    if (ctx->has_birthday) {
      snprintf(ctx->birthday, sizeof(ctx->birthday), "%s", snapshot.birthday);
    } else {
      ctx->birthday[0] = '\0';
    }

    ctx->translation_caption_spacing = snapshot.translation_caption_spacing;
    if (ctx->translation_caption_spacing > 8U) {
      ctx->translation_caption_spacing = 8U;
    }

    if (snapshot.translation_master_explicit) {
      ctx->translation_enabled = snapshot.translation_master_enabled;
    }

    ctx->output_translation_enabled = snapshot.output_translation_enabled;
    snprintf(ctx->output_translation_language, sizeof(ctx->output_translation_language), "%s",
             snapshot.output_translation_language);
    ctx->input_translation_enabled = snapshot.input_translation_enabled;
    snprintf(ctx->input_translation_language, sizeof(ctx->input_translation_language), "%s",
             snapshot.input_translation_language);
  }

  (void)session_user_data_load(ctx);
  session_force_dark_mode_foreground(ctx);
}

static bool session_argument_is_disable(const char *token) {
  if (token == NULL) {
    return false;
  }

  if (strcasecmp(token, "off") == 0 || strcasecmp(token, "none") == 0 || strcasecmp(token, "disable") == 0 ||
      strcasecmp(token, "stop") == 0) {
    return true;
  }

  return strcmp(token, "끄기") == 0 || strcmp(token, "オフ") == 0 || strcmp(token, "关") == 0 || strcmp(token, "выкл") == 0;
}

static void session_language_normalize(const char *input, char *normalized, size_t length) {
  if (normalized == NULL || length == 0U) {
    return;
  }

  normalized[0] = '\0';
  if (input == NULL) {
    return;
  }

  size_t out_idx = 0U;
  for (size_t idx = 0U; input[idx] != '\0'; ++idx) {
    unsigned char ch = (unsigned char)input[idx];
    if (isspace(ch)) {
      continue;
    }

    char lowered = (char)tolower(ch);
    if (lowered == '_') {
      lowered = '-';
    }

    if (out_idx + 1U >= length) {
      break;
    }

    normalized[out_idx++] = lowered;
  }

  if (out_idx < length) {
    normalized[out_idx] = '\0';
  } else {
    normalized[length - 1U] = '\0';
  }
}

static bool session_language_equals(const char *lhs, const char *rhs) {
  if (lhs == NULL || rhs == NULL) {
    return false;
  }

  char normalized_lhs[SSH_CHATTER_LANG_NAME_LEN];
  char normalized_rhs[SSH_CHATTER_LANG_NAME_LEN];
  session_language_normalize(lhs, normalized_lhs, sizeof(normalized_lhs));
  session_language_normalize(rhs, normalized_rhs, sizeof(normalized_rhs));

  return strcmp(normalized_lhs, normalized_rhs) == 0;
}

typedef enum translation_job_type {
  TRANSLATION_JOB_CAPTION = 0,
  TRANSLATION_JOB_INPUT,
  TRANSLATION_JOB_PRIVATE_MESSAGE,
  TRANSLATION_JOB_ELIZA_CHAT,
} translation_job_type_t;

typedef struct translation_job {
  translation_job_type_t type;
  char target_language[SSH_CHATTER_LANG_NAME_LEN];
  size_t placeholder_lines;
  struct translation_job *next;
  union {
    struct {
      char sanitized[SSH_CHATTER_TRANSLATION_WORKING_LEN];
      translation_placeholder_t placeholders[SSH_CHATTER_MAX_TRANSLATION_PLACEHOLDERS];
      size_t placeholder_count;
    } caption;
    struct {
      char original[SSH_CHATTER_TRANSLATION_WORKING_LEN];
    } input;
    struct {
      char original[SSH_CHATTER_TRANSLATION_WORKING_LEN];
      char target_name[SSH_CHATTER_USERNAME_LEN];
      char to_target_label[SSH_CHATTER_MESSAGE_LIMIT];
      char to_sender_label[SSH_CHATTER_MESSAGE_LIMIT];
    } pm;
    struct {
      char prompt[SSH_CHATTER_MESSAGE_LIMIT];
      char formatted_prompt[SSH_CHATTER_ELIZA_PROMPT_BUFFER];
    } eliza;
  } data;
} translation_job_t;

typedef struct translation_result {
  translation_job_type_t type;
  bool success;
  size_t placeholder_lines;
  char translated[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  char detected_language[SSH_CHATTER_LANG_NAME_LEN];
  char original[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  char error_message[128];
  char pm_target_name[SSH_CHATTER_USERNAME_LEN];
  char pm_to_target_label[SSH_CHATTER_MESSAGE_LIMIT];
  char pm_to_sender_label[SSH_CHATTER_MESSAGE_LIMIT];
  struct translation_result *next;
} translation_result_t;

static translation_job_t *session_translation_job_alloc(void) {
  translation_job_t *job = (translation_job_t *)GC_MALLOC(sizeof(*job));
  if (job != NULL) {
    memset(job, 0, sizeof(*job));
  }
  return job;
}

static translation_result_t *session_translation_result_alloc(void) {
  translation_result_t *result = (translation_result_t *)GC_MALLOC(sizeof(*result));
  if (result != NULL) {
    memset(result, 0, sizeof(*result));
  }
  return result;
}

static bool session_translation_worker_ensure(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  if (!ctx->translation_mutex_initialized) {
    if (pthread_mutex_init(&ctx->translation_mutex, NULL) != 0) {
      return false;
    }
    ctx->translation_mutex_initialized = true;
  }

  if (!ctx->translation_cond_initialized) {
    if (pthread_cond_init(&ctx->translation_cond, NULL) != 0) {
      pthread_mutex_destroy(&ctx->translation_mutex);
      ctx->translation_mutex_initialized = false;
      return false;
    }
    ctx->translation_cond_initialized = true;
  }

  if (!ctx->translation_thread_started) {
    ctx->translation_thread_stop = false;
    if (pthread_create(&ctx->translation_thread, NULL, session_translation_worker, ctx) != 0) {
      pthread_cond_destroy(&ctx->translation_cond);
      ctx->translation_cond_initialized = false;
      pthread_mutex_destroy(&ctx->translation_mutex);
      ctx->translation_mutex_initialized = false;
      return false;
    }
    ctx->translation_thread_started = true;
  }

  return true;
}

static void session_translation_clear_queue(session_ctx_t *ctx) {
  if (ctx == NULL || !ctx->translation_mutex_initialized) {
    return;
  }

  translation_job_t *pending = NULL;
  translation_result_t *ready = NULL;

  pthread_mutex_lock(&ctx->translation_mutex);
  pending = ctx->translation_pending_head;
  ctx->translation_pending_head = NULL;
  ctx->translation_pending_tail = NULL;
  ready = ctx->translation_ready_head;
  ctx->translation_ready_head = NULL;
  ctx->translation_ready_tail = NULL;
  pthread_mutex_unlock(&ctx->translation_mutex);

  while (pending != NULL) {
    translation_job_t *next = pending->next;
    pending = next;
  }

  while (ready != NULL) {
    translation_result_t *next = ready->next;
    ready = next;
  }

  ctx->translation_placeholder_active_lines = 0U;
}

static bool session_translation_queue_caption(session_ctx_t *ctx, const char *message, size_t placeholder_lines) {
  if (ctx == NULL || message == NULL) {
    return false;
  }

  char stripped[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  if (translation_strip_no_translate_prefix(message, stripped, sizeof(stripped))) {
    return false;
  }

  if (!ctx->translation_enabled || !ctx->output_translation_enabled ||
      ctx->output_translation_language[0] == '\0' || message[0] == '\0') {
    return false;
  }

  if (!session_translation_worker_ensure(ctx)) {
    return false;
  }

  translation_job_t *job = session_translation_job_alloc();
  if (job == NULL) {
    return false;
  }

  size_t placeholder_count = 0U;
  if (!translation_prepare_text(message, job->data.caption.sanitized, sizeof(job->data.caption.sanitized),
                                job->data.caption.placeholders, &placeholder_count)) {
    return false;
  }

  if (job->data.caption.sanitized[0] == '\0') {
    return false;
  }

  job->type = TRANSLATION_JOB_CAPTION;
  job->data.caption.placeholder_count = placeholder_count;
  job->placeholder_lines = placeholder_lines;
  snprintf(job->target_language, sizeof(job->target_language), "%s", ctx->output_translation_language);

  pthread_mutex_lock(&ctx->translation_mutex);
  job->next = NULL;
  if (ctx->translation_pending_tail != NULL) {
    ctx->translation_pending_tail->next = job;
  } else {
    ctx->translation_pending_head = job;
  }
  ctx->translation_pending_tail = job;
  pthread_cond_signal(&ctx->translation_cond);
  pthread_mutex_unlock(&ctx->translation_mutex);

  return true;
}

static void session_translation_reserve_placeholders(session_ctx_t *ctx, size_t placeholder_lines) {
  if (ctx == NULL || !session_transport_active(ctx) || placeholder_lines == 0U) {
    return;
  }

  for (size_t idx = 0U; idx < placeholder_lines; ++idx) {
    session_write_rendered_line(ctx, "");
  }

  if (SIZE_MAX - ctx->translation_placeholder_active_lines < placeholder_lines) {
    ctx->translation_placeholder_active_lines = SIZE_MAX;
  } else {
    ctx->translation_placeholder_active_lines += placeholder_lines;
  }

  if (ctx->history_scroll_position == 0U) {
    session_refresh_input_line(ctx);
  }
}

static bool session_translation_push_scope_override(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  bool previous = ctx->translation_manual_scope_override;
  ctx->translation_manual_scope_override = true;
  return previous;
}

static void session_translation_pop_scope_override(session_ctx_t *ctx, bool previous) {
  if (ctx == NULL) {
    return;
  }

  ctx->translation_manual_scope_override = previous;
}

static void session_translation_queue_block(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || text == NULL || text[0] == '\0') {
    return;
  }

  if (translator_should_limit_to_chat_bbs() && !ctx->translation_manual_scope_override) {
    return;
  }

  (void)session_translation_queue_caption(ctx, text, 0U);
}

static bool session_translation_queue_private_message(session_ctx_t *ctx, session_ctx_t *target, const char *message) {
  if (ctx == NULL || target == NULL || message == NULL) {
    return false;
  }

  if (!ctx->translation_enabled || !ctx->input_translation_enabled || ctx->input_translation_language[0] == '\0' ||
      message[0] == '\0') {
    return false;
  }

  if (!session_translation_worker_ensure(ctx)) {
    return false;
  }

  translation_job_t *job = session_translation_job_alloc();
  if (job == NULL) {
    return false;
  }

  job->type = TRANSLATION_JOB_PRIVATE_MESSAGE;
  job->placeholder_lines = 0U;
  snprintf(job->target_language, sizeof(job->target_language), "%s", ctx->input_translation_language);
  snprintf(job->data.pm.original, sizeof(job->data.pm.original), "%s", message);
  snprintf(job->data.pm.target_name, sizeof(job->data.pm.target_name), "%s", target->user.name);
  snprintf(job->data.pm.to_target_label, sizeof(job->data.pm.to_target_label), "%s -> you", ctx->user.name);
  snprintf(job->data.pm.to_sender_label, sizeof(job->data.pm.to_sender_label), "you -> %s", target->user.name);

  pthread_mutex_lock(&ctx->translation_mutex);
  job->next = NULL;
  if (ctx->translation_pending_tail != NULL) {
    ctx->translation_pending_tail->next = job;
  } else {
    ctx->translation_pending_head = job;
  }
  ctx->translation_pending_tail = job;
  pthread_cond_signal(&ctx->translation_cond);
  pthread_mutex_unlock(&ctx->translation_mutex);

  return true;
}

static bool session_translation_queue_input(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || text == NULL || text[0] == '\0') {
    return false;
  }

  if (!ctx->translation_enabled || !ctx->input_translation_enabled || ctx->input_translation_language[0] == '\0') {
    return false;
  }

  if (!session_translation_worker_ensure(ctx)) {
    return false;
  }

  translation_job_t *job = session_translation_job_alloc();
  if (job == NULL) {
    return false;
  }

  job->type = TRANSLATION_JOB_INPUT;
  job->placeholder_lines = 0U;
  snprintf(job->target_language, sizeof(job->target_language), "%s", ctx->input_translation_language);
  snprintf(job->data.input.original, sizeof(job->data.input.original), "%s", text);

  pthread_mutex_lock(&ctx->translation_mutex);
  job->next = NULL;
  if (ctx->translation_pending_tail != NULL) {
    ctx->translation_pending_tail->next = job;
  } else {
    ctx->translation_pending_head = job;
  }
  ctx->translation_pending_tail = job;
  pthread_cond_signal(&ctx->translation_cond);
  pthread_mutex_unlock(&ctx->translation_mutex);

  return true;
}

static void session_translation_normalize_output(char *text) {
  if (text == NULL) {
    return;
  }

  size_t length = strlen(text);
  size_t idx = 0U;
  while (idx < length) {
    char ch = text[idx];
    if ((ch == 'u' || ch == 'U') && idx + 4U < length && text[idx + 1U] == '0' && text[idx + 2U] == '0' &&
        text[idx + 3U] == '3' && (text[idx + 4U] == 'c' || text[idx + 4U] == 'C' || text[idx + 4U] == 'e' ||
                                   text[idx + 4U] == 'E')) {
      char replacement = (text[idx + 4U] == 'c' || text[idx + 4U] == 'C') ? '<' : '>';
      size_t remove_start = idx;
      if (remove_start > 0U && text[remove_start - 1U] == '\\') {
        --remove_start;
      }

      size_t remove_end = idx + 5U;
      size_t removed = remove_end - remove_start;
      text[remove_start] = replacement;
      memmove(text + remove_start + 1U, text + remove_end, length - remove_end + 1U);
      length -= (removed - 1U);
      idx = remove_start + 1U;
      continue;
    }

    ++idx;
  }
}

static bool host_motd_contains_translation_notice(const char *motd_text) {
  if (motd_text == NULL) {
    return false;
  }

  const size_t notice_length = strlen(kTranslationQuotaNotice);
  const char *cursor = motd_text;
  while (*cursor != '\0') {
    size_t skip = host_column_reset_sequence_length(cursor);
    if (skip > 0U) {
      cursor += skip;
      continue;
    }
    if (*cursor == '\r' || *cursor == '\n') {
      ++cursor;
      continue;
    }
    if (strncmp(cursor, kTranslationQuotaNotice, notice_length) == 0) {
      return true;
    }
    while (*cursor != '\0' && *cursor != '\n') {
      ++cursor;
    }
  }

  return false;
}

static void host_prepend_translation_notice_in_memory(host_t *host, const char *existing_motd) {
  if (host == NULL) {
    return;
  }

  char updated[sizeof(host->motd)];
  if (existing_motd != NULL && existing_motd[0] != '\0') {
    snprintf(updated, sizeof(updated), "%s\n\n%s", kTranslationQuotaNotice, existing_motd);
  } else {
    snprintf(updated, sizeof(updated), "%s\n", kTranslationQuotaNotice);
  }

  pthread_mutex_lock(&host->lock);
  snprintf(host->motd_base, sizeof(host->motd_base), "%s", updated);
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_handle_translation_quota_exhausted(host_t *host) {
  if (host == NULL) {
    return;
  }

  bool already_marked = false;
  char motd_path[PATH_MAX];
  motd_path[0] = '\0';
  char motd_snapshot[sizeof(host->motd_base)];
  motd_snapshot[0] = '\0';

  pthread_mutex_lock(&host->lock);
  if (host->translation_quota_exhausted) {
    already_marked = true;
  } else {
    host->translation_quota_exhausted = true;
    if (host->motd_has_file && host->motd_path[0] != '\0') {
      snprintf(motd_path, sizeof(motd_path), "%s", host->motd_path);
    }
    snprintf(motd_snapshot, sizeof(motd_snapshot), "%s", host->motd_base);
  }
  pthread_mutex_unlock(&host->lock);

  if (already_marked) {
    return;
  }

  if (motd_path[0] == '\0') {
    if (host_motd_contains_translation_notice(motd_snapshot)) {
      host_refresh_motd(host);
      return;
    }
    host_prepend_translation_notice_in_memory(host, motd_snapshot);
    return;
  }

  char existing[8192];
  existing[0] = '\0';
  size_t existing_len = 0U;

  FILE *motd_file = fopen(motd_path, "rb");
  if (motd_file != NULL) {
    existing_len = fread(existing, 1U, sizeof(existing) - 1U, motd_file);
    if (ferror(motd_file)) {
      const int read_error = errno;
      humanized_log_error("host", "failed to read motd file", read_error);
      existing_len = 0U;
      existing[0] = '\0';
    }
    existing[existing_len] = '\0';
    if (fclose(motd_file) != 0) {
      const int close_error = errno;
      humanized_log_error("host", "failed to close motd file", close_error);
    }
  } else {
    host_prepend_translation_notice_in_memory(host, motd_snapshot);
    return;
  }

  const char *existing_start = existing;
  while (*existing_start == '\n' || *existing_start == '\r') {
    ++existing_start;
  }

  if (strncmp(existing_start, kTranslationQuotaNotice, strlen(kTranslationQuotaNotice)) == 0) {
    (void)host_try_load_motd_from_path(host, motd_path);
    return;
  }

  FILE *out = fopen(motd_path, "wb");
  if (out == NULL) {
    const int write_error = errno != 0 ? errno : EIO;
    humanized_log_error("host", "failed to update motd file", write_error);
    host_prepend_translation_notice_in_memory(host, motd_snapshot);
    return;
  }

  (void)fprintf(out, "%s\n", kTranslationQuotaNotice);
  if (existing[0] != '\0') {
    fputc('\n', out);
    (void)fwrite(existing, 1U, existing_len, out);
  }

  if (fclose(out) != 0) {
    const int close_error = errno;
    humanized_log_error("host", "failed to close motd file", close_error);
  }

  (void)host_try_load_motd_from_path(host, motd_path);
}

static void session_handle_translation_quota_exhausted(session_ctx_t *ctx, const char *error_detail) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_handle_translation_quota_exhausted(ctx->owner);

  const bool was_enabled = ctx->translation_enabled || ctx->output_translation_enabled ||
                           ctx->input_translation_enabled;
  ctx->translation_enabled = false;
  ctx->output_translation_enabled = false;
  ctx->input_translation_enabled = false;

  if (was_enabled) {
    host_store_translation_preferences(ctx->owner, ctx);
  }

  if (!ctx->translation_quota_notified) {
    char message[256];
    if (error_detail != NULL && error_detail[0] != '\0') {
      (void)snprintf(message, sizeof(message), "%s (%s)", kTranslationQuotaSystemMessage, error_detail);
    } else {
      (void)snprintf(message, sizeof(message), "%s", kTranslationQuotaSystemMessage);
    }
    session_send_system_line(ctx, message);
    ctx->translation_quota_notified = true;
  }
}

static void session_translation_flush_ready(session_ctx_t *ctx) {
  if (ctx == NULL || !ctx->translation_mutex_initialized) {
    return;
  }

  translation_result_t *ready = NULL;

  pthread_mutex_lock(&ctx->translation_mutex);
  ready = ctx->translation_ready_head;
  ctx->translation_ready_head = NULL;
  ctx->translation_ready_tail = NULL;
  pthread_mutex_unlock(&ctx->translation_mutex);

  if (ready == NULL) {
    return;
  }

  const bool translation_active = ctx->translation_enabled && ctx->output_translation_enabled &&
                                  ctx->output_translation_language[0] != '\0';

  bool refreshed = false;
  while (ready != NULL) {
    translation_result_t *next = ready->next;
    if (ready->type == TRANSLATION_JOB_INPUT) {
      if (ready->success) {
        if (ready->detected_language[0] != '\0') {
          snprintf(ctx->last_detected_input_language, sizeof(ctx->last_detected_input_language), "%s",
                   ready->detected_language);
        }
        session_deliver_outgoing_message(ctx, ready->translated, false);
      } else {
        const char *error_message = ready->error_message[0] != '\0'
                                        ? ready->error_message
                                        : "Translation failed; sending your original message.";
        session_send_system_line(ctx, error_message);
        session_deliver_outgoing_message(ctx, ready->original, false);
      }
      refreshed = true;
      ready = next;
      continue;
    }

    if (ready->type == TRANSLATION_JOB_PRIVATE_MESSAGE) {
      session_ctx_t *target = NULL;
      if (ctx->owner != NULL && ready->pm_target_name[0] != '\0') {
        target = chat_room_find_user(&ctx->owner->room, ready->pm_target_name);
      }

      if (ready->success) {
        if (target != NULL) {
          session_send_private_message_line(target, ctx, ready->pm_to_target_label, ready->translated);
        } else if (ready->pm_target_name[0] != '\0') {
          char notice[SSH_CHATTER_MESSAGE_LIMIT];
          snprintf(notice, sizeof(notice), "User '%s' disconnected before your private message was delivered.",
                   ready->pm_target_name);
          session_send_system_line(ctx, notice);
        }
        session_send_private_message_line(ctx, ctx, ready->pm_to_sender_label, ready->translated);
      } else {
        const char *error_message = ready->error_message[0] != '\0'
                                        ? ready->error_message
                                        : "Translation failed; sending your original message.";
        session_send_system_line(ctx, error_message);
        if (target != NULL) {
          session_send_private_message_line(target, ctx, ready->pm_to_target_label, ready->original);
        } else if (ready->pm_target_name[0] != '\0') {
          char notice[SSH_CHATTER_MESSAGE_LIMIT];
          snprintf(notice, sizeof(notice), "User '%s' disconnected before your private message was delivered.",
                   ready->pm_target_name);
          session_send_system_line(ctx, notice);
        }
        session_send_private_message_line(ctx, ctx, ready->pm_to_sender_label, ready->original);
      }

      refreshed = true;
      ready = next;
      continue;
    }

    if (ready->type == TRANSLATION_JOB_ELIZA_CHAT) {
      if (ready->success) {
        if (ctx->owner != NULL) {
          host_eliza_memory_store(ctx->owner, ready->original, ready->translated);
          clock_gettime(CLOCK_MONOTONIC, &ctx->owner->eliza_last_action);
        }

        session_ctx_t palette = {0};
        if (ctx->owner != NULL) {
          palette.user_color_code = ctx->owner->user_theme.userColor;
          palette.user_highlight_code = ctx->owner->user_theme.highlight;
          palette.user_is_bold = ctx->owner->user_theme.isBold;
        }

        session_send_private_message_line(ctx, &palette, "eliza -> you", ready->translated);

        if (ctx->owner != NULL) {
          ctx->last_message_time = ctx->owner->eliza_last_action;
          ctx->has_last_message_time = true;
        }

        printf("[eliza-chat] %s -> eliza: %s\n", ctx->user.name, ready->original);
        printf("[eliza-chat] eliza -> %s: %s\n", ctx->user.name, ready->translated);
      } else {
        const char *error_message =
            ready->error_message[0] != '\0' ? ready->error_message : "eliza can't reply right now. Try again in a moment.";
        session_send_system_line(ctx, error_message);
      }

      refreshed = true;
      ready = next;
      continue;
    }

    size_t placeholder_lines = ready->placeholder_lines;
    size_t move_up = 0U;
    if (placeholder_lines > 0U && ctx->translation_placeholder_active_lines >= placeholder_lines) {
      size_t remaining_after = ctx->translation_placeholder_active_lines - placeholder_lines;
      move_up = remaining_after + 1U;
    }

    if (translation_active) {
      const char *body = ready->translated;
      if (body[0] == '\0') {
        body = "translation unavailable.";
      }

      const char *line_cursor = body;
      size_t line_index = 0U;
      while (line_cursor != NULL) {
        const char *line_end = strchr(line_cursor, '\n');
        size_t line_length = (line_end != NULL) ? (size_t)(line_end - line_cursor) : strlen(line_cursor);
        if (line_length >= SSH_CHATTER_TRANSLATION_WORKING_LEN) {
          line_length = SSH_CHATTER_TRANSLATION_WORKING_LEN - 1U;
        }

        char line_fragment[SSH_CHATTER_TRANSLATION_WORKING_LEN];
        memcpy(line_fragment, line_cursor, line_length);
        line_fragment[line_length] = '\0';

        char annotated[SSH_CHATTER_TRANSLATION_WORKING_LEN + 64U];
        snprintf(annotated, sizeof(annotated), "    \342\206\263 %s", line_fragment);
        session_render_caption_with_offset(ctx, annotated, line_index == 0U ? move_up : 0U);
        refreshed = true;

        if (line_end == NULL) {
          break;
        }

        line_cursor = line_end + 1;
        ++line_index;
      }
    }

    if (placeholder_lines > 0U) {
      if (ctx->translation_placeholder_active_lines >= placeholder_lines) {
        ctx->translation_placeholder_active_lines -= placeholder_lines;
      } else {
        ctx->translation_placeholder_active_lines = 0U;
      }
    }

    ready = next;
  }

  if (refreshed && ctx->history_scroll_position == 0U) {
    session_refresh_input_line(ctx);
  }
}

static void session_translation_worker_shutdown(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->translation_mutex_initialized) {
    pthread_mutex_lock(&ctx->translation_mutex);
    if (ctx->translation_thread_started) {
      ctx->translation_thread_stop = true;
      pthread_cond_broadcast(&ctx->translation_cond);
      pthread_mutex_unlock(&ctx->translation_mutex);
      pthread_join(ctx->translation_thread, NULL);
      ctx->translation_thread_started = false;
    } else {
      pthread_mutex_unlock(&ctx->translation_mutex);
    }
  }

  session_translation_clear_queue(ctx);

  if (ctx->translation_cond_initialized) {
    pthread_cond_destroy(&ctx->translation_cond);
    ctx->translation_cond_initialized = false;
  }
  if (ctx->translation_mutex_initialized) {
    pthread_mutex_destroy(&ctx->translation_mutex);
    ctx->translation_mutex_initialized = false;
  }

  ctx->translation_thread_stop = false;
}

static void session_translation_publish_result(session_ctx_t *ctx, const translation_job_t *job,
                                               const char *payload, const char *detected_language,
                                               const char *error_message, bool success) {
  if (ctx == NULL || job == NULL) {
    return;
  }

  translation_result_t *result = session_translation_result_alloc();
  if (result == NULL) {
    return;
  }

  result->type = job->type;
  result->success = success;
  result->placeholder_lines = job->placeholder_lines;

  if (job->type == TRANSLATION_JOB_INPUT) {
    snprintf(result->original, sizeof(result->original), "%s", job->data.input.original);
    if (payload != NULL) {
      snprintf(result->translated, sizeof(result->translated), "%s", payload);
    } else {
      result->translated[0] = '\0';
    }
    if (detected_language != NULL) {
      snprintf(result->detected_language, sizeof(result->detected_language), "%s", detected_language);
    } else {
      result->detected_language[0] = '\0';
    }
    if (error_message != NULL) {
      snprintf(result->error_message, sizeof(result->error_message), "%s", error_message);
    } else {
      result->error_message[0] = '\0';
    }
    session_translation_normalize_output(result->translated);
  } else if (job->type == TRANSLATION_JOB_PRIVATE_MESSAGE) {
    snprintf(result->original, sizeof(result->original), "%s", job->data.pm.original);
    if (payload != NULL) {
      snprintf(result->translated, sizeof(result->translated), "%s", payload);
    } else {
      result->translated[0] = '\0';
    }
    if (error_message != NULL) {
      snprintf(result->error_message, sizeof(result->error_message), "%s", error_message);
    } else {
      result->error_message[0] = '\0';
    }
    result->detected_language[0] = '\0';
    snprintf(result->pm_target_name, sizeof(result->pm_target_name), "%s", job->data.pm.target_name);
    snprintf(result->pm_to_target_label, sizeof(result->pm_to_target_label), "%s", job->data.pm.to_target_label);
    snprintf(result->pm_to_sender_label, sizeof(result->pm_to_sender_label), "%s", job->data.pm.to_sender_label);
    session_translation_normalize_output(result->translated);
  } else if (job->type == TRANSLATION_JOB_ELIZA_CHAT) {
    snprintf(result->original, sizeof(result->original), "%s", job->data.eliza.prompt);
    if (payload != NULL) {
      snprintf(result->translated, sizeof(result->translated), "%s", payload);
    } else {
      result->translated[0] = '\0';
    }
    if (error_message != NULL) {
      snprintf(result->error_message, sizeof(result->error_message), "%s", error_message);
    } else {
      result->error_message[0] = '\0';
    }
    result->detected_language[0] = '\0';
    session_translation_normalize_output(result->translated);
  } else {
    const char *message = payload;
    if (message == NULL || message[0] == '\0') {
      if (success) {
        message = "";
      } else {
        message = "⚠️ translation unavailable.";
      }
    }

    snprintf(result->translated, sizeof(result->translated), "%s", message);
    session_translation_normalize_output(result->translated);
    result->detected_language[0] = '\0';
    result->error_message[0] = '\0';
    result->original[0] = '\0';
  }

  pthread_mutex_lock(&ctx->translation_mutex);
  result->next = NULL;
  if (ctx->translation_ready_tail != NULL) {
    ctx->translation_ready_tail->next = result;
  } else {
    ctx->translation_ready_head = result;
  }
  ctx->translation_ready_tail = result;
  pthread_mutex_unlock(&ctx->translation_mutex);
}

static void session_translation_process_single_job(session_ctx_t *ctx, translation_job_t *job) {
  if (ctx == NULL || job == NULL) {
    return;
  }

  if (ctx->translation_thread_stop) {
    return;
  }

  if (job->type == TRANSLATION_JOB_INPUT || job->type == TRANSLATION_JOB_PRIVATE_MESSAGE) {
    char translated_body[SSH_CHATTER_TRANSLATION_WORKING_LEN];
    char detected_language[SSH_CHATTER_LANG_NAME_LEN];
    translated_body[0] = '\0';
    detected_language[0] = '\0';

    const bool is_private_message = (job->type == TRANSLATION_JOB_PRIVATE_MESSAGE);
    const char *source_text =
        is_private_message ? job->data.pm.original : job->data.input.original;
    char *detected_target = is_private_message ? NULL : detected_language;
    size_t detected_length = is_private_message ? 0U : sizeof(detected_language);

    if (translator_translate_with_cancel(source_text, job->target_language, translated_body, sizeof(translated_body),
                                         detected_target, detected_length, &ctx->translation_thread_stop)) {
      if (ctx->translation_thread_stop) {
        return;
      }
      session_translation_publish_result(ctx, job, translated_body,
                                         is_private_message ? NULL : detected_language, NULL, true);
    } else {
      const char *error = translator_last_error();
      char message[128];
      const bool quota_failure = translator_last_error_was_quota();
      if (ctx->translation_thread_stop) {
        return;
      }
      if (quota_failure) {
        if (error != NULL && error[0] != '\0') {
          snprintf(message, sizeof(message),
                   "⚠️ translation unavailable (quota exhausted: %s); sending your original message.", error);
        } else {
          snprintf(message, sizeof(message),
                   "⚠️ translation unavailable (quota exhausted); sending your original message.");
        }
        session_handle_translation_quota_exhausted(ctx, error);
      } else if (error != NULL && error[0] != '\0') {
        snprintf(message, sizeof(message), "Translation failed (%s); sending your original message.", error);
      } else {
        snprintf(message, sizeof(message), "Translation failed; sending your original message.");
      }
      if (ctx->translation_thread_stop) {
        return;
      }
      session_translation_publish_result(ctx, job, NULL, NULL, message, false);
    }
    return;
  }

  if (job->type == TRANSLATION_JOB_ELIZA_CHAT) {
    if (ctx->translation_thread_stop) {
      return;
    }

    char reply[SSH_CHATTER_MESSAGE_LIMIT];
    reply[0] = '\0';
    if (translator_eliza_respond(job->data.eliza.formatted_prompt, reply, sizeof(reply))) {
      trim_whitespace_inplace(reply);
      if (ctx->translation_thread_stop) {
        return;
      }
      session_translation_publish_result(ctx, job, reply, NULL, NULL, true);
    } else {
      const char *error = translator_last_error();
      char message[128];
      if (error != NULL && error[0] != '\0') {
        snprintf(message, sizeof(message), "eliza can't reply right now (%s).", error);
      } else {
        snprintf(message, sizeof(message), "eliza can't reply right now. Try again in a moment.");
      }
      if (ctx->translation_thread_stop) {
        return;
      }
      session_translation_publish_result(ctx, job, NULL, NULL, message, false);
    }
    return;
  }

  char translated_body[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  char restored[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  translated_body[0] = '\0';
  restored[0] = '\0';

  bool success = false;
  char failure_message[128];
  failure_message[0] = '\0';
  const int max_attempts = 3;
  for (int attempt = 0; attempt < max_attempts && !success; ++attempt) {
    translated_body[0] = '\0';

    if (ctx->translation_thread_stop) {
      return;
    }

    if (!translator_translate_with_cancel(job->data.caption.sanitized, job->target_language, translated_body,
                                          sizeof(translated_body), NULL, 0U, &ctx->translation_thread_stop)) {
      const char *error = translator_last_error();
      const bool quota_failure = translator_last_error_was_quota();
      if (ctx->translation_thread_stop) {
        return;
      }
      if (quota_failure) {
        if (error != NULL && error[0] != '\0') {
          snprintf(failure_message, sizeof(failure_message),
                   "⚠️ translation unavailable (quota exhausted: %s)", error);
        } else {
          snprintf(failure_message, sizeof(failure_message), "⚠️ translation unavailable (quota exhausted).");
        }
        session_handle_translation_quota_exhausted(ctx, error);
        break;
      }

      if (error != NULL && error[0] != '\0') {
        snprintf(failure_message, sizeof(failure_message), "⚠️ translation failed: %s", error);
      } else {
        snprintf(failure_message, sizeof(failure_message), "⚠️ translation failed.");
      }

      if (attempt + 1 < max_attempts) {
        struct timespec retry_delay = {.tv_sec = 1, .tv_nsec = 0L};
        nanosleep(&retry_delay, NULL);
      }
      continue;
    }

    if (!translation_restore_text(translated_body, restored, sizeof(restored), job->data.caption.placeholders,
                                  job->data.caption.placeholder_count)) {
      snprintf(failure_message, sizeof(failure_message), "⚠️ translation post-processing failed.");
      break;
    }

    success = true;
    failure_message[0] = '\0';
  }

  if (!success && failure_message[0] == '\0') {
    snprintf(failure_message, sizeof(failure_message), "⚠️ translation unavailable.");
  }

  if (ctx->translation_thread_stop) {
    return;
  }

  if (success) {
    session_translation_publish_result(ctx, job, restored, NULL, NULL, true);
  } else {
    session_translation_publish_result(ctx, job, failure_message, NULL, NULL, false);
  }

}

static bool session_translation_process_batch(session_ctx_t *ctx, translation_job_t **jobs, size_t job_count) {
  if (ctx == NULL || jobs == NULL || job_count == 0U) {
    return false;
  }

  if (jobs[0] == NULL || jobs[0]->type != TRANSLATION_JOB_CAPTION) {
    return false;
  }

  if (ctx->translation_thread_stop) {
    for (size_t idx = 0U; idx < job_count; ++idx) {
      if (jobs[idx] != NULL) {
        jobs[idx] = NULL;
      }
    }
    return true;
  }

  char *combined = GC_CALLOC(SSH_CHATTER_TRANSLATION_BATCH_BUFFER, sizeof(char));
  char *translated = GC_CALLOC(SSH_CHATTER_TRANSLATION_BATCH_BUFFER, sizeof(char));
  if (combined == NULL || translated == NULL) {
    return false;
  }

  size_t offset = 0U;
  for (size_t idx = 0U; idx < job_count; ++idx) {
    if (ctx->translation_thread_stop) {
      for (size_t release = idx; release < job_count; ++release) {
        if (jobs[release] != NULL) {
          jobs[release] = NULL;
        }
      }
      return true;
    }
    if (jobs[idx] == NULL || jobs[idx]->type != TRANSLATION_JOB_CAPTION) {
      return false;
    }

    char marker[32];
    int marker_len = snprintf(marker, sizeof(marker), "[[SEG%02zu]]\n", idx);
    if (marker_len < 0) {
      return false;
    }

    size_t marker_size = (size_t)marker_len;
    size_t text_len = strlen(jobs[idx]->data.caption.sanitized);
    if (offset + marker_size + text_len + 1U > SSH_CHATTER_TRANSLATION_BATCH_BUFFER) {
      return false;
    }

    memcpy(combined + offset, marker, marker_size);
    offset += marker_size;
    memcpy(combined + offset, jobs[idx]->data.caption.sanitized, text_len);
    offset += text_len;
    combined[offset++] = '\n';
  }
  combined[offset] = '\0';

  if (!translator_translate_with_cancel(combined, jobs[0]->target_language, translated,
                                        SSH_CHATTER_TRANSLATION_BATCH_BUFFER, NULL, 0U,
                                        &ctx->translation_thread_stop)) {
    if (ctx->translation_thread_stop) {
      for (size_t idx = 0U; idx < job_count; ++idx) {
        if (jobs[idx] != NULL) {
          jobs[idx] = NULL;
        }
      }
      return true;
    }
    return false;
  }

  if (ctx->translation_thread_stop) {
    for (size_t idx = 0U; idx < job_count; ++idx) {
      if (jobs[idx] != NULL) {
        jobs[idx] = NULL;
      }
    }
    return true;
  }

  char *segment_starts[SSH_CHATTER_TRANSLATION_BATCH_MAX] = {0};
  char *segment_ends[SSH_CHATTER_TRANSLATION_BATCH_MAX] = {0};

  char *search_cursor = translated;
  for (size_t idx = 0U; idx < job_count; ++idx) {
    char marker[32];
    int marker_len = snprintf(marker, sizeof(marker), "[[SEG%02zu]]", idx);
    if (marker_len < 0) {
      return false;
    }

    char *marker_pos = strstr(search_cursor, marker);
    if (marker_pos == NULL) {
      return false;
    }

    char *start = marker_pos + (size_t)marker_len;
    while (*start == '\r' || *start == '\n') {
      ++start;
    }

    segment_starts[idx] = start;
    search_cursor = start;
  }

  for (size_t idx = 0U; idx + 1U < job_count; ++idx) {
    char marker[32];
    int marker_len = snprintf(marker, sizeof(marker), "[[SEG%02zu]]", idx + 1U);
    if (marker_len < 0) {
      return false;
    }

    char *next_pos = strstr(segment_starts[idx], marker);
    if (next_pos == NULL) {
      return false;
    }

    char *end = next_pos;
    while (end > segment_starts[idx] && (end[-1] == '\r' || end[-1] == '\n')) {
      --end;
    }
    segment_ends[idx] = end;
  }

  char *last_end = translated + strlen(translated);
  while (last_end > segment_starts[job_count - 1U] && (last_end[-1] == '\r' || last_end[-1] == '\n')) {
    --last_end;
  }
  segment_ends[job_count - 1U] = last_end;

  char restored_segments[SSH_CHATTER_TRANSLATION_BATCH_MAX][SSH_CHATTER_TRANSLATION_WORKING_LEN];
  for (size_t idx = 0U; idx < job_count; ++idx) {
    if (segment_starts[idx] == NULL || segment_ends[idx] == NULL || segment_ends[idx] < segment_starts[idx]) {
      return false;
    }

    size_t segment_len = (size_t)(segment_ends[idx] - segment_starts[idx]);
    if (segment_len + 1U > SSH_CHATTER_TRANSLATION_WORKING_LEN) {
      return false;
    }

    char segment_buffer[SSH_CHATTER_TRANSLATION_WORKING_LEN];
    memcpy(segment_buffer, segment_starts[idx], segment_len);
    segment_buffer[segment_len] = '\0';

    if (!translation_restore_text(segment_buffer, restored_segments[idx], sizeof(restored_segments[idx]),
                                  jobs[idx]->data.caption.placeholders, jobs[idx]->data.caption.placeholder_count)) {
      return false;
    }
  }

  if (ctx->translation_thread_stop) {
    for (size_t idx = 0U; idx < job_count; ++idx) {
      if (jobs[idx] != NULL) {
        jobs[idx] = NULL;
      }
    }
    return true;
  }

  for (size_t idx = 0U; idx < job_count; ++idx) {
    session_translation_publish_result(ctx, jobs[idx], restored_segments[idx], NULL, NULL, true);
  }

  return true;
}

static void *session_translation_worker(void *arg) {
  session_ctx_t *ctx = (session_ctx_t *)arg;
  if (ctx == NULL) {
    return NULL;
  }

  for (;;) {
    translation_job_t *batch[SSH_CHATTER_TRANSLATION_BATCH_MAX] = {0};
    size_t batch_count = 0U;

    pthread_mutex_lock(&ctx->translation_mutex);
    while (!ctx->translation_thread_stop && ctx->translation_pending_head == NULL) {
      pthread_cond_wait(&ctx->translation_cond, &ctx->translation_mutex);
    }

    if (ctx->translation_thread_stop) {
      pthread_mutex_unlock(&ctx->translation_mutex);
      break;
    }

    translation_job_t *job = ctx->translation_pending_head;
    if (job != NULL) {
      ctx->translation_pending_head = job->next;
      if (ctx->translation_pending_head == NULL) {
        ctx->translation_pending_tail = NULL;
      }
      job->next = NULL;
      batch[batch_count++] = job;
    }
    pthread_mutex_unlock(&ctx->translation_mutex);

    if (batch_count == 0U) {
      continue;
    }

    if (batch[0]->type == TRANSLATION_JOB_INPUT) {
      session_translation_process_single_job(ctx, batch[0]);
      continue;
    }

    size_t estimate = strlen(batch[0]->data.caption.sanitized) + SSH_CHATTER_TRANSLATION_SEGMENT_GUARD;

    if (batch_count == 1U) {
      bool delay_needed = false;
      pthread_mutex_lock(&ctx->translation_mutex);
      if (!ctx->translation_thread_stop && ctx->translation_pending_head == NULL) {
        delay_needed = true;
      }
      pthread_mutex_unlock(&ctx->translation_mutex);

      if (delay_needed) {
        struct timespec aggregation_delay = {.tv_sec = 0, .tv_nsec = SSH_CHATTER_TRANSLATION_BATCH_DELAY_NS};
        nanosleep(&aggregation_delay, NULL);
      }
    }

    pthread_mutex_lock(&ctx->translation_mutex);
    while (batch_count < SSH_CHATTER_TRANSLATION_BATCH_MAX && ctx->translation_pending_head != NULL) {
      translation_job_t *candidate = ctx->translation_pending_head;
      if (candidate == NULL) {
        break;
      }

      if (candidate->type != TRANSLATION_JOB_CAPTION) {
        break;
      }

      if (strcmp(candidate->target_language, batch[0]->target_language) != 0) {
        break;
      }

      size_t candidate_len = strlen(candidate->data.caption.sanitized) + SSH_CHATTER_TRANSLATION_SEGMENT_GUARD;
      if (estimate + candidate_len >= SSH_CHATTER_TRANSLATION_BATCH_BUFFER) {
        break;
      }

      ctx->translation_pending_head = candidate->next;
      if (ctx->translation_pending_head == NULL) {
        ctx->translation_pending_tail = NULL;
      }
      candidate->next = NULL;
      batch[batch_count++] = candidate;
      estimate += candidate_len;
    }
    pthread_mutex_unlock(&ctx->translation_mutex);

    bool processed = false;
    if (batch_count > 1U) {
      processed = session_translation_process_batch(ctx, batch, batch_count);
    }

    if (!processed) {
      for (size_t idx = 0U; idx < batch_count; ++idx) {
        session_translation_process_single_job(ctx, batch[idx]);
      }
    }
  }

  return NULL;
}

static void session_channel_log_write_failure(session_ctx_t *ctx, const char *reason) {
  if (ctx == NULL) {
    return;
  }

  if (reason == NULL || reason[0] == '\0') {
    reason = "transport write failure";
  }

  const char *username = ctx->user.name[0] != '\0' ? ctx->user.name : "unknown";
  printf("[session] transport write failure for %s: %s\n", username, reason);
}

static bool session_telnet_write_block(session_ctx_t *ctx, const unsigned char *data, size_t length) {
  if (ctx == NULL || data == NULL || length == 0U || ctx->telnet_fd < 0) {
    return true;
  }

  while (length > 0U) {
    size_t chunk = length;
    if (chunk > SSH_CHATTER_CHANNEL_WRITE_CHUNK) {
      chunk = SSH_CHATTER_CHANNEL_WRITE_CHUNK;
    }

    unsigned char buffer[SSH_CHATTER_CHANNEL_WRITE_CHUNK * 2U];
    size_t expanded = 0U;
    for (size_t idx = 0U; idx < chunk; ++idx) {
      unsigned char byte = data[idx];
      buffer[expanded++] = byte;
      if (byte == TELNET_IAC) {
        buffer[expanded++] = TELNET_IAC;
      }
    }

    size_t offset = 0U;
    while (offset < expanded) {
      ssize_t written = send(ctx->telnet_fd, buffer + offset, expanded - offset, MSG_NOSIGNAL);
      if (written < 0) {
        if (errno == EINTR) {
          continue;
        }
        return false;
      }
      offset += (size_t)written;
    }

    data += chunk;
    length -= chunk;
  }

  return true;
}

static bool session_channel_wait_writable(session_ctx_t *ctx, int timeout_ms) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    if (ctx->telnet_fd < 0) {
      return false;
    }

    struct pollfd pfd = {
        .fd = ctx->telnet_fd,
        .events = POLLOUT,
        .revents = 0,
    };

    for (;;) {
      int result = poll(&pfd, 1, timeout_ms);
      if (result < 0) {
        if (errno == EINTR) {
          continue;
        }
        return false;
      }
      if (result == 0) {
        return false;
      }
      if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
        return false;
      }
      if (pfd.revents & POLLOUT) {
        return true;
      }
      return false;
    }
  }

  if (ctx->session == NULL) {
    return false;
  }

  int fd = ssh_get_fd(ctx->session);
  if (fd < 0) {
    struct timespec backoff = {
        .tv_sec = 0,
        .tv_nsec = SSH_CHATTER_CHANNEL_WRITE_BACKOFF_NS,
    };
    nanosleep(&backoff, NULL);
    return true;
  }

  struct pollfd pfd = {
      .fd = fd,
      .events = POLLOUT,
      .revents = 0,
  };

  for (;;) {
    int result = poll(&pfd, 1, timeout_ms);
    if (result < 0) {
      if (errno == EINTR) {
        continue;
      }
      return false;
    }
    if (result == 0) {
      return false;
    }
    if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
      return false;
    }
    if (pfd.revents & POLLOUT) {
      return true;
    }
    return false;
  }
}

static bool session_channel_write_all(session_ctx_t *ctx, const void *data, size_t length) {
  if (ctx == NULL || data == NULL || length == 0U || !session_transport_active(ctx)) {
    return true;
  }

  const unsigned char *cursor = (const unsigned char *)data;
  size_t remaining = length;
  unsigned int stalled = 0U;

  while (remaining > 0U) {
    if (!session_channel_wait_writable(ctx, SSH_CHATTER_CHANNEL_WRITE_TIMEOUT_MS)) {
      if (++stalled >= SSH_CHATTER_CHANNEL_WRITE_MAX_STALLS) {
        session_channel_log_write_failure(ctx, "write timed out");
        return false;
      }
      continue;
    }

    stalled = 0U;

    size_t chunk = remaining;
    if (chunk > SSH_CHATTER_CHANNEL_WRITE_CHUNK) {
      chunk = SSH_CHATTER_CHANNEL_WRITE_CHUNK;
    }

    if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
      if (!session_telnet_write_block(ctx, cursor, chunk)) {
        session_channel_log_write_failure(ctx, "telnet write error");
        return false;
      }
      cursor += chunk;
      remaining -= chunk;
      continue;
    }

    ssize_t written = ssh_channel_write(ctx->channel, cursor, (uint32_t)chunk);
    if (written == SSH_ERROR) {
      const char *error = ssh_get_error(ctx->session);
      session_channel_log_write_failure(ctx,
                                        (error != NULL && error[0] != '\0') ? error : "channel write error");
      return false;
    }

    if (written == 0) {
      if (ssh_channel_is_eof(ctx->channel) || !ssh_channel_is_open(ctx->channel)) {
        session_channel_log_write_failure(ctx, "channel closed during write");
        return false;
      }

      if (++stalled >= SSH_CHATTER_CHANNEL_WRITE_MAX_STALLS) {
        session_channel_log_write_failure(ctx, "channel write stalled");
        return false;
      }

      continue;
    }

    cursor += written;
    remaining -= (size_t)written;
  }

  return true;
}

static bool session_channel_write_cp437(session_ctx_t *ctx, const char *data, size_t length) {
  if (ctx == NULL || data == NULL || length == 0U) {
    return true;
  }

  iconv_t descriptor = iconv_open("CP437//TRANSLIT", "UTF-8");
  if (descriptor == (iconv_t)(-1)) {
    return session_channel_write_all(ctx, data, length);
  }

  size_t capacity = (length > 0U ? length : 1U) * 4U + 16U;
  char *buffer = (char *)GC_MALLOC(capacity);
  if (buffer == NULL) {
    iconv_close(descriptor);
    return session_channel_write_all(ctx, data, length);
  }

  const char *input_cursor = data;
  size_t input_remaining = length;
  char *output_cursor = buffer;
  size_t output_remaining = capacity;

  bool fallback_to_plaintext = false;

  while (input_remaining > 0U) {
    size_t result = iconv(descriptor, (char **)&input_cursor, &input_remaining, &output_cursor, &output_remaining);
    if (result == (size_t)-1) {
      if (errno == E2BIG) {
        size_t produced = capacity - output_remaining;
        size_t new_capacity = capacity * 2U;
        if (new_capacity <= capacity) {
          new_capacity = capacity + length + 32U;
        }
        char *resized = (char *)realloc(buffer, new_capacity);
        if (resized == NULL) {
          fallback_to_plaintext = true;
          goto cleanup;
        }
        buffer = resized;
        output_cursor = buffer + produced;
        output_remaining = new_capacity - produced;
        capacity = new_capacity;
        continue;
      }
      if (errno == EILSEQ || errno == EINVAL) {
        ++input_cursor;
        --input_remaining;
        if (output_remaining == 0U) {
          size_t produced = capacity - output_remaining;
          size_t new_capacity = capacity * 2U;
          if (new_capacity <= capacity) {
            new_capacity = capacity + length + 32U;
          }
          char *resized = (char *)realloc(buffer, new_capacity);
          if (resized == NULL) {
            fallback_to_plaintext = true;
            goto cleanup;
          }
          buffer = resized;
          output_cursor = buffer + produced;
          output_remaining = new_capacity - produced;
          capacity = new_capacity;
        }
        *output_cursor++ = '?';
        output_remaining -= 1U;
        continue;
      }
      fallback_to_plaintext = true;
      goto cleanup;
    }
  }

cleanup:
  iconv_close(descriptor);
  bool success = false;
  if (fallback_to_plaintext) {
    success = session_channel_write_all(ctx, data, length);
  } else {
    size_t produced = capacity - output_remaining;
    success = session_channel_write_all(ctx, buffer, produced);
  }
  return success;
}

static void session_channel_write(session_ctx_t *ctx, const void *data, size_t length) {
  if (ctx == NULL || data == NULL || length == 0U || ctx->should_exit || !session_transport_active(ctx)) {
    return;
  }

  bool success = true;
  if (ctx->prefer_cp437_output) {
    success = session_channel_write_cp437(ctx, (const char *)data, length);
  } else if (ctx->prefer_utf16_output) {
    success = session_channel_write_utf16(ctx, (const char *)data, length);
  } else {
    success = session_channel_write_all(ctx, data, length);
  }

  if (!success) {
    ctx->should_exit = true;
  }
}

static bool session_channel_write_utf16(session_ctx_t *ctx, const char *data, size_t length) {
  if (ctx == NULL || data == NULL) {
    return true;
  }

  size_t idx = 0U;
  while (idx < length) {
    unsigned char byte = (unsigned char)data[idx];
    if (byte == '\033') {
      size_t start = idx++;
      if (idx < length) {
        unsigned char next = (unsigned char)data[idx];
        if (next == '[') {
          ++idx;
          while (idx < length) {
            unsigned char ch = (unsigned char)data[idx++];
            if (ch >= '@' && ch <= '~') {
              break;
            }
          }
        } else if (next == ']') {
          ++idx;
          while (idx < length) {
            unsigned char ch = (unsigned char)data[idx++];
            if (ch == '\a') {
              break;
            }
            if (ch == '\033' && idx < length) {
              unsigned char terminator = (unsigned char)data[idx];
              if (terminator == '\\') {
                ++idx;
                break;
              }
            }
          }
        }
      }

      if (!session_channel_write_all(ctx, data + start, idx - start)) {
        return false;
      }
      continue;
    }

    if (byte < 0x20U || byte == 0x7FU) {
      if (!session_channel_write_all(ctx, data + idx, 1U)) {
        return false;
      }
      ++idx;
      continue;
    }

    size_t start = idx;
    while (idx < length) {
      unsigned char ch = (unsigned char)data[idx];
      if (ch == '\033' || ch < 0x20U || ch == 0x7FU) {
        break;
      }
      ++idx;
    }

    if (!session_channel_write_utf16_segment(ctx, data + start, idx - start)) {
      return false;
    }
  }

  return true;
}

static bool session_channel_write_utf16_segment(session_ctx_t *ctx, const char *data, size_t length) {
  if (ctx == NULL || data == NULL || length == 0U) {
    return true;
  }

  size_t max_output = length * 4U;
  if (max_output == 0U) {
    return true;
  }

  unsigned char stack_buffer[512];
  unsigned char *buffer = NULL;
  bool use_stack = max_output <= sizeof(stack_buffer);
  if (use_stack) {
    buffer = stack_buffer;
  } else {
    buffer = (unsigned char *)GC_MALLOC(max_output);
    if (buffer == NULL) {
      return session_channel_write_all(ctx, data, length);
    }
  }

  size_t produced = 0U;
  bool encoded = session_utf8_to_utf16le(data, length, buffer, max_output, &produced);
  bool result = false;
  if (encoded) {
    result = session_channel_write_all(ctx, buffer, produced);
  } else {
    result = session_channel_write_all(ctx, data, length);
  }

  if (!use_stack) {
  }

  return result;
}

static size_t session_utf8_decode_codepoint(const unsigned char *data, size_t length, uint32_t *codepoint) {
  if (data == NULL || length == 0U || codepoint == NULL) {
    return 0U;
  }

  unsigned char b0 = data[0];
  if (b0 < 0x80U) {
    *codepoint = b0;
    return 1U;
  }

  if ((b0 & 0xE0U) == 0xC0U) {
    if (length < 2U) {
      return 0U;
    }
    unsigned char b1 = data[1];
    if ((b1 & 0xC0U) != 0x80U) {
      return 0U;
    }
    uint32_t value = ((uint32_t)(b0 & 0x1FU) << 6U) | (uint32_t)(b1 & 0x3FU);
    if (value < 0x80U) {
      return 0U;
    }
    *codepoint = value;
    return 2U;
  }

  if ((b0 & 0xF0U) == 0xE0U) {
    if (length < 3U) {
      return 0U;
    }
    unsigned char b1 = data[1];
    unsigned char b2 = data[2];
    if ((b1 & 0xC0U) != 0x80U || (b2 & 0xC0U) != 0x80U) {
      return 0U;
    }
    uint32_t value = ((uint32_t)(b0 & 0x0FU) << 12U) | ((uint32_t)(b1 & 0x3FU) << 6U) | (uint32_t)(b2 & 0x3FU);
    if (value < 0x800U || (value >= 0xD800U && value <= 0xDFFFU)) {
      return 0U;
    }
    *codepoint = value;
    return 3U;
  }

  if ((b0 & 0xF8U) == 0xF0U) {
    if (length < 4U) {
      return 0U;
    }
    unsigned char b1 = data[1];
    unsigned char b2 = data[2];
    unsigned char b3 = data[3];
    if ((b1 & 0xC0U) != 0x80U || (b2 & 0xC0U) != 0x80U || (b3 & 0xC0U) != 0x80U) {
      return 0U;
    }
    uint32_t value = ((uint32_t)(b0 & 0x07U) << 18U) | ((uint32_t)(b1 & 0x3FU) << 12U) |
                     ((uint32_t)(b2 & 0x3FU) << 6U) | (uint32_t)(b3 & 0x3FU);
    if (value < 0x10000U || value > 0x10FFFFU) {
      return 0U;
    }
    *codepoint = value;
    return 4U;
  }

  return 0U;
}

static bool session_utf8_to_utf16le(const char *input, size_t length, unsigned char *output, size_t capacity,
                                    size_t *produced) {
  if (input == NULL || output == NULL) {
    return false;
  }

  size_t out_idx = 0U;
  size_t idx = 0U;
  while (idx < length) {
    uint32_t codepoint = 0U;
    size_t consumed = session_utf8_decode_codepoint((const unsigned char *)input + idx, length - idx, &codepoint);
    if (consumed == 0U) {
      codepoint = 0xFFFD;
      consumed = 1U;
    }
    idx += consumed;

    if (codepoint <= 0xFFFFU) {
      if (codepoint >= 0xD800U && codepoint <= 0xDFFFU) {
        codepoint = 0xFFFD;
      }
      if (out_idx + 2U > capacity) {
        return false;
      }
      output[out_idx++] = (unsigned char)(codepoint & 0xFFU);
      output[out_idx++] = (unsigned char)((codepoint >> 8U) & 0xFFU);
      continue;
    }

    uint32_t adjusted = codepoint - 0x10000U;
    uint16_t high = (uint16_t)(0xD800U | ((adjusted >> 10U) & 0x3FFU));
    uint16_t low = (uint16_t)(0xDC00U | (adjusted & 0x3FFU));
    if (out_idx + 4U > capacity) {
      return false;
    }
    output[out_idx++] = (unsigned char)(high & 0xFFU);
    output[out_idx++] = (unsigned char)((high >> 8U) & 0xFFU);
    output[out_idx++] = (unsigned char)(low & 0xFFU);
    output[out_idx++] = (unsigned char)((low >> 8U) & 0xFFU);
  }

  if (produced != NULL) {
    *produced = out_idx;
  }
  return true;
}

static void session_apply_background_fill(session_ctx_t *ctx) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return;
  }

  const char *bg = ctx->system_bg_code != NULL ? ctx->system_bg_code : "";
  const size_t bg_len = strlen(bg);

  if (bg_len > 0U) {
    session_channel_write(ctx, bg, bg_len);
  }

  session_channel_write(ctx, ANSI_CLEAR_LINE, sizeof(ANSI_CLEAR_LINE) - 1U);
  session_channel_write(ctx, "\r", 1U);

  if (bg_len > 0U) {
    session_channel_write(ctx, bg, bg_len);
  }
}

static void session_write_rendered_line(session_ctx_t *ctx, const char *render_source) {
  if (ctx == NULL || render_source == NULL || !session_transport_active(ctx)) {
    return;
  }

  const char *bg = ctx->system_bg_code != NULL ? ctx->system_bg_code : "";
  const size_t bg_len = strlen(bg);

  if (bg_len == 0U) {
    session_channel_write(ctx, render_source, strlen(render_source));
    session_channel_write(ctx, "\r\n", 2U);
    return;
  }

  session_channel_write(ctx, bg, bg_len);
  session_channel_write(ctx, ANSI_CLEAR_LINE, sizeof(ANSI_CLEAR_LINE) - 1U);
  session_channel_write(ctx, "\r", 1U);

  char expanded[SSH_CHATTER_TRANSLATION_WORKING_LEN + SSH_CHATTER_MESSAGE_LIMIT];
  size_t out_idx = 0U;
  const size_t length = strlen(render_source);

  for (size_t idx = 0U; idx < length && out_idx + 1U < sizeof(expanded);) {
    if (render_source[idx] == '\033' && idx + 3U < length && render_source[idx + 1U] == '[' &&
        render_source[idx + 2U] == '0' && render_source[idx + 3U] == 'm') {
      if (out_idx + 4U >= sizeof(expanded)) {
        break;
      }

      memcpy(expanded + out_idx, render_source + idx, 4U);
      out_idx += 4U;
      idx += 4U;

      if (out_idx + bg_len >= sizeof(expanded)) {
        break;
      }
      memcpy(expanded + out_idx, bg, bg_len);
      out_idx += bg_len;
      continue;
    }

    expanded[out_idx++] = render_source[idx++];
  }

  expanded[out_idx] = '\0';

  session_channel_write(ctx, expanded, out_idx);
  session_channel_write(ctx, "\r\n", 2U);
  session_channel_write(ctx, bg, bg_len);
}

static void session_send_caption_line(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || message == NULL || !session_transport_active(ctx)) {
    return;
  }

  session_channel_write(ctx, "\r", 1U);
  session_channel_write(ctx, ANSI_INSERT_LINE, sizeof(ANSI_INSERT_LINE) - 1U);

  session_write_rendered_line(ctx, message);
}

static void session_render_caption_with_offset(session_ctx_t *ctx, const char *message, size_t move_up) {
  if (ctx == NULL || message == NULL || !session_transport_active(ctx)) {
    return;
  }

  if (move_up == 0U) {
    session_send_caption_line(ctx, message);
    return;
  }

  session_channel_write(ctx, "\033[s", 3U);

  char command[32];
  int written = snprintf(command, sizeof(command), "\033[%zuA", move_up);
  if (written > 0 && (size_t)written < sizeof(command)) {
    session_channel_write(ctx, command, (size_t)written);
  }

  session_channel_write(ctx, "\r", 1U);
  session_write_rendered_line(ctx, message);
  session_channel_write(ctx, "\033[u", 3U);
}

static void session_telnet_send_option(session_ctx_t *ctx, unsigned char command, unsigned char option) {
  if (ctx == NULL || ctx->telnet_fd < 0) {
    return;
  }

  unsigned char payload[3] = {TELNET_IAC, command, option};
  send(ctx->telnet_fd, payload, sizeof(payload), MSG_NOSIGNAL);
}

static void session_telnet_request_terminal_type(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->telnet_fd < 0 || ctx->telnet_terminal_type_requested) {
    return;
  }

  unsigned char payload[] = {TELNET_IAC, TELNET_CMD_SB, TELNET_OPT_TERMINAL_TYPE, 1U, TELNET_IAC, TELNET_CMD_SE};
  send(ctx->telnet_fd, payload, sizeof(payload), MSG_NOSIGNAL);
  ctx->telnet_terminal_type_requested = true;
}

static void session_telnet_handle_option(session_ctx_t *ctx, unsigned char command, unsigned char option) {
  if (ctx == NULL) {
    return;
  }

  switch (command) {
    case TELNET_CMD_DO:
      if (option == TELNET_OPT_SUPPRESS_GO_AHEAD || option == TELNET_OPT_ECHO) {
        session_telnet_send_option(ctx, TELNET_CMD_WILL, option);
      } else if (option == TELNET_OPT_TERMINAL_TYPE) {
        session_telnet_send_option(ctx, TELNET_CMD_WONT, option);
      } else {
        session_telnet_send_option(ctx, TELNET_CMD_WONT, option);
      }
      break;
    case TELNET_CMD_DONT:
      session_telnet_send_option(ctx, TELNET_CMD_WONT, option);
      break;
    case TELNET_CMD_WILL:
      if (option == TELNET_OPT_SUPPRESS_GO_AHEAD) {
        session_telnet_send_option(ctx, TELNET_CMD_DO, option);
      } else if (option == TELNET_OPT_TERMINAL_TYPE) {
        session_telnet_send_option(ctx, TELNET_CMD_DO, option);
        session_telnet_request_terminal_type(ctx);
      } else {
        session_telnet_send_option(ctx, TELNET_CMD_DONT, option);
      }
      break;
    case TELNET_CMD_WONT:
      session_telnet_send_option(ctx, TELNET_CMD_DONT, option);
      break;
    default:
      break;
  }
}

static void session_telnet_initialize(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->telnet_fd < 0 || ctx->telnet_negotiated) {
    return;
  }

  session_telnet_send_option(ctx, TELNET_CMD_WILL, TELNET_OPT_ECHO);
  session_telnet_send_option(ctx, TELNET_CMD_WILL, TELNET_OPT_SUPPRESS_GO_AHEAD);
  session_telnet_send_option(ctx, TELNET_CMD_DO, TELNET_OPT_SUPPRESS_GO_AHEAD);
  session_telnet_send_option(ctx, TELNET_CMD_DONT, TELNET_OPT_LINEMODE);
  session_telnet_send_option(ctx, TELNET_CMD_WONT, TELNET_OPT_STATUS);
  session_telnet_send_option(ctx, TELNET_CMD_DO, TELNET_OPT_TERMINAL_TYPE);
  session_telnet_send_option(ctx, TELNET_CMD_WONT, TELNET_OPT_TERMINAL_SPEED);
  session_telnet_send_option(ctx, TELNET_CMD_WONT, TELNET_OPT_NAWS);

  ctx->telnet_negotiated = true;
}

static int session_telnet_read_byte(session_ctx_t *ctx, unsigned char *out, int timeout_ms) {
  if (ctx == NULL || out == NULL || ctx->telnet_fd < 0) {
    return SSH_ERROR;
  }

  if (ctx->telnet_pending_valid) {
    ctx->telnet_pending_valid = false;
    *out = (unsigned char)ctx->telnet_pending_char;
    return 1;
  }

  for (;;) {
    struct pollfd pfd = {
        .fd = ctx->telnet_fd,
        .events = POLLIN,
        .revents = 0,
    };

    int poll_result = poll(&pfd, 1, timeout_ms);
    if (poll_result < 0) {
      if (errno == EINTR) {
        continue;
      }
      return SSH_ERROR;
    }
    if (poll_result == 0) {
      return SSH_AGAIN;
    }
    if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
      ctx->telnet_eof = true;
      return 0;
    }

    unsigned char byte = 0U;
    ssize_t read_result = recv(ctx->telnet_fd, &byte, 1, 0);
    if (read_result < 0) {
      if (errno == EINTR) {
        continue;
      }
      if (errno == EAGAIN || errno == EWOULDBLOCK) {
        continue;
      }
      return SSH_ERROR;
    }
    if (read_result == 0) {
      ctx->telnet_eof = true;
      return 0;
    }

    if (byte == TELNET_IAC) {
      unsigned char command = 0U;
      ssize_t command_result = recv(ctx->telnet_fd, &command, 1, 0);
      if (command_result <= 0) {
        if (command_result < 0 && errno == EINTR) {
          continue;
        }
        ctx->telnet_eof = (command_result == 0);
        return ctx->telnet_eof ? 0 : SSH_ERROR;
      }

      if (command == TELNET_IAC) {
        *out = TELNET_IAC;
        return 1;
      }

      if (command == TELNET_CMD_DO || command == TELNET_CMD_DONT || command == TELNET_CMD_WILL ||
          command == TELNET_CMD_WONT) {
        unsigned char option = 0U;
        ssize_t option_result = recv(ctx->telnet_fd, &option, 1, 0);
        if (option_result <= 0) {
          if (option_result < 0 && errno == EINTR) {
            continue;
          }
          ctx->telnet_eof = (option_result == 0);
          return ctx->telnet_eof ? 0 : SSH_ERROR;
        }
        session_telnet_handle_option(ctx, command, option);
        continue;
      }

      if (command == TELNET_CMD_SB) {
        unsigned char option = 0U;
        ssize_t option_result = recv(ctx->telnet_fd, &option, 1, 0);
        if (option_result <= 0) {
          if (option_result < 0 && errno == EINTR) {
            continue;
          }
          ctx->telnet_eof = (option_result == 0);
          return ctx->telnet_eof ? 0 : SSH_ERROR;
        }

        if (option == TELNET_OPT_TERMINAL_TYPE) {
          unsigned char qualifier = 0U;
          ssize_t qual_result = recv(ctx->telnet_fd, &qualifier, 1, 0);
          if (qual_result <= 0) {
            if (qual_result < 0 && errno == EINTR) {
              continue;
            }
            ctx->telnet_eof = (qual_result == 0);
            return ctx->telnet_eof ? 0 : SSH_ERROR;
          }

          char type_buffer[SSH_CHATTER_TERMINAL_TYPE_LEN];
          size_t type_len = 0U;
          bool finished = false;

          while (!finished) {
            unsigned char chunk = 0U;
            ssize_t chunk_result = recv(ctx->telnet_fd, &chunk, 1, 0);
            if (chunk_result < 0) {
              if (errno == EINTR) {
                continue;
              }
              if (errno == EAGAIN || errno == EWOULDBLOCK) {
                continue;
              }
              return SSH_ERROR;
            }
            if (chunk_result == 0) {
              ctx->telnet_eof = true;
              return 0;
            }

            if (chunk == TELNET_IAC) {
              unsigned char next = 0U;
              ssize_t next_result = recv(ctx->telnet_fd, &next, 1, 0);
              if (next_result < 0) {
                if (errno == EINTR) {
                  continue;
                }
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                  continue;
                }
                return SSH_ERROR;
              }
              if (next_result == 0) {
                ctx->telnet_eof = true;
                return 0;
              }

              if (next == TELNET_CMD_SE) {
                finished = true;
                break;
              }
              if (next == TELNET_IAC) {
                if (type_len + 1U < sizeof(type_buffer)) {
                  type_buffer[type_len++] = (char)TELNET_IAC;
                }
              }
              continue;
            }

            if (type_len + 1U < sizeof(type_buffer)) {
              type_buffer[type_len++] = (char)chunk;
            }
          }

          if (type_len < sizeof(type_buffer)) {
            type_buffer[type_len] = '\0';
          } else {
            type_buffer[sizeof(type_buffer) - 1U] = '\0';
          }

          if (qualifier == 0U) {
            trim_whitespace_inplace(type_buffer);
            if (type_buffer[0] != '\0') {
              for (size_t idx = 0U; type_buffer[idx] != '\0'; ++idx) {
                type_buffer[idx] = (char)toupper((unsigned char)type_buffer[idx]);
              }
              snprintf(ctx->terminal_type, sizeof(ctx->terminal_type), "%s", type_buffer);
              session_refresh_output_encoding(ctx);
            }
          }
        } else {
          unsigned char prev = 0U;
          for (;;) {
            unsigned char chunk = 0U;
            ssize_t chunk_result = recv(ctx->telnet_fd, &chunk, 1, 0);
            if (chunk_result < 0) {
              if (errno == EINTR) {
                continue;
              }
              if (errno == EAGAIN || errno == EWOULDBLOCK) {
                continue;
              }
              return SSH_ERROR;
            }
            if (chunk_result == 0) {
              ctx->telnet_eof = true;
              return 0;
            }
            if (prev == TELNET_IAC && chunk == TELNET_CMD_SE) {
              break;
            }
            prev = (chunk == TELNET_IAC) ? TELNET_IAC : 0U;
          }
        }
        continue;
      }

      if (command == TELNET_CMD_NOP || command == TELNET_CMD_DM || command == TELNET_CMD_BREAK) {
        continue;
      }

      continue;
    }

    if (byte == '\r') {
      unsigned char next = 0U;
      ssize_t next_result = recv(ctx->telnet_fd, &next, 1, MSG_PEEK);
      if (next_result > 0) {
        if (next == '\n' || next == '\0') {
          recv(ctx->telnet_fd, &next, 1, 0);
        } else {
          recv(ctx->telnet_fd, &next, 1, 0);
          ctx->telnet_pending_char = (int)next;
          ctx->telnet_pending_valid = true;
        }
      }

      *out = '\n';
      return 1;
    }

    *out = byte;
    return 1;
  }
}

static bool session_telnet_collect_line(session_ctx_t *ctx, char *buffer, size_t length) {
  if (ctx == NULL || buffer == NULL || length == 0U) {
    return false;
  }

  size_t written = 0U;
  bool ignore_next_newline = false;

  while (!ctx->should_exit) {
    unsigned char byte = 0U;
    int read_result = session_telnet_read_byte(ctx, &byte, -1);
    if (read_result == SSH_AGAIN) {
      continue;
    }
    if (read_result <= 0) {
      ctx->should_exit = true;
      return false;
    }

    if (ignore_next_newline) {
      ignore_next_newline = false;
      if (byte == '\n') {
        continue;
      }
    }

    if (byte == '\0') {
      ctx->should_exit = true;
      return false;
    }

    if (byte == '\r' || byte == '\n') {
      session_channel_write(ctx, "\r\n", 2U);
      if (byte == '\r') {
        ignore_next_newline = true;
      }
      break;
    }

    if (byte == 0x7FU || byte == '\b') {
      if (written > 0U) {
        --written;
        session_channel_write(ctx, "\b \b", 3U);
      }
      continue;
    }

    if (byte == 0x03U || byte == 0x04U) {
      ctx->should_exit = true;
      return false;
    }

    if (byte < 0x20U) {
      continue;
    }

    if (written + 1U >= length) {
      const char bell = '\a';
      session_channel_write(ctx, &bell, 1U);
      continue;
    }

    buffer[written++] = (char)byte;
    session_channel_write(ctx, (const char *)&byte, 1U);
  }

  buffer[written] = '\0';
  return !ctx->should_exit;
}

static bool session_telnet_can_use_reserved_name(session_ctx_t *ctx) {
  return ctx != NULL && ctx->lan_operator_credentials_valid;
}

static bool session_telnet_prompt_initial_nickname(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return false;
  }

  char nickname[SSH_CHATTER_USERNAME_LEN];

  while (!ctx->should_exit) {
    session_send_system_line(ctx, "Set your nickname:");
    session_channel_write(ctx, "> ", 2U);

    if (!session_telnet_collect_line(ctx, nickname, sizeof(nickname))) {
      return false;
    }

    trim_whitespace_inplace(nickname);

    const char *lang_args = NULL;
    if (session_parse_command(nickname, "/set-ui-lang", &lang_args) ||
        session_parse_command(nickname, "set-ui-lang", &lang_args)) {
      session_handle_set_ui_lang(ctx, lang_args);
      continue;
    }
    if (nickname[0] == '\0') {
      session_send_system_line(ctx, "Nickname cannot be empty.");
      continue;
    }

    bool invalid_character = false;
    for (size_t idx = 0U; nickname[idx] != '\0'; ++idx) {
      const unsigned char ch = (unsigned char)nickname[idx];
      if (ch <= 0x1FU || ch == 0x7FU || ch == ' ' || ch == '\t') {
        invalid_character = true;
        break;
      }
    }

    if (invalid_character) {
      session_send_system_line(ctx, "Names may not include control characters or whitespace.");
      continue;
    }

    if (host_is_username_banned(ctx->owner, nickname)) {
      session_send_system_line(ctx,
                               "That nickname is blocked for bot detection. Choose another.");
      continue;
    }

    if (ctx->owner != NULL && host_username_reserved(ctx->owner, nickname) &&
        !session_telnet_can_use_reserved_name(ctx)) {
      session_send_system_line(ctx, "That name is reserved for LAN operators.");
      continue;
    }

    session_ctx_t *existing = chat_room_find_user(&ctx->owner->room, nickname);
    if (existing != NULL && existing != ctx) {
      session_send_system_line(ctx, "That name is already taken.");
      continue;
    }

    snprintf(ctx->user.name, sizeof(ctx->user.name), "%s", nickname);
    return true;
  }

  return false;
}

static int session_transport_read(session_ctx_t *ctx, void *buffer, size_t length, int timeout_ms) {
  if (ctx == NULL || buffer == NULL || length == 0U) {
    return SSH_ERROR;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    unsigned char *output = (unsigned char *)buffer;
    size_t produced = 0U;

    while (produced < length) {
      unsigned char byte = 0U;
      int read_result = session_telnet_read_byte(ctx, &byte, timeout_ms);
      if (read_result == SSH_AGAIN) {
        if (produced > 0U) {
          return (int)produced;
        }
        return SSH_AGAIN;
      }
      if (read_result <= 0) {
        if (produced > 0U) {
          return (int)produced;
        }
        return read_result;
      }

      output[produced++] = byte;
      if (timeout_ms >= 0) {
        break;
      }
    }

    return (int)produced;
  }

  const uint32_t chunk = (length > UINT32_MAX) ? UINT32_MAX : (uint32_t)length;

  if (timeout_ms >= 0) {
    return ssh_channel_read_timeout(ctx->channel, buffer, chunk, 0, timeout_ms);
  }

  return ssh_channel_read(ctx->channel, buffer, chunk, 0);
}

static void session_deliver_outgoing_message(session_ctx_t *ctx, const char *message,
                                             bool clear_prompt_text) {
  if (ctx == NULL || ctx->owner == NULL || message == NULL) {
    return;
  }

  chat_history_entry_t entry = {0};
  if (!host_history_record_user(ctx->owner, ctx, message, &entry)) {
    return;
  }

  session_send_history_entry(ctx, &entry);
  if (ctx->history_scroll_position == 0U && !ctx->bracket_paste_active) {
    if (clear_prompt_text) {
      ctx->input_length = 0U;
      ctx->input_buffer[0] = '\0';
    }
    session_refresh_input_line(ctx);
  }
  chat_room_broadcast_entry(&ctx->owner->room, &entry, ctx);
  host_notify_external_clients(ctx->owner, &entry);

  (void)host_eliza_intervene(ctx, message, NULL, false);

  size_t message_length = strnlen(message, SSH_CHATTER_MESSAGE_LIMIT);

  if (!host_moderation_queue_chat(ctx, message, message_length)) {
    (void)session_security_check_text(ctx, "chat message", message, message_length, true);
  }
}

// session_send_line writes a single line while preserving the session's
// background color even when individual strings reset their ANSI attributes by
// clearing the row with the palette tint before printing.
static void session_send_line(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || !session_transport_active(ctx) || message == NULL) {
    return;
  }

  char buffer[SSH_CHATTER_MESSAGE_LIMIT + 1U];
  memset(buffer, 0, sizeof(buffer));
  strncpy(buffer, message, SSH_CHATTER_MESSAGE_LIMIT);
  buffer[SSH_CHATTER_MESSAGE_LIMIT] = '\0';

  char stripped[SSH_CHATTER_MESSAGE_LIMIT + 1U];
  bool suppress_translation = translation_strip_no_translate_prefix(buffer, stripped, sizeof(stripped));
  const char *render_text = suppress_translation ? stripped : buffer;

  session_write_rendered_line(ctx, render_text);

  size_t placeholder_lines = 0U;
  const bool scope_allows_translation =
      (!translator_should_limit_to_chat_bbs() || ctx->translation_manual_scope_override);
  const bool translation_ready = scope_allows_translation && !suppress_translation &&
                                 !ctx->translation_suppress_output && ctx->translation_enabled &&
                                 ctx->output_translation_enabled && ctx->output_translation_language[0] != '\0' &&
                                 render_text[0] != '\0';
  if (translation_ready && !ctx->in_bbs_mode && !ctx->in_rss_mode) {
    size_t spacing = ctx->translation_caption_spacing;
    if (spacing > 8U) {
      spacing = 8U;
    }
    placeholder_lines = spacing + 1U;
  }

  if (translation_ready && session_translation_queue_caption(ctx, render_text, placeholder_lines)) {
    if (placeholder_lines > 0U) {
      session_translation_reserve_placeholders(ctx, placeholder_lines);
    }
  }

  session_translation_flush_ready(ctx);
}

static size_t session_append_fragment(char *dest, size_t dest_size, size_t offset, const char *fragment) {
  if (dest == NULL || dest_size == 0U) {
    return offset;
  }

  if (offset >= dest_size) {
    return dest_size > 0U ? dest_size - 1U : offset;
  }

  if (fragment == NULL) {
    dest[offset] = '\0';
    return offset;
  }

  const size_t fragment_len = strlen(fragment);
  if (fragment_len == 0U) {
    return offset;
  }

  if (offset >= dest_size - 1U) {
    dest[dest_size - 1U] = '\0';
    return dest_size - 1U;
  }

  size_t available = dest_size - offset - 1U;
  if (fragment_len < available) {
    memcpy(dest + offset, fragment, fragment_len);
    offset += fragment_len;
  } else {
    memcpy(dest + offset, fragment, available);
    offset += available;
  }

  dest[offset] = '\0';
  return offset;
}

static void session_apply_motd_highlight(const session_ctx_t *ctx, const char *input, char *output, size_t length) {
  if (output == NULL || length == 0U) {
    return;
  }

  output[0] = '\0';
  if (ctx == NULL || input == NULL) {
    return;
  }

  const char *prefix = session_command_prefix(ctx);
  if (prefix == NULL || prefix[0] == '\0') {
    prefix = "/";
  }

  char command[32];
  snprintf(command, sizeof(command), "%smotd", prefix);

  size_t offset = 0U;
  offset = session_append_fragment(output, length, offset, "\033[37m");

  const char *cursor = input;
  const size_t command_len = strlen(command);
  while (*cursor != '\0' && offset < length - 1U) {
    const char *match = strstr(cursor, command);
    if (match == NULL) {
      offset = session_append_fragment(output, length, offset, cursor);
      break;
    }

    if (match > cursor) {
      size_t chunk_len = (size_t)(match - cursor);
      if (chunk_len > 0U) {
        char chunk[SSH_CHATTER_MESSAGE_LIMIT];
        if (chunk_len >= sizeof(chunk)) {
          chunk_len = sizeof(chunk) - 1U;
        }
        memcpy(chunk, cursor, chunk_len);
        chunk[chunk_len] = '\0';
        offset = session_append_fragment(output, length, offset, chunk);
      }
    }

    offset = session_append_fragment(output, length, offset, "\033[1;30;43m");
    offset = session_append_fragment(output, length, offset, command);
    offset = session_append_fragment(output, length, offset, "\033[0;37m");
    cursor = match + command_len;
  }

  offset = session_append_fragment(output, length, offset, "\033[0m");
}

static void session_send_plain_line(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || !session_transport_active(ctx) || message == NULL) {
    return;
  }

  static const char kCaptionPrefix[] = "    \342\206\263";
  if (strncmp(message, kCaptionPrefix, sizeof(kCaptionPrefix) - 1U) == 0) {
    session_send_caption_line(ctx, message);
    return;
  }

  session_send_line(ctx, message);
}

static void session_send_reply_tree(session_ctx_t *ctx, uint64_t parent_message_id, uint64_t parent_reply_id, size_t depth) {
  if (ctx == NULL || ctx->owner == NULL || parent_message_id == 0U) {
    return;
  }

  if (depth > 32U) {
    return;
  }

  host_t *host = ctx->owner;

  size_t match_count = 0U;
  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < host->reply_count; ++idx) {
    const chat_reply_entry_t *candidate = &host->replies[idx];
    if (!candidate->in_use) {
      continue;
    }
    if (candidate->parent_message_id == parent_message_id && candidate->parent_reply_id == parent_reply_id) {
      ++match_count;
    }
  }

  if (match_count == 0U) {
    pthread_mutex_unlock(&host->lock);
    return;
  }

  chat_reply_entry_t *snapshot = GC_CALLOC(match_count, sizeof(*snapshot));
  if (snapshot == NULL) {
    pthread_mutex_unlock(&host->lock);
    return;
  }

  size_t copy_idx = 0U;
  for (size_t idx = 0U; idx < host->reply_count && copy_idx < match_count; ++idx) {
    const chat_reply_entry_t *candidate = &host->replies[idx];
    if (!candidate->in_use) {
      continue;
    }
    if (candidate->parent_message_id == parent_message_id && candidate->parent_reply_id == parent_reply_id) {
      snapshot[copy_idx++] = *candidate;
    }
  }
  pthread_mutex_unlock(&host->lock);

  for (size_t idx = 0U; idx < copy_idx; ++idx) {
    const chat_reply_entry_t *reply = &snapshot[idx];

    size_t indent_len = depth * 4U;
    char indent[128];
    if (indent_len >= sizeof(indent)) {
      indent_len = sizeof(indent) - 1U;
    }
    memset(indent, ' ', indent_len);
    indent[indent_len] = '\0';

    const char *target_prefix = (reply->parent_reply_id == 0U) ? "#" : "r#";
    uint64_t target_id = (reply->parent_reply_id == 0U) ? reply->parent_message_id : reply->parent_reply_id;

    char line[SSH_CHATTER_MESSAGE_LIMIT + 160];
    snprintf(line, sizeof(line), "%s↳ [r#%" PRIu64 " → %s%" PRIu64 "] %s: %s", indent, reply->reply_id, target_prefix,
             target_id, reply->username, reply->message);
    session_send_plain_line(ctx, line);

    session_send_reply_tree(ctx, parent_message_id, reply->reply_id, depth + 1U);
  }

}

static bool host_lookup_member_ip(host_t *host, const char *username, char *ip, size_t length) {
  if (host == NULL || username == NULL || ip == NULL || length == 0U) {
    return false;
  }

  session_ctx_t *member = chat_room_find_user(&host->room, username);
  if (member == NULL || member->client_ip[0] == '\0') {
    return false;
  }

  snprintf(ip, length, "%s", member->client_ip);
  return true;
}

static void session_telnet_capture_startup_metadata(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->telnet_fd < 0) {
    return;
  }

  while (!ctx->telnet_eof) {
    struct pollfd pfd = {
        .fd = ctx->telnet_fd,
        .events = POLLIN,
        .revents = 0,
    };

    int poll_result = poll(&pfd, 1, 0);
    if (poll_result <= 0 || (pfd.revents & POLLIN) == 0) {
      break;
    }

    unsigned char byte = 0U;
    int read_result = session_telnet_read_byte(ctx, &byte, 0);
    if (read_result == SSH_AGAIN) {
      break;
    }
    if (read_result <= 0) {
      break;
    }

    if (byte != 0U) {
      if (!ctx->telnet_pending_valid) {
        ctx->telnet_pending_char = (int)byte;
        ctx->telnet_pending_valid = true;
      }
      break;
    }
  }
}

typedef struct provider_prefix {
    const char *prefix;
    const char *label;
  } provider_prefix_t;

  static const provider_prefix_t kProviderPrefixes[] = {
      {"39.7.", "Korean ISP"},       {"58.120.", "Korean ISP"}, {"59.0.", "Korean ISP"},
      {"61.32.", "Korean ISP"},      {"211.36.", "Korean ISP"}, {"218.144.", "Korean ISP"},
      {"73.", "US ISP"},             {"96.", "US ISP"},         {"107.", "US ISP"},
      {"174.", "US ISP"},            {"2600:", "US ISP"},       {"2604:", "US ISP"},
      {"2605:", "US ISP"},           {"2607:", "US ISP"},       {"2609:", "US ISP"},
      {"1.0.", "Japanese ISP"},       {"106.130.", "Japanese ISP"}, {"118.103.", "Japanese ISP"},
      {"126.", "Japanese ISP"},       {"133.", "Japanese ISP"},     {"153.", "Japanese ISP"},
      {"210.", "Japanese ISP"},       {"219.", "Japanese ISP"},     {"220.", "Japanese ISP"},
      {"2400:", "Japanese ISP"},     {"2404:", "Japanese ISP"},   {"2406:", "Japanese ISP"},
      {"2408:", "Japanese ISP"},
      {"24.114.", "Canadian ISP"},   {"142.", "Canadian ISP"}, {"2603:", "Canadian ISP"},
      {"185.", "EU ISP"},            {"195.", "EU ISP"},       {"2a00:", "EU ISP"},
      {"2a02:", "EU ISP"},           {"2a03:", "EU ISP"},      {"2a09:", "EU ISP"},
      {"5.18.", "Russian ISP"},      {"37.", "Russian ISP"},   {"91.", "Russian ISP"},
      {"36.", "Chinese ISP"},        {"42.", "Chinese ISP"},   {"139.", "Chinese ISP"},
      {"2408:", "Chinese ISP"},      {"2409:", "Chinese ISP"}, {"49.", "Indian ISP"},
      {"103.", "Indian ISP"},        {"106.", "Indian ISP"},   {"2405:", "Indian ISP"},
      {"2406:", "Indian ISP"},       {"100.64.", "Carrier-grade NAT"}};

static bool session_detect_provider_ip(const char *ip, char *label, size_t length) {
  if (label != NULL && length > 0U) {
    label[0] = '\0';
  }

  if (ip == NULL || ip[0] == '\0' || label == NULL || length == 0U) {
    return false;
  }

  for (size_t idx = 0U; idx < sizeof(kProviderPrefixes) / sizeof(kProviderPrefixes[0]); ++idx) {
    const provider_prefix_t *entry = &kProviderPrefixes[idx];
    size_t prefix_len = strlen(entry->prefix);
    if (strncasecmp(ip, entry->prefix, prefix_len) == 0) {
      snprintf(label, length, "%s", entry->label);
      return true;
    }
  }

  return false;
}

  static const struct {
    const char *label;
    session_ui_language_t language;
  } kProviderLanguageMapping[] = {
      {"Korean ISP", SESSION_UI_LANGUAGE_KO},
      {"US ISP", SESSION_UI_LANGUAGE_EN},
      {"Canadian ISP", SESSION_UI_LANGUAGE_EN},
      {"EU ISP", SESSION_UI_LANGUAGE_EN},
      {"Russian ISP", SESSION_UI_LANGUAGE_RU},
      {"Chinese ISP", SESSION_UI_LANGUAGE_ZH},
      {"Indian ISP", SESSION_UI_LANGUAGE_EN},
      {"Japanese ISP", SESSION_UI_LANGUAGE_JP},
  };


static session_ui_language_t session_client_geo_language(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return SESSION_UI_LANGUAGE_COUNT;
  }

  char label[64];
  if (!session_detect_provider_ip(ctx->client_ip, label, sizeof(label))) {
    return SESSION_UI_LANGUAGE_COUNT;
  }

  for (size_t idx = 0U; idx < sizeof(kProviderLanguageMapping) / sizeof(kProviderLanguageMapping[0]); ++idx) {
    if (strcasecmp(label, kProviderLanguageMapping[idx].label) == 0) {
      return kProviderLanguageMapping[idx].language;
    }
  }

  return SESSION_UI_LANGUAGE_COUNT;
}

static bool session_blocklist_add(session_ctx_t *ctx, const char *ip, const char *username, bool ip_wide,
                                  bool *already_present) {
  if (ctx == NULL) {
    if (already_present != NULL) {
      *already_present = false;
    }
    return false;
  }

  if (already_present != NULL) {
    *already_present = false;
  }

  char normalized_ip[SSH_CHATTER_IP_LEN] = {0};
  char normalized_user[SSH_CHATTER_USERNAME_LEN] = {0};

  if (ip != NULL && ip[0] != '\0') {
    snprintf(normalized_ip, sizeof(normalized_ip), "%s", ip);
  }

  if (username != NULL && username[0] != '\0') {
    snprintf(normalized_user, sizeof(normalized_user), "%s", username);
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
    session_block_entry_t *entry = &ctx->block_entries[idx];
    if (!entry->in_use) {
      continue;
    }

    if (ip_wide) {
      if (normalized_ip[0] != '\0' && strncmp(entry->ip, normalized_ip, SSH_CHATTER_IP_LEN) == 0) {
        if (already_present != NULL) {
          *already_present = true;
        }
        return false;
      }
    } else {
      if (normalized_user[0] != '\0' && strncmp(entry->username, normalized_user, SSH_CHATTER_USERNAME_LEN) == 0 &&
          !entry->ip_wide) {
        if (already_present != NULL) {
          *already_present = true;
        }
        return false;
      }
    }
  }

  size_t free_index = SSH_CHATTER_MAX_BLOCKED;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
    if (!ctx->block_entries[idx].in_use) {
      free_index = idx;
      break;
    }
  }

  if (free_index >= SSH_CHATTER_MAX_BLOCKED) {
    return false;
  }

  session_block_entry_t *slot = &ctx->block_entries[free_index];
  memset(slot, 0, sizeof(*slot));
  slot->in_use = true;
  slot->ip_wide = ip_wide;
  if (normalized_ip[0] != '\0') {
    snprintf(slot->ip, sizeof(slot->ip), "%s", normalized_ip);
  }
  if (normalized_user[0] != '\0') {
    snprintf(slot->username, sizeof(slot->username), "%s", normalized_user);
  }

  if (ctx->block_entry_count < SSH_CHATTER_MAX_BLOCKED) {
    ctx->block_entry_count += 1U;
  }

  return true;
}

static bool session_blocklist_remove(session_ctx_t *ctx, const char *token) {
  if (ctx == NULL || token == NULL || token[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
    session_block_entry_t *entry = &ctx->block_entries[idx];
    if (!entry->in_use) {
      continue;
    }

    if ((entry->ip[0] != '\0' && strncmp(entry->ip, token, SSH_CHATTER_IP_LEN) == 0) ||
        (entry->username[0] != '\0' && strncmp(entry->username, token, SSH_CHATTER_USERNAME_LEN) == 0)) {
      memset(entry, 0, sizeof(*entry));
      if (ctx->block_entry_count > 0U) {
        ctx->block_entry_count -= 1U;
      }
      return true;
    }
  }

  return false;
}

static void session_blocklist_show(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->block_entry_count == 0U) {
    session_send_system_line(ctx, "No blocked users or IPs.");
    return;
  }

  session_send_system_line(ctx, "Blocked targets:");
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
    const session_block_entry_t *entry = &ctx->block_entries[idx];
    if (!entry->in_use) {
      continue;
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    if (entry->ip_wide && entry->ip[0] != '\0') {
      if (entry->username[0] != '\0') {
        snprintf(line, sizeof(line), "- %s (all users from this IP, originally [%s])", entry->ip, entry->username);
      } else {
        snprintf(line, sizeof(line), "- %s (all users from this IP)", entry->ip);
      }
    } else if (entry->username[0] != '\0') {
      if (entry->ip[0] != '\0') {
        snprintf(line, sizeof(line), "- [%s] (only this user, IP %s)", entry->username, entry->ip);
      } else {
        snprintf(line, sizeof(line), "- [%s]", entry->username);
      }
    } else {
      snprintf(line, sizeof(line), "- entry #%zu", idx + 1U);
    }
    session_send_system_line(ctx, line);
  }
}

static bool session_bbs_should_defer_breaking(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || message == NULL) {
    return false;
  }

  if (!ctx->bbs_post_pending || ctx->bbs_rendering_editor) {
    return false;
  }

  if (strstr(message, SSH_CHATTER_RSS_BREAKING_PREFIX) != NULL) {
    return true;
  }

  if (strcasestr(message, "breaking news") != NULL || strcasestr(message, "breaking:") != NULL ||
      strcasestr(message, "urgent") != NULL || strcasestr(message, "alert") != NULL) {
    return true;
  }

  if (strstr(message, "속보") != NULL || strstr(message, "速報") != NULL) {
    return true;
  }

  return false;
}

static void session_bbs_buffer_breaking_notice(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || message == NULL) {
    return;
  }

  size_t limit = SSH_CHATTER_BBS_BREAKING_MAX;
  if (limit == 0U) {
    return;
  }

  if (ctx->bbs_breaking_count < limit) {
    snprintf(ctx->bbs_breaking_messages[ctx->bbs_breaking_count],
             sizeof(ctx->bbs_breaking_messages[ctx->bbs_breaking_count]), "%s", message);
    ctx->bbs_breaking_count += 1U;
  } else {
    for (size_t idx = 1U; idx < limit; ++idx) {
      snprintf(ctx->bbs_breaking_messages[idx - 1U], sizeof(ctx->bbs_breaking_messages[idx - 1U]), "%s",
               ctx->bbs_breaking_messages[idx]);
    }
    snprintf(ctx->bbs_breaking_messages[limit - 1U], sizeof(ctx->bbs_breaking_messages[limit - 1U]), "%s", message);
  }

  session_bbs_render_editor(ctx, NULL);
}

static bool session_should_hide_entry(session_ctx_t *ctx, const chat_history_entry_t *entry) {
  if (ctx == NULL || entry == NULL) {
    return false;
  }

  if (!entry->is_user_message) {
    return false;
  }

  if (ctx->block_entry_count == 0U) {
    return false;
  }

  if (strncmp(entry->username, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) {
    return false;
  }

  char entry_ip[SSH_CHATTER_IP_LEN] = {0};
  if (ctx->owner != NULL) {
    host_lookup_member_ip(ctx->owner, entry->username, entry_ip, sizeof(entry_ip));
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
    const session_block_entry_t *block = &ctx->block_entries[idx];
    if (!block->in_use) {
      continue;
    }

    bool ip_match = false;
    bool user_match = false;

    if (block->ip[0] != '\0' && entry_ip[0] != '\0' &&
        strncmp(block->ip, entry_ip, SSH_CHATTER_IP_LEN) == 0) {
      ip_match = true;
    }

    if (block->username[0] != '\0' &&
        strncmp(block->username, entry->username, SSH_CHATTER_USERNAME_LEN) == 0) {
      user_match = true;
    }

    if (block->ip_wide) {
      if (ip_match) {
        return true;
      }
      if (!ip_match && entry_ip[0] == '\0' && user_match) {
        return true;
      }
    } else {
      if (user_match) {
        return true;
      }
    }
  }

  return false;
}

// this displays a message to a chatting room.
static void session_send_system_line(session_ctx_t *ctx, const char *message) {
  if (ctx == NULL || !session_transport_active(ctx) || message == NULL) {
    return;
  }

  if (session_bbs_should_defer_breaking(ctx, message)) {
    session_bbs_buffer_breaking_notice(ctx, message);
    return;
  }

  const char *fg = ctx->system_fg_code != NULL ? ctx->system_fg_code : "";
  const char *bg = ctx->system_bg_code != NULL ? ctx->system_bg_code : "";
  const char *bold = ctx->system_is_bold ? ANSI_BOLD : "";

  if (message[0] == '\0') {
    char formatted_empty[SSH_CHATTER_MESSAGE_LIMIT];
    size_t offset = 0U;
    offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), offset, bg);
    offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), offset, fg);
    offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), offset, bold);
    session_append_fragment(formatted_empty, sizeof(formatted_empty), offset, ANSI_RESET);
    session_send_line(ctx, formatted_empty);
    return;
  }

  const bool scope_allows_translation =
      (!translator_should_limit_to_chat_bbs() || ctx->translation_manual_scope_override);
  const bool translation_ready = scope_allows_translation && ctx->translation_enabled &&
                                 ctx->output_translation_enabled && ctx->output_translation_language[0] != '\0' &&
                                 !ctx->in_bbs_mode && !ctx->in_rss_mode;
  const bool multiline_message = strchr(message, '\n') != NULL;
  bool translation_block = false;
  bool previous_suppress = ctx->translation_suppress_output;
  if (translation_ready && multiline_message && !ctx->translation_suppress_output) {
    translation_block = true;
    ctx->translation_suppress_output = true;
  }

  const char *cursor = message;
  for (;;) {
    const char *newline = strchr(cursor, '\n');
    size_t segment_length = newline != NULL ? (size_t)(newline - cursor) : strlen(cursor);
    if (segment_length >= SSH_CHATTER_MESSAGE_LIMIT) {
      segment_length = SSH_CHATTER_MESSAGE_LIMIT - 1U;
    }

    char segment[SSH_CHATTER_MESSAGE_LIMIT];
    memcpy(segment, cursor, segment_length);
    segment[segment_length] = '\0';

    char formatted[SSH_CHATTER_MESSAGE_LIMIT];
    size_t offset = 0U;
    offset = session_append_fragment(formatted, sizeof(formatted), offset, bg);
    offset = session_append_fragment(formatted, sizeof(formatted), offset, fg);
    offset = session_append_fragment(formatted, sizeof(formatted), offset, bold);
    offset = session_append_fragment(formatted, sizeof(formatted), offset, segment);
    session_append_fragment(formatted, sizeof(formatted), offset, ANSI_RESET);
    session_send_line(ctx, formatted);

    if (newline == NULL) {
      break;
    }

    cursor = newline + 1;
    if (*cursor == '\r') {
      ++cursor;
    }

    if (*cursor == '\0') {
      char formatted_empty[SSH_CHATTER_MESSAGE_LIMIT];
      size_t empty_offset = 0U;
      empty_offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), empty_offset, bg);
      empty_offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), empty_offset, fg);
      empty_offset = session_append_fragment(formatted_empty, sizeof(formatted_empty), empty_offset, bold);
      session_append_fragment(formatted_empty, sizeof(formatted_empty), empty_offset, ANSI_RESET);
      session_send_line(ctx, formatted_empty);
      break;
    }
  }

  if (translation_block) {
    ctx->translation_suppress_output = previous_suppress;
    if (!ctx->translation_suppress_output) {
      session_translation_queue_block(ctx, message);
      session_translation_flush_ready(ctx);
    }
    return;
  }

  ctx->translation_suppress_output = previous_suppress;
}

static void session_send_raw_text(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || !session_transport_active(ctx) || text == NULL) {
    return;
  }

  const char *cursor = text;
  while (*cursor != '\0') {
    const char *newline = strchr(cursor, '\n');
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    if (newline == NULL) {
      snprintf(line, sizeof(line), "%s", cursor);
      session_send_plain_line(ctx, line);
      break;
    }

    size_t length = (size_t)(newline - cursor);
    if (length >= sizeof(line)) {
      length = sizeof(line) - 1U;
    }
    memcpy(line, cursor, length);
    line[length] = '\0';
    session_send_plain_line(ctx, line);

    cursor = newline + 1;
    if (*cursor == '\r') {
      ++cursor;
    }
    if (*cursor == '\0') {
      session_send_plain_line(ctx, "");
    }
  }
}

static void session_send_raw_text_bulk(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || text == NULL) {
    return;
  }

  const bool scope_allows_translation =
      (!translator_should_limit_to_chat_bbs() || ctx->translation_manual_scope_override);
  const bool translation_ready = scope_allows_translation && ctx->translation_enabled &&
                                 ctx->output_translation_enabled && ctx->output_translation_language[0] != '\0' &&
                                 !ctx->in_bbs_mode && !ctx->in_rss_mode;

  bool previous_suppress = ctx->translation_suppress_output;
  if (translation_ready && !ctx->translation_suppress_output) {
    ctx->translation_suppress_output = true;
  }

  session_send_raw_text(ctx, text);

  ctx->translation_suppress_output = previous_suppress;

  if (translation_ready && !previous_suppress && text[0] != '\0') {
    session_translation_queue_block(ctx, text);
    session_translation_flush_ready(ctx);
  }
}

static void session_format_separator_line(session_ctx_t *ctx, const char *label, char *out, size_t length) {
  if (out == NULL || length == 0U) {
    return;
  }

  out[0] = '\0';

  if (ctx == NULL || label == NULL) {
    return;
  }

  const char *fg = ctx->system_fg_code != NULL ? ctx->system_fg_code : "";
  const char *hl = ctx->system_highlight_code != NULL ? ctx->system_highlight_code : "";
  const char *bold = ctx->system_is_bold ? ANSI_BOLD : "";

  const size_t total_width = 80U;
  char label_block[96];
  snprintf(label_block, sizeof(label_block), " %s ", label);
  size_t label_len = strnlen(label_block, sizeof(label_block) - 1U);
  if (label_len > total_width) {
    label_len = total_width;
    label_block[label_len] = '\0';
  }

  size_t dash_total = total_width > label_len ? total_width - label_len : 0U;
  size_t left = dash_total / 2U;
  size_t right = dash_total - left;

  char body[128];
  size_t offset = 0U;
  for (size_t idx = 0U; idx < left && offset + 1U < sizeof(body); ++idx) {
    body[offset++] = '-';
  }
  if (offset + label_len < sizeof(body)) {
    memcpy(body + offset, label_block, label_len);
    offset += label_len;
  }
  for (size_t idx = 0U; idx < right && offset < sizeof(body); ++idx) {
    body[offset++] = '-';
  }
  body[offset] = '\0';

  snprintf(out, length, "%s%s%s%s%s", hl, fg, bold, body, ANSI_RESET);
}

static void session_render_separator(session_ctx_t *ctx, const char *label) {
  if (ctx == NULL || label == NULL) {
    return;
  }

  char line[SSH_CHATTER_MESSAGE_LIMIT];
  session_format_separator_line(ctx, label, line, sizeof(line));
  if (line[0] != '\0') {
    session_send_line(ctx, line);
  }
}

static void session_clear_screen(session_ctx_t *ctx) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return;
  }

  static const char kClearSequence[] = "\033[2J\033[H";
  session_channel_write(ctx, kClearSequence, sizeof(kClearSequence) - 1U);
}

static void session_bbs_prepare_canvas(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_clear_screen(ctx);
  session_apply_background_fill(ctx);
}

static void session_bbs_recalculate_line_count(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  size_t count = 0U;
  if (ctx->pending_bbs_body_length > 0U) {
    count = 1U;
    for (size_t idx = 0U; idx < ctx->pending_bbs_body_length; ++idx) {
      if (ctx->pending_bbs_body[idx] == '\n') {
        ++count;
      }
    }
  }

  ctx->pending_bbs_line_count = count;
  if (ctx->pending_bbs_cursor_line > count) {
    ctx->pending_bbs_cursor_line = count;
    ctx->pending_bbs_editing_line = false;
  }
}

static bool session_bbs_get_line_range(const session_ctx_t *ctx, size_t line_index, size_t *start, size_t *length) {
  if (ctx == NULL || start == NULL || length == NULL) {
    return false;
  }

  if (line_index >= ctx->pending_bbs_line_count) {
    return false;
  }

  size_t offset = 0U;
  size_t current = 0U;
  while (current < line_index && offset < ctx->pending_bbs_body_length) {
    const char *newline = memchr(ctx->pending_bbs_body + offset, '\n', ctx->pending_bbs_body_length - offset);
    if (newline == NULL) {
      return false;
    }
    offset = (size_t)(newline - ctx->pending_bbs_body) + 1U;
    ++current;
  }

  if (offset > ctx->pending_bbs_body_length) {
    return false;
  }

  size_t end = ctx->pending_bbs_body_length;
  const char *newline = memchr(ctx->pending_bbs_body + offset, '\n', ctx->pending_bbs_body_length - offset);
  if (newline != NULL) {
    end = (size_t)(newline - ctx->pending_bbs_body);
  }

  *start = offset;
  *length = end - offset;
  return true;
}

static void session_bbs_copy_line(const session_ctx_t *ctx, size_t line_index, char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }

  buffer[0] = '\0';
  size_t start = 0U;
  size_t line_length = 0U;
  if (!session_bbs_get_line_range(ctx, line_index, &start, &line_length)) {
    return;
  }

  if (line_length >= length) {
    line_length = length - 1U;
  }

  if (line_length > 0U) {
    memcpy(buffer, ctx->pending_bbs_body + start, line_length);
  }
  buffer[line_length] = '\0';
}

static size_t session_editor_body_capacity(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return 0U;
  }

  if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
    if (ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE &&
        USER_DATA_PROFILE_PICTURE_LEN < SSH_CHATTER_ASCIIART_BUFFER_LEN) {
      return USER_DATA_PROFILE_PICTURE_LEN;
    }
    return SSH_CHATTER_ASCIIART_BUFFER_LEN;
  }

  return sizeof(ctx->pending_bbs_body);
}

static size_t session_editor_max_lines(const session_ctx_t *ctx) {
  if (ctx != NULL && ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
    return SSH_CHATTER_ASCIIART_MAX_LINES;
  }

  return SIZE_MAX;
}

static bool session_bbs_append_line(session_ctx_t *ctx, const char *line, char *status, size_t status_length) {
  if (ctx == NULL) {
    return false;
  }

  const bool ascii_mode = ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART;
  if (status != NULL && status_length > 0U) {
    status[0] = '\0';
  }

  if (line == NULL) {
    line = "";
  }

  const char *length_limit_message =
      ascii_mode ? "ASCII art buffer is full. Additional text ignored." : "Post body length limit reached. Additional text ignored.";
  const char *line_limit_message = ascii_mode ? "ASCII art line limit reached. Additional text ignored."
                                             : "Post line limit reached. Additional text ignored.";
  const char *line_truncated_message = ascii_mode ? "Line truncated to fit within the ASCII art size limit."
                                                  : "Line truncated to fit within the post size limit.";

  size_t capacity = session_editor_body_capacity(ctx);
  if (capacity == 0U) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "%s", length_limit_message);
    }
    return false;
  }

  if (ctx->pending_bbs_body_length >= capacity - 1U) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "%s", length_limit_message);
    }
    return false;
  }

  session_bbs_recalculate_line_count(ctx);
  size_t max_lines = session_editor_max_lines(ctx);
  if (ctx->pending_bbs_line_count >= max_lines) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "%s", line_limit_message);
    }
    return false;
  }

  size_t available = capacity - ctx->pending_bbs_body_length - 1U;
  if (available == 0U) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "%s", length_limit_message);
    }
    return false;
  }

  bool needs_newline = ctx->pending_bbs_body_length > 0U;
  if (needs_newline) {
    if (available == 0U) {
      if (status != NULL && status_length > 0U) {
        snprintf(status, status_length, "%s", length_limit_message);
      }
      return false;
    }
    ctx->pending_bbs_body[ctx->pending_bbs_body_length++] = '\n';
    --available;
  }

  size_t line_length = strlen(line);
  if (line_length > available) {
    line_length = available;
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "%s", line_truncated_message);
    }
  }

  if (line_length > 0U) {
    memcpy(ctx->pending_bbs_body + ctx->pending_bbs_body_length, line, line_length);
    ctx->pending_bbs_body_length += line_length;
  }

  ctx->pending_bbs_body[ctx->pending_bbs_body_length] = '\0';
  session_bbs_recalculate_line_count(ctx);
  ctx->pending_bbs_cursor_line = ctx->pending_bbs_line_count;
  ctx->pending_bbs_editing_line = false;
  return true;
}

static bool session_bbs_replace_line(session_ctx_t *ctx, size_t line_index, const char *line, char *status,
                                     size_t status_length) {
  if (ctx == NULL || line == NULL) {
    return false;
  }

  const bool ascii_mode = ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART;
  if (status != NULL && status_length > 0U) {
    status[0] = '\0';
  }

  session_bbs_recalculate_line_count(ctx);
  if (line_index >= ctx->pending_bbs_line_count) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "Unable to locate the selected line.");
    }
    return false;
  }

  size_t start = 0U;
  size_t old_length = 0U;
  if (!session_bbs_get_line_range(ctx, line_index, &start, &old_length)) {
    if (status != NULL && status_length > 0U) {
      snprintf(status, status_length, "Unable to locate the selected line.");
    }
    return false;
  }

  size_t current_length = ctx->pending_bbs_body_length;
  size_t capacity = session_editor_body_capacity(ctx);
  if (capacity == 0U) {
    return false;
  }
  if (capacity > 0U) {
    --capacity;
  }
  size_t base_length = current_length - old_length;
  size_t max_allowed = (capacity > base_length) ? (capacity - base_length) : 0U;

  size_t new_length = strlen(line);
  if (new_length > max_allowed) {
    new_length = max_allowed;
    if (status != NULL && status_length > 0U) {
      const char *line_truncated_message =
          ascii_mode ? "Line truncated to fit within the ASCII art size limit."
                     : "Line truncated to fit within the post size limit.";
      snprintf(status, status_length, "%s", line_truncated_message);
    }
  }

  size_t tail_offset = start + old_length;
  size_t tail_bytes = current_length - tail_offset + 1U;

  if (new_length > old_length) {
    size_t shift = new_length - old_length;
    memmove(ctx->pending_bbs_body + tail_offset + shift, ctx->pending_bbs_body + tail_offset, tail_bytes);
  } else if (old_length > new_length) {
    size_t shift = old_length - new_length;
    memmove(ctx->pending_bbs_body + tail_offset - shift, ctx->pending_bbs_body + tail_offset, tail_bytes);
    tail_offset -= shift;
  }

  if (new_length > 0U) {
    memcpy(ctx->pending_bbs_body + start, line, new_length);
  }

  ctx->pending_bbs_body_length = base_length + new_length;
  ctx->pending_bbs_body[ctx->pending_bbs_body_length] = '\0';

  session_bbs_recalculate_line_count(ctx);
  size_t updated_count = ctx->pending_bbs_line_count;
  if (line_index + 1U <= updated_count) {
    ctx->pending_bbs_cursor_line = line_index + 1U;
  } else {
    ctx->pending_bbs_cursor_line = updated_count;
  }
  ctx->pending_bbs_editing_line = false;
  return true;
}

static void session_bbs_render_editor(session_ctx_t *ctx, const char *status) {
  if (ctx == NULL) {
    return;
  }

  const bool ascii_mode = ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART;
  const bool editing_post = ctx->editor_mode == SESSION_EDITOR_MODE_BBS_EDIT;

  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;
  ctx->bbs_rendering_editor = true;

  session_bbs_prepare_canvas(ctx);
  session_bbs_recalculate_line_count(ctx);
  size_t line_count = ctx->pending_bbs_line_count;

  if (ascii_mode) {
    const char *target_label =
        (ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE) ? "profile picture" : "chat";
    char title_line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(title_line, sizeof(title_line), "ASCII art %s draft (%zu/%u lines)", target_label, line_count,
             (unsigned int)SSH_CHATTER_ASCIIART_MAX_LINES);
    session_send_system_line(ctx, title_line);
  } else {
    char title_line[SSH_CHATTER_MESSAGE_LIMIT];
    if (editing_post) {
      if (ctx->pending_bbs_edit_id != 0U) {
        snprintf(title_line, sizeof(title_line), "Editing post #%" PRIu64 " '%s'", ctx->pending_bbs_edit_id,
                 ctx->pending_bbs_title);
      } else {
        snprintf(title_line, sizeof(title_line), "Editing '%s'", ctx->pending_bbs_title);
      }
    } else {
      snprintf(title_line, sizeof(title_line), "Composing '%s'", ctx->pending_bbs_title);
    }
    session_send_system_line(ctx, title_line);

    char tag_buffer[SSH_CHATTER_BBS_MAX_TAGS * (SSH_CHATTER_BBS_TAG_LEN + 2U)];
    tag_buffer[0] = '\0';
    size_t offset = 0U;
    for (size_t idx = 0U; idx < ctx->pending_bbs_tag_count; ++idx) {
      size_t remaining = sizeof(tag_buffer) - offset;
      if (remaining == 0U) {
        break;
      }
      int written = snprintf(tag_buffer + offset, remaining, "%s%s", idx > 0U ? "," : "", ctx->pending_bbs_tags[idx]);
      if (written < 0) {
        break;
      }
      if ((size_t)written >= remaining) {
        offset = sizeof(tag_buffer) - 1U;
        break;
      }
      offset += (size_t)written;
    }

    char tags_line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(tags_line, sizeof(tags_line), "Tags: %s", tag_buffer[0] != '\0' ? tag_buffer : "(none)");
    session_send_system_line(ctx, tags_line);
  }

  session_send_system_line(ctx, SSH_CHATTER_BBS_EDITOR_BODY_DIVIDER);

  if (line_count == 0U) {
    const char *prefix = ctx->pending_bbs_editing_line ? "> " : "> ";
    session_send_line(ctx, prefix);
  } else {
    for (size_t idx = 0U; idx < line_count; ++idx) {
      char line_buffer[SSH_CHATTER_MESSAGE_LIMIT];
      session_bbs_copy_line(ctx, idx, line_buffer, sizeof(line_buffer));
      bool selected = ctx->pending_bbs_editing_line && ctx->pending_bbs_cursor_line == idx;
      const char *prefix = selected ? "> " : "  ";
      char display[SSH_CHATTER_MESSAGE_LIMIT];
      if (line_buffer[0] == '\0') {
        snprintf(display, sizeof(display), "%s", prefix);
      } else {
        snprintf(display, sizeof(display), "%s%s", prefix, line_buffer);
      }
      session_send_line(ctx, display);
    }
    if (!ctx->pending_bbs_editing_line) {
      session_send_line(ctx, "> ");
    }
  }

  session_send_system_line(ctx, SSH_CHATTER_BBS_EDITOR_END_DIVIDER);

  size_t capacity = session_editor_body_capacity(ctx);
  size_t remaining = 0U;
  if (capacity > ctx->pending_bbs_body_length) {
    remaining = capacity - ctx->pending_bbs_body_length - 1U;
  }
  char remaining_line[64];
  snprintf(remaining_line, sizeof(remaining_line), "Remaining bytes: %zu", remaining);
  session_send_system_line(ctx, remaining_line);

  const char *terminator = session_editor_terminator(ctx);
  char shortcut_hint[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(shortcut_hint, sizeof(shortcut_hint), "Ctrl+S(or Save) inserts %s. Ctrl+A(or Abort) cancels the draft.", terminator);
  session_send_system_line(ctx, shortcut_hint);
  session_send_system_line(ctx, "Use Up/Down arrows to revisit a saved line and press Enter to store changes.");
  char publish_hint[SSH_CHATTER_MESSAGE_LIMIT];
  if (ascii_mode) {
    snprintf(publish_hint, sizeof(publish_hint), "Typing %s on its own line will finish the artwork.", terminator);
  } else if (editing_post) {
    snprintf(publish_hint, sizeof(publish_hint), "Typing %s on its own line will update the post.", terminator);
  } else {
    snprintf(publish_hint, sizeof(publish_hint), "Typing %s on its own line will publish the post.", terminator);
  }
  session_send_system_line(ctx, publish_hint);

  if (ctx->bbs_breaking_count > 0U && !ascii_mode) {
    session_send_system_line(ctx, "");
    session_send_system_line(ctx, "Breaking updates:");
    for (size_t idx = 0U; idx < ctx->bbs_breaking_count; ++idx) {
      session_send_system_line(ctx, ctx->bbs_breaking_messages[idx]);
    }
  }

  if (status != NULL && status[0] != '\0') {
    char working[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(working, sizeof(working), "%s", status);
    char *cursor = working;
    while (cursor != NULL && *cursor != '\0') {
      char *newline = strchr(cursor, '\n');
      if (newline != NULL) {
        *newline = '\0';
      }
      if (*cursor != '\0') {
        session_send_system_line(ctx, cursor);
      }
      if (newline == NULL) {
        break;
      }
      cursor = newline + 1;
    }
  }

  session_render_prompt(ctx, false);
  ctx->bbs_rendering_editor = false;
}

static void session_bbs_move_cursor(session_ctx_t *ctx, int direction) {
  if (ctx == NULL || direction == 0) {
    return;
  }

  session_bbs_recalculate_line_count(ctx);
  size_t line_count = ctx->pending_bbs_line_count;

  if (line_count == 0U) {
    ctx->pending_bbs_cursor_line = 0U;
    ctx->pending_bbs_editing_line = false;
    session_set_input_text(ctx, "");
    session_bbs_render_editor(ctx, NULL);
    return;
  }

  size_t target = ctx->pending_bbs_cursor_line;
  bool editing = ctx->pending_bbs_editing_line;
  if (target > line_count) {
    target = line_count;
  }

  if (direction < 0) {
    if (!editing) {
      target = line_count - 1U;
      editing = true;
    } else {
      if (target > 0U) {
        --target;
      }
    }
  } else {
    if (editing) {
      if (target + 1U < line_count) {
        ++target;
      } else {
        target = line_count;
        editing = false;
      }
    }
  }

  ctx->pending_bbs_cursor_line = target;
  ctx->pending_bbs_editing_line = editing;

  char status[64];
  status[0] = '\0';

  if (editing && target < line_count) {
    char line_buffer[SSH_CHATTER_MAX_INPUT_LEN];
    session_bbs_copy_line(ctx, target, line_buffer, sizeof(line_buffer));
    session_set_input_text(ctx, line_buffer);
    snprintf(status, sizeof(status), "Editing line %zu of %zu.", target + 1U, line_count);
  } else {
    session_set_input_text(ctx, "");
    snprintf(status, sizeof(status), "Editing new line %zu.", line_count + 1U);
  }

  session_bbs_render_editor(ctx, status);
}

static bool session_render_external_banner(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  static const char kExternalBannerPath[] = "/var/lib/ssh-chatter/banner";

  struct stat banner_info;
  if (stat(kExternalBannerPath, &banner_info) != 0 || !S_ISREG(banner_info.st_mode)) {
    return false;
  }

  FILE *banner_file = fopen(kExternalBannerPath, "r");
  if (banner_file == NULL) {
    return false;
  }

  char line[SSH_CHATTER_MESSAGE_LIMIT];
  bool rendered = false;
  while (fgets(line, sizeof(line), banner_file) != NULL) {
    size_t length = strlen(line);
    while (length > 0U && (line[length - 1U] == '\n' || line[length - 1U] == '\r')) {
      line[--length] = '\0';
    }

    session_send_plain_line(ctx, line);
    rendered = true;
  }

  fclose(banner_file);
  return rendered;
}

static void session_render_banner_ascii(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  static const char *kBanner[] = {
      "\033[1;35m+===================================================================+\033[0m",
      "\033[1;36m|  ██████╗██╗  ██╗ █████╗ ████████╗████████╗███████╗██████╗         |\033[0m",
      "\033[1;36m| ██╔════╝██║  ██║██╔══██╗╚══██╔══╝╚══██╔══╝██╔════╝██╔══██╗        |\033[0m",
      "\033[1;34m| ██║     ███████║███████║   ██║      ██║   █████╗  ██████╔╝        |\033[0m",
      "\033[1;34m| ██║     ██╔══██║██╔══██║   ██║      ██║   ██╔══╝  ██╔══██╗        |\033[0m",
      "\033[1;32m| ╚██████╗██║  ██║██║  ██║   ██║      ██║   ███████╗██║  ██║        |\033[0m",
      "\033[1;32m|  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚═╝  ╚═╝        |\033[0m",
      "\033[1;35m+===================================================================+\033[0m",
      "\033[1;36m|        *** Welcome to CHATTER (2025) ***                          |\033[0m",
      "\033[1;35m|   Cute and tiny SSH chat written in C.                            |\033[0m",
      "\033[1;36m|   Type \033[1;33m/help\033[1;36m to see available commands.                           |\033[0m",
      "\033[1;36m|   Type \033[1;33m/mode\033[1;36m to switch input modes.                               |\033[0m",
      "\033[1;35m+===================================================================+\033[0m",
  };

  for (size_t idx = 0; idx < sizeof(kBanner) / sizeof(kBanner[0]); ++idx) {
    session_send_system_line(ctx, kBanner[idx]);
  }
}


static void session_render_prelogin_language_prompt(session_ctx_t *ctx) {
  if (ctx == NULL || session_client_geo_language(ctx) != SESSION_UI_LANGUAGE_KO) {
    return;
  }

  session_send_system_line(ctx, "기본 UI 언어는 한국어입니다. 로그인 전에 원하는 언어를 선택하세요.");
  session_send_system_line(ctx, "Default UI language is Korean. Choose one before logging in:");

  const char *prefix = session_command_prefix(ctx);
  static const struct {
    const char *code;
    const char *label;
  } kLanguagePrompts[] = {
      {"en", "English"},
      {"jp", "日本語 / Japanese"},
      {"zh", "中文 / Chinese"},
      {"ru", "Русский / Russian"},
  };

  for (size_t idx = 0; idx < sizeof(kLanguagePrompts) / sizeof(kLanguagePrompts[0]); ++idx) {
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "  %sset-ui-lang %s  → %s", prefix, kLanguagePrompts[idx].code,
             kLanguagePrompts[idx].label);
    session_send_system_line(ctx, line);
  }

  session_send_system_line(ctx, "명령을 입력하면 해당 언어로 전환되고, Enter를 누르면 한국어가 유지됩니다.");
  session_send_system_line(ctx, "Run one of the commands above to switch, or press Enter to keep Korean.");
}

static void session_render_prelogin_banner(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->prelogin_banner_rendered) {
    return;
  }

  session_apply_background_fill(ctx);

  bool has_external_banner = session_render_external_banner(ctx);
  if (!has_external_banner) {
    session_render_banner_ascii(ctx);
  }

  session_send_plain_line(ctx, "\033[37mConnection established.\033[0m");
  session_send_plain_line(ctx, "\033[37mAuthenticate or choose a nickname to continue.\033[0m");

  session_render_prelogin_language_prompt(ctx);

  ctx->prelogin_banner_rendered = true;
}

static void session_render_banner(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_apply_background_fill(ctx);

  bool show_graphics = !ctx->prelogin_banner_rendered;
  bool has_external_banner = false;
  if (show_graphics) {
    has_external_banner = session_render_external_banner(ctx);
    if (!has_external_banner) {
      session_render_banner_ascii(ctx);
    }
  }

  char welcome[SSH_CHATTER_MESSAGE_LIMIT];
  size_t name_len = 0;
  if (ctx->user.name[0] != '\0')
    name_len = strlen(ctx->user.name);
  int welcome_padding = 55 - (int)name_len;
  if (welcome_padding < 0) {
    welcome_padding = 0;
  }

  snprintf(welcome, sizeof(welcome), "\033[1;32m|  Welcome, %s!%*s|\033[0m", ctx->user.name, welcome_padding, "");
  session_send_system_line(ctx, welcome);

  char version_line[SSH_CHATTER_MESSAGE_LIMIT];
  size_t version_len = strlen(ctx->owner->version);
  int version_padding = 65 - (int)version_len;
  if (version_padding < 0) {
    version_padding = 0;
  }
  snprintf(version_line, sizeof(version_line), "\033[1;32m|  %s%*s|\033[0m", ctx->owner->version, version_padding, "");
  session_send_system_line(ctx, version_line);

  if (show_graphics && !has_external_banner) {
    session_send_system_line(ctx, "\033[1;32m+===================================================================+\033[0m");
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);

  if (locale->welcome_help_hint != NULL && locale->welcome_help_hint[0] != '\0') {
    const char *args[] = {prefix};
    char hint[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(locale->welcome_help_hint, args, sizeof(args) / sizeof(args[0]), hint, sizeof(hint));
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "\033[37m%s\033[0m", hint);
    session_send_plain_line(ctx, line);
  }

  if (locale->welcome_motd_hint != NULL && locale->welcome_motd_hint[0] != '\0') {
    const char *args[] = {prefix};
    char hint[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(locale->welcome_motd_hint, args, sizeof(args) / sizeof(args[0]), hint, sizeof(hint));
    char highlighted[SSH_CHATTER_MESSAGE_LIMIT];
    session_apply_motd_highlight(ctx, hint, highlighted, sizeof(highlighted));
    session_send_plain_line(ctx, highlighted);
  }
  session_render_separator(ctx, "Chatroom");
}

static void session_render_prompt(session_ctx_t *ctx, bool include_separator) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return;
  }

  if (include_separator) {
    session_render_separator(ctx, "Input");
  }

  session_apply_background_fill(ctx);

  const char *fg = ctx->system_fg_code != NULL ? ctx->system_fg_code : "";
  const char *hl = ctx->system_highlight_code != NULL ? ctx->system_highlight_code : "";
  const char *bold = ctx->system_is_bold ? ANSI_BOLD : "";
  const char *bg = ctx->system_bg_code != NULL ? ctx->system_bg_code : "";
  const char *mode_prompt = ctx->input_mode == SESSION_INPUT_MODE_COMMAND ? "│ cmd> " : "│ > ";

  char prompt[128];
  size_t offset = 0U;
  offset = session_append_fragment(prompt, sizeof(prompt), offset, hl);
  offset = session_append_fragment(prompt, sizeof(prompt), offset, fg);
  offset = session_append_fragment(prompt, sizeof(prompt), offset, bold);
  offset = session_append_fragment(prompt, sizeof(prompt), offset, mode_prompt);
  offset = session_append_fragment(prompt, sizeof(prompt), offset, ANSI_RESET);
  if (bg[0] != '\0') {
    offset = session_append_fragment(prompt, sizeof(prompt), offset, bg);
  }
  if (fg[0] != '\0') {
    offset = session_append_fragment(prompt, sizeof(prompt), offset, fg);
  }
  if (bold[0] != '\0') {
    offset = session_append_fragment(prompt, sizeof(prompt), offset, bold);
  }

  session_channel_write(ctx, prompt, offset);
  if (ctx->input_length > 0U) {
    session_channel_write(ctx, ctx->input_buffer, ctx->input_length);
  }
}

static void session_refresh_input_line(session_ctx_t *ctx) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return;
  }

  const char *bg = ctx->system_bg_code != NULL ? ctx->system_bg_code : "";
  if (bg[0] != '\0') {
    session_channel_write(ctx, bg, strlen(bg));
  }

  static const char clear_sequence[] = "\r" ANSI_CLEAR_LINE;
  session_channel_write(ctx, clear_sequence, sizeof(clear_sequence) - 1U);

  if (bg[0] != '\0') {
    session_channel_write(ctx, bg, strlen(bg));
  }

  session_render_prompt(ctx, false);
}

static void session_set_input_text(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL) {
    return;
  }

  ctx->input_length = 0U;
  memset(ctx->input_buffer, 0, sizeof(ctx->input_buffer));

  if (text != NULL && text[0] != '\0') {
    const size_t len = strnlen(text, sizeof(ctx->input_buffer) - 1U);
    memcpy(ctx->input_buffer, text, len);
    ctx->input_buffer[len] = '\0';
    ctx->input_length = len;
  }

  session_refresh_input_line(ctx);
}

static void session_local_echo_char(session_ctx_t *ctx, char ch) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return;
  }

  if (ch == '\r' || ch == '\n') {
    session_channel_write(ctx, "\r\n", 2U);
    return;
  }

  session_channel_write(ctx, &ch, 1U);
}

static size_t session_utf8_prev_char_len(const char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return 0U;
  }

  size_t idx = length;
  while (idx > 0U) {
    --idx;
    const unsigned char byte = (unsigned char)buffer[idx];
    if ((byte & 0xC0U) != 0x80U) {
      const size_t seq_len = length - idx;
      size_t expected = 1U;
      if ((byte & 0x80U) == 0U) {
        expected = 1U;
      } else if ((byte & 0xE0U) == 0xC0U) {
        expected = 2U;
      } else if ((byte & 0xF0U) == 0xE0U) {
        expected = 3U;
      } else if ((byte & 0xF8U) == 0xF0U) {
        expected = 4U;
      } else {
        expected = 1U;
      }

      if (seq_len < expected) {
        return seq_len;
      }
      return expected;
    }
  }

  return 1U;
}

static int session_utf8_char_width(const char *bytes, size_t length) {
  if (bytes == NULL || length == 0U) {
    return 0;
  }

  mbstate_t state;
  memset(&state, 0, sizeof(state));

  wchar_t wc;
  const size_t result = mbrtowc(&wc, bytes, length, &state);
  if (result == (size_t)-1 || result == (size_t)-2) {
    return 1;
  }

  const int width = wcwidth(wc);
  if (width < 0) {
    return 1;
  }

  return width;
}

static void session_local_backspace(session_ctx_t *ctx) {
  if (ctx == NULL || !session_transport_active(ctx) || ctx->input_length == 0U) {
    return;
  }

  const size_t char_len = session_utf8_prev_char_len(ctx->input_buffer, ctx->input_length);
  if (char_len == 0U || char_len > ctx->input_length) {
    return;
  }

  const size_t char_start = ctx->input_length - char_len;
  const int display_width = session_utf8_char_width(&ctx->input_buffer[char_start], char_len);

  ctx->input_length = char_start;
  ctx->input_buffer[ctx->input_length] = '\0';

  const int width = display_width > 0 ? display_width : 1;
  const char sequence[] = "\b \b";
  for (int idx = 0; idx < width; ++idx) {
    session_channel_write(ctx, sequence, sizeof(sequence) - 1U);
  }
}

static void session_clear_input(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  ctx->input_length = 0U;
  memset(ctx->input_buffer, 0, sizeof(ctx->input_buffer));
  ctx->input_history_position = -1;
  ctx->input_escape_active = false;
  ctx->input_escape_length = 0U;
  if (!ctx->bracket_paste_active) {
    session_refresh_input_line(ctx);
  }
}

static bool session_try_command_completion(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->input_length == 0U) {
    return false;
  }

  size_t first_visible = 0U;
  while (first_visible < ctx->input_length && isspace((unsigned char)ctx->input_buffer[first_visible])) {
    ++first_visible;
  }
  if (first_visible >= ctx->input_length) {
    return false;
  }

  const bool has_slash = ctx->input_buffer[first_visible] == '/';
  if (!has_slash && ctx->input_mode != SESSION_INPUT_MODE_COMMAND) {
    return false;
  }

  size_t command_start = first_visible + (has_slash ? 1U : 0U);
  if (command_start > ctx->input_length) {
    command_start = ctx->input_length;
  }

  size_t command_end = command_start;
  while (command_end < ctx->input_length && !isspace((unsigned char)ctx->input_buffer[command_end])) {
    ++command_end;
  }

  const size_t token_len = command_end - command_start;
  char prefix[SSH_CHATTER_MAX_INPUT_LEN];
  size_t copy_len = token_len < sizeof(prefix) - 1U ? token_len : sizeof(prefix) - 1U;
  if (copy_len > 0U) {
    memcpy(prefix, &ctx->input_buffer[command_start], copy_len);
  }
  prefix[copy_len] = '\0';

  const size_t prefix_len = strlen(prefix);
  const char *matches[SSH_CHATTER_COMMAND_COUNT];
  size_t match_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_COMMAND_COUNT; ++idx) {
    const char *candidate = kSessionCommandNames[idx];
    if (prefix_len == 0U || strncasecmp(candidate, prefix, prefix_len) == 0) {
      matches[match_count++] = candidate;
    }
  }

  session_command_collect_localized_matches(ctx, prefix, matches, &match_count,
                                            sizeof(matches) / sizeof(matches[0]));

  if (match_count == 0U) {
    if (session_transport_active(ctx)) {
      const char bell = '\a';
      session_channel_write(ctx, &bell, 1U);
    }
    session_refresh_input_line(ctx);
    return true;
  }

  char updated[SSH_CHATTER_MAX_INPUT_LEN];
  size_t updated_len = 0U;
  const size_t prefix_copy_len = command_start < sizeof(updated) ? command_start : sizeof(updated) - 1U;
  if (prefix_copy_len > 0U) {
    memcpy(updated, ctx->input_buffer, prefix_copy_len);
    updated_len = prefix_copy_len;
  }

  if (match_count == 1U) {
    const char *completion = matches[0];
    size_t completion_len = strlen(completion);
    if (updated_len + completion_len >= sizeof(updated)) {
      completion_len = sizeof(updated) - 1U - updated_len;
    }
    memcpy(&updated[updated_len], completion, completion_len);
    updated_len += completion_len;

    size_t suffix_len = ctx->input_length - command_end;
    if (suffix_len > 0U) {
      size_t copy_suffix = suffix_len;
      if (updated_len + copy_suffix >= sizeof(updated)) {
        copy_suffix = sizeof(updated) - 1U - updated_len;
      }
      memcpy(&updated[updated_len], &ctx->input_buffer[command_end], copy_suffix);
      updated_len += copy_suffix;
    } else if (updated_len + 1U < sizeof(updated)) {
      updated[updated_len++] = ' ';
    }

    updated[updated_len] = '\0';
    session_set_input_text(ctx, updated);
    ctx->input_history_position = -1;
    ctx->history_scroll_position = 0U;
    return true;
  }

  size_t common_len = strlen(matches[0]);
  for (size_t idx = 1U; idx < match_count && common_len > 0U; ++idx) {
    const char *candidate = matches[idx];
    size_t candidate_len = strlen(candidate);
    if (candidate_len < common_len) {
      common_len = candidate_len;
    }
    size_t compare_len = common_len;
    size_t match_prefix = 0U;
    for (; match_prefix < compare_len; ++match_prefix) {
      unsigned char lhs = (unsigned char)tolower((unsigned char)matches[0][match_prefix]);
      unsigned char rhs = (unsigned char)tolower((unsigned char)candidate[match_prefix]);
      if (lhs != rhs) {
        break;
      }
    }
    common_len = match_prefix;
  }

  if (common_len > prefix_len) {
    size_t completion_len = common_len;
    if (updated_len + completion_len >= sizeof(updated)) {
      completion_len = sizeof(updated) - 1U - updated_len;
    }
    memcpy(&updated[updated_len], matches[0], completion_len);
    updated_len += completion_len;

    size_t suffix_len = ctx->input_length - command_end;
    if (suffix_len > 0U) {
      size_t copy_suffix = suffix_len;
      if (updated_len + copy_suffix >= sizeof(updated)) {
        copy_suffix = sizeof(updated) - 1U - updated_len;
      }
      memcpy(&updated[updated_len], &ctx->input_buffer[command_end], copy_suffix);
      updated_len += copy_suffix;
    }

    updated[updated_len] = '\0';
    session_set_input_text(ctx, updated);
    ctx->input_history_position = -1;
    ctx->history_scroll_position = 0U;
    return true;
  }

  session_send_system_line(ctx, "Possible commands:");
  char line[SSH_CHATTER_MESSAGE_LIMIT];
  size_t offset = 0U;
  for (size_t idx = 0U; idx < match_count; ++idx) {
    char entry[64];
    snprintf(entry, sizeof(entry), "/%s", matches[idx]);
    size_t entry_len = strlen(entry);
    if (offset != 0U) {
      if (offset + 1U >= sizeof(line)) {
        line[offset] = '\0';
        session_send_system_line(ctx, line);
        offset = 0U;
      }
      line[offset++] = ' ';
    }
    if (entry_len >= sizeof(line)) {
      session_send_system_line(ctx, entry);
      offset = 0U;
      continue;
    }
    if (offset + entry_len >= sizeof(line)) {
      line[offset] = '\0';
      session_send_system_line(ctx, line);
      offset = 0U;
    }
    memcpy(&line[offset], entry, entry_len);
    offset += entry_len;
  }
  if (offset > 0U) {
    line[offset] = '\0';
    session_send_system_line(ctx, line);
  }
  session_refresh_input_line(ctx);
  return true;
}

static void session_history_record(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || line == NULL) {
    return;
  }

  bool has_visible = false;
  for (const char *cursor = line; *cursor != '\0'; ++cursor) {
    if (!isspace((unsigned char)*cursor)) {
      has_visible = true;
      break;
    }
  }

  if (!has_visible) {
    ctx->input_history_position = -1;
    return;
  }

  const char *trimmed = line;
  while (*trimmed == ' ' || *trimmed == '\t') {
    ++trimmed;
  }

  bool is_command = false;
  if (*trimmed != '\0') {
    if (*trimmed == '/') {
      is_command = true;
    } else if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
      is_command = true;
    }
  }

  if (ctx->input_history_count > 0U) {
    const size_t last_index = ctx->input_history_count - 1U;
    if (strncmp(ctx->input_history[last_index], line, sizeof(ctx->input_history[last_index])) == 0) {
      ctx->input_history_position = -1;
      return;
    }
  }

  if (ctx->input_history_count < SSH_CHATTER_INPUT_HISTORY_LIMIT) {
    snprintf(ctx->input_history[ctx->input_history_count], sizeof(ctx->input_history[0]), "%s", line);
    ctx->input_history_is_command[ctx->input_history_count] = is_command;
    ++ctx->input_history_count;
  } else {
    memmove(ctx->input_history, ctx->input_history + 1,
            sizeof(ctx->input_history) - sizeof(ctx->input_history[0]));
    memmove(ctx->input_history_is_command, ctx->input_history_is_command + 1,
            (SSH_CHATTER_INPUT_HISTORY_LIMIT - 1U) * sizeof(ctx->input_history_is_command[0]));
    snprintf(ctx->input_history[SSH_CHATTER_INPUT_HISTORY_LIMIT - 1U], sizeof(ctx->input_history[0]), "%s", line);
    ctx->input_history_is_command[SSH_CHATTER_INPUT_HISTORY_LIMIT - 1U] = is_command;
  }

  ctx->input_history_position = -1;
  ctx->history_scroll_position = 0U;
}

static void session_history_navigate(session_ctx_t *ctx, int direction) {
  if (ctx == NULL || direction == 0) {
    return;
  }

  ctx->history_scroll_position = 0U;

  if (ctx->input_history_count == 0U) {
    ctx->input_history_position = (int)ctx->input_history_count;
    session_set_input_text(ctx, "");
    return;
  }

  int position = ctx->input_history_position;
  if (position < 0 || position > (int)ctx->input_history_count) {
    position = (int)ctx->input_history_count;
  }

  position += direction;
  if (position < 0) {
    position = 0;
  }
  if (position > (int)ctx->input_history_count) {
    position = (int)ctx->input_history_count;
  }

  ctx->input_history_position = position;

  if (position == (int)ctx->input_history_count) {
    session_set_input_text(ctx, "");
  } else {
    session_set_input_text(ctx, ctx->input_history[position]);
  }
}

static void session_scrollback_navigate(session_ctx_t *ctx, int direction) {
  if (ctx == NULL || ctx->owner == NULL || !session_transport_active(ctx) || direction == 0) {
    return;
  }

  size_t total = host_history_total(ctx->owner);
  if (total == 0U) {
    session_send_system_line(ctx, "No chat history available yet.");
    return;
  }

  bool suppress_translation = translator_should_skip_scrollback_translation();
  bool previous_translation_suppress = ctx->translation_suppress_output;
  if (suppress_translation) {
    ctx->translation_suppress_output = true;
  }

  const size_t step = SSH_CHATTER_SCROLLBACK_CHUNK > 0 ? SSH_CHATTER_SCROLLBACK_CHUNK : 1U;
  if (ctx->history_scroll_position >= total) {
    ctx->history_scroll_position = total > 0U ? total - 1U : 0U;
  }
  size_t position = ctx->history_scroll_position;
  size_t new_position = position;
  bool reached_oldest = false;

  const size_t max_position = total > 0U ? total - 1U : 0U;

  if (direction > 0) {
    size_t current_newest_visible = 0U;
    if (position < total) {
      current_newest_visible = total - 1U - position;
    }

    size_t current_chunk = step;
    if (current_chunk > current_newest_visible + 1U) {
      current_chunk = current_newest_visible + 1U;
    }
    if (current_chunk == 0U) {
      current_chunk = 1U;
    }

    const size_t current_oldest_visible =
        (current_newest_visible + 1U > current_chunk) ? (current_newest_visible + 1U - current_chunk) : 0U;

    if (current_oldest_visible == 0U) {
      reached_oldest = true;
    } else if (new_position < max_position) {
      size_t advance = step;
      if (advance > max_position - new_position) {
        advance = max_position - new_position;
      }
      if (advance == 0U) {
        reached_oldest = true;
      } else {
        new_position += advance;
      }
    } else {
      reached_oldest = true;
    }
  } else if (direction < 0) {
    if (new_position > 0U) {
      size_t retreat = step;
      if (retreat > new_position) {
        retreat = new_position;
      }
      new_position -= retreat;
    }
  }

  bool at_boundary = (new_position == position);
  ctx->history_scroll_position = new_position;

  const char clear_sequence[] = "\r" ANSI_CLEAR_LINE;
  session_channel_write(ctx, clear_sequence, sizeof(clear_sequence) - 1U);
  session_channel_write(ctx, "\r\n", 2U);

  if (direction < 0 && at_boundary && new_position == 0U) {
    if (position == 0U) {
      session_send_system_line(ctx, "Already at the latest messages.");
    }
    session_render_prompt(ctx, false);
    goto cleanup;
  }

  const size_t newest_visible = total - 1U - new_position;
  size_t chunk = step;
  if (chunk > newest_visible + 1U) {
    chunk = newest_visible + 1U;
  }
  if (chunk == 0U) {
    chunk = 1U;
  }

  const size_t oldest_visible = (newest_visible + 1U > chunk) ? (newest_visible + 1U - chunk) : 0U;

  if (direction > 0 && (reached_oldest || (at_boundary && new_position == max_position))) {
    session_send_system_line(ctx, "Reached the oldest stored message.");
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Scrollback (%zu-%zu of %zu)", oldest_visible + 1U, newest_visible + 1U, total);
  session_send_system_line(ctx, header);

  chat_history_entry_t buffer[SSH_CHATTER_SCROLLBACK_CHUNK];
  size_t request = chunk;
  if (request > SSH_CHATTER_SCROLLBACK_CHUNK) {
    request = SSH_CHATTER_SCROLLBACK_CHUNK;
  }
  size_t copied = host_history_copy_range(ctx->owner, oldest_visible, buffer, request);
  if (copied == 0U) {
    session_send_system_line(ctx, "Unable to read chat history right now.");
    session_render_prompt(ctx, false);
    goto cleanup;
  }

  for (size_t idx = 0; idx < copied; ++idx) {
    session_send_history_entry(ctx, &buffer[idx]);
  }

  if (direction < 0 && new_position == 0U) {
    session_send_system_line(ctx, "End of scrollback.");
  }

  session_render_prompt(ctx, false);

cleanup:
  if (suppress_translation) {
    ctx->translation_suppress_output = previous_translation_suppress;
  }
}

static bool session_consume_escape_sequence(session_ctx_t *ctx, char ch) {
  if (ctx == NULL) {
    return false;
  }

  if (!ctx->input_escape_active) {
    if (ch == 0x1b) {
      ctx->input_escape_active = true;
      ctx->input_escape_length = 0U;
      if (ctx->input_escape_length < sizeof(ctx->input_escape_buffer)) {
        ctx->input_escape_buffer[ctx->input_escape_length++] = ch;
      }
      return true;
    }
    return false;
  }

  if (ctx->input_escape_length < sizeof(ctx->input_escape_buffer)) {
    ctx->input_escape_buffer[ctx->input_escape_length++] = ch;
  }

  const char *sequence = ctx->input_escape_buffer;
  const size_t length = ctx->input_escape_length;

  if (length == 1U) {
    return true;
  }

  if (length == 2U) {
    if (sequence[1] == '[') {
      return true;
    }
    if (sequence[1] == 'k') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, -1);
      } else {
        if (ctx->bbs_view_active && session_bbs_scroll(ctx, 1, 1U)) {
          ctx->input_escape_active = false;
          ctx->input_escape_length = 0U;
          return true;
        }
        session_history_navigate(ctx, -1);
      }
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[1] == 'j') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, 1);
      } else {
        if (ctx->bbs_view_active && session_bbs_scroll(ctx, -1, 1U)) {
          ctx->input_escape_active = false;
          ctx->input_escape_length = 0U;
          return true;
        }
        session_history_navigate(ctx, 1);
      }
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if ((sequence[1] == 'l' || sequence[1] == 'L') && ctx->game.active && ctx->game.type == SESSION_GAME_ALPHA) {
      session_game_alpha_manual_lock(ctx);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
  }

  if (length == 3U && sequence[1] == '[') {
    int dx = 0;
    int dy = 0;
    switch (sequence[2]) {
      case 'A':
        dy = -1;
        break;
      case 'B':
        dy = 1;
        break;
      case 'C':
        dx = 1;
        break;
      case 'D':
        dx = -1;
        break;
      default:
        break;
    }
    if ((dx != 0 || dy != 0) && session_game_alpha_handle_arrow(ctx, dx, dy)) {
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[2] == 'A') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, -1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, 1, 1U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->in_rss_mode && session_rss_move(ctx, -1)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
        session_history_navigate(ctx, -1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, 1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[2] == 'B') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, 1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, -1, 1U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->in_rss_mode && session_rss_move(ctx, 1)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
        session_history_navigate(ctx, 1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, -1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
  }

  if (length == 3U && sequence[1] == 'O') {
    int dx = 0;
    int dy = 0;
    switch (sequence[2]) {
      case 'A':
        dy = -1;
        break;
      case 'B':
        dy = 1;
        break;
      case 'C':
        dx = 1;
        break;
      case 'D':
        dx = -1;
        break;
      default:
        break;
    }
    if ((dx != 0 || dy != 0) && session_game_alpha_handle_arrow(ctx, dx, dy)) {
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[2] == 'A') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, -1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, 1, 1U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->in_rss_mode && session_rss_move(ctx, -1)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
        session_history_navigate(ctx, -1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, 1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[2] == 'B') {
      if (ctx->bbs_post_pending) {
        session_bbs_move_cursor(ctx, 1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, -1, 1U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->in_rss_mode && session_rss_move(ctx, 1)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
        session_history_navigate(ctx, 1);
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, -1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
  }

  if (length == 4U && sequence[1] == '[' && sequence[3] == '~') {
    if (sequence[2] == '5') {
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, 1, 0U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, 1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
    if (sequence[2] == '6') {
      if (ctx->bbs_view_active && session_bbs_scroll(ctx, -1, 0U)) {
        ctx->input_escape_active = false;
        ctx->input_escape_length = 0U;
        return true;
      }
      session_scrollback_navigate(ctx, -1);
      ctx->input_escape_active = false;
      ctx->input_escape_length = 0U;
      return true;
    }
  }

  const bool bracket_sequence = (length >= 2U && sequence[1] == '[');
  if (bracket_sequence) {
    const char final = sequence[length - 1U];
    if (final != '~' && !(length == 3U && isalpha((unsigned char)sequence[2]))) {
      return true;
    }
    if (final == '~') {
      if (length >= 5U && strncmp(&sequence[2], "200", 3) == 0) {
        ctx->bracket_paste_active = true;
      } else if (length >= 5U && strncmp(&sequence[2], "201", 3) == 0) {
        ctx->bracket_paste_active = false;
        session_refresh_input_line(ctx);
      }
    }
  }

  ctx->input_escape_active = false;
  ctx->input_escape_length = 0U;
  if (bracket_sequence) {
    return true;
  }
  return ch == 0x1b;
}

static void session_send_private_message_line(session_ctx_t *ctx, const session_ctx_t *color_source, const char *label,
                                              const char *message) {
  if (ctx == NULL || !session_transport_active(ctx) || color_source == NULL || label == NULL || message == NULL) {
    return;
  }

  const char *highlight = color_source->user_highlight_code != NULL ? color_source->user_highlight_code : "";
  const char *color = color_source->user_color_code != NULL ? color_source->user_color_code : "";
  const char *bold = color_source->user_is_bold ? ANSI_BOLD : "";

  char line[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(line, sizeof(line), "%s%s%s[%s]%s %s", highlight, bold, color, label, ANSI_RESET, message);
  session_send_line(ctx, line);

  if (ctx != color_source && ctx->history_scroll_position == 0U) {
    session_refresh_input_line(ctx);
  }
}

static void session_send_history_entry(session_ctx_t *ctx, const chat_history_entry_t *entry) {
  if (ctx == NULL || !session_transport_active(ctx) || entry == NULL) {
    return;
  }

  if (session_should_hide_entry(ctx, entry)) {
    return;
  }

  if (entry->is_user_message) {
    bool previous_override = session_translation_push_scope_override(ctx);
    const char *highlight = entry->user_highlight_code != NULL ? entry->user_highlight_code : "";
    const char *color = entry->user_color_code != NULL ? entry->user_color_code : "";
    const char *bold = entry->user_is_bold ? ANSI_BOLD : "";

    const char *message_text = entry->message;
    char fallback[SSH_CHATTER_MESSAGE_LIMIT + 64];
    if ((message_text == NULL || message_text[0] == '\0') && entry->attachment_type != CHAT_ATTACHMENT_NONE) {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      snprintf(fallback, sizeof(fallback), "shared a %s", label);
      message_text = fallback;
    } else if (message_text == NULL) {
      message_text = "";
    }

    bool multiline_message = strchr(message_text, '\n') != NULL;
    const char *header_body = message_text;
    if (multiline_message) {
      header_body = "shared ASCII art:";
    }

    char header[SSH_CHATTER_MESSAGE_LIMIT + 128];
    if (entry->message_id > 0U) {
      snprintf(header, sizeof(header), "[#%" PRIu64 "] %s%s%s[%s]%s %s", entry->message_id, highlight, bold, color,
               entry->username, ANSI_RESET, header_body);
    } else {
      snprintf(header, sizeof(header), "%s%s%s[%s]%s %s", highlight, bold, color, entry->username, ANSI_RESET,
               header_body);
    }
    session_send_plain_line(ctx, header);

    if (multiline_message) {
      const char *line_start = message_text;
      while (line_start != NULL) {
        const char *newline = strchr(line_start, '\n');
        size_t segment_length = newline != NULL ? (size_t)(newline - line_start) : strlen(line_start);
        char line[SSH_CHATTER_MESSAGE_LIMIT + 1U];
        if (segment_length >= sizeof(line)) {
          segment_length = sizeof(line) - 1U;
        }
        if (segment_length > 0U) {
          memcpy(line, line_start, segment_length);
        }
        line[segment_length] = '\0';
        session_send_plain_line(ctx, line);
        if (newline == NULL) {
          break;
        }
        line_start = newline + 1;
      }
    }

    char attachment_line[SSH_CHATTER_ATTACHMENT_TARGET_LEN + 64];
    if (entry->attachment_type != CHAT_ATTACHMENT_NONE && entry->attachment_target[0] != '\0') {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      snprintf(attachment_line, sizeof(attachment_line), "    ↳ %s: %s", label, entry->attachment_target);
      session_send_plain_line(ctx, attachment_line);
    }

    char caption_line[SSH_CHATTER_ATTACHMENT_CAPTION_LEN + 32];
    if (entry->attachment_caption[0] != '\0') {
      snprintf(caption_line, sizeof(caption_line), "    ↳ note: %s", entry->attachment_caption);
      session_send_plain_line(ctx, caption_line);
    }

    char reactions_line[SSH_CHATTER_MESSAGE_LIMIT];
    if (chat_history_entry_build_reaction_summary(entry, reactions_line, sizeof(reactions_line))) {
      char summary_line[SSH_CHATTER_MESSAGE_LIMIT + 32];
      snprintf(summary_line, sizeof(summary_line), "    ↳ reactions: %s", reactions_line);
      session_send_plain_line(ctx, summary_line);
    }

    if (entry->attachment_type == CHAT_ATTACHMENT_IMAGE && entry->message_id > 0U) {
      char hint[SSH_CHATTER_MESSAGE_LIMIT];
      session_send_plain_line(ctx, hint);
    }

    if (entry->message_id > 0U) {
      session_send_reply_tree(ctx, entry->message_id, 0U, 1U);
    }

    session_translation_pop_scope_override(ctx, previous_override);
  } else {
    session_send_system_line(ctx, entry->message);
  }
}

// Present a summary of a poll, optionally showing the label used for named polls.
static void session_send_poll_summary_generic(session_ctx_t *ctx, const poll_state_t *poll, const char *label) {
  if (ctx == NULL || poll == NULL) {
    return;
  }

  if (!poll->active || poll->option_count == 0U) {
    if (label == NULL) {
      session_send_system_line(ctx, "No active poll right now.");
    } else {
      char message[128];
      snprintf(message, sizeof(message), "Poll '%s' is not active.", label);
      session_send_system_line(ctx, message);
    }
    return;
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT + 64];
  const char *mode_suffix = poll->allow_multiple ? " (multiple choice)" : "";
  if (label == NULL) {
    snprintf(header, sizeof(header), "Poll #%" PRIu64 ": %s%s", poll->id, poll->question, mode_suffix);
  } else {
    snprintf(header, sizeof(header), "Poll [%s] #%" PRIu64 ": %s%s", label, poll->id, poll->question, mode_suffix);
  }
  session_send_system_line(ctx, header);

  for (size_t idx = 0U; idx < poll->option_count; ++idx) {
    char option_line[SSH_CHATTER_MESSAGE_LIMIT + 64];
    uint32_t votes = poll->options[idx].votes;
    if (label == NULL) {
      snprintf(option_line, sizeof(option_line), "  /%zu - %s (%u vote%s)", idx + 1U, poll->options[idx].text, votes,
               votes == 1U ? "" : "s");
    } else {
      snprintf(option_line, sizeof(option_line), "  /%zu %s - %s (%u vote%s)", idx + 1U, label, poll->options[idx].text, votes,
               votes == 1U ? "" : "s");
    }
    session_send_system_line(ctx, option_line);
  }

  if (label == NULL) {
    if (poll->allow_multiple) {
      session_send_system_line(ctx, "Vote with /1 through /5 (multiple selections allowed).");
    } else {
      session_send_system_line(ctx, "Vote with /1 through /5.");
    }
  } else {
    char footer[192];
    if (poll->allow_multiple) {
      snprintf(footer, sizeof(footer), "Vote with /1 %s through /%zu %s (multiple selections allowed).", label,
               poll->option_count, label);
    } else {
      snprintf(footer, sizeof(footer), "Vote with /1 %s through /%zu %s.", label, poll->option_count, label);
    }
    session_send_system_line(ctx, footer);
  }
}

// Gather the main poll and any named polls and present summaries to the caller.
static void session_send_poll_summary(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  poll_state_t main_snapshot = {0};
  named_poll_state_t named_snapshot[SSH_CHATTER_MAX_NAMED_POLLS];
  size_t named_count = 0U;

  pthread_mutex_lock(&host->lock);
  main_snapshot = host->poll;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    if (host->named_polls[idx].label[0] == '\0') {
      continue;
    }
    named_snapshot[named_count++] = host->named_polls[idx];
    if (named_count >= SSH_CHATTER_MAX_NAMED_POLLS) {
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  session_send_poll_summary_generic(ctx, &main_snapshot, NULL);

  size_t active_named = 0U;
  for (size_t idx = 0U; idx < named_count; ++idx) {
    if (named_snapshot[idx].poll.active && named_snapshot[idx].poll.option_count > 0U) {
      if (active_named == 0U) {
        session_send_system_line(ctx, "Active named polls:");
      }
      session_send_poll_summary_generic(ctx, &named_snapshot[idx].poll, named_snapshot[idx].label);
      ++active_named;
    }
  }

  if (active_named == 0U) {
    session_send_system_line(ctx,
                             "No active named polls. Use /vote <label> <question>|<option1>|<option2> or /vote-single for a "
                             "single-choice poll.");
  }
}

// Provide a lightweight overview of every named poll regardless of status.
static void session_list_named_polls(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  named_poll_state_t snapshot[SSH_CHATTER_MAX_NAMED_POLLS];
  size_t count = 0U;

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    if (host->named_polls[idx].label[0] == '\0') {
      continue;
    }
    snapshot[count++] = host->named_polls[idx];
    if (count >= SSH_CHATTER_MAX_NAMED_POLLS) {
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (count == 0U) {
    session_send_system_line(ctx,
                             "No named polls exist. Start one with /vote <label> <question>|<option1>|<option2> or /vote-single "
                             "for single-choice voting.");
    return;
  }

  session_send_system_line(ctx, "Named polls overview:");
  for (size_t idx = 0U; idx < count; ++idx) {
    const named_poll_state_t *entry = &snapshot[idx];
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    const char *status = entry->poll.active ? "active" : "inactive";
    const char *mode = entry->poll.allow_multiple ? "multiple choice" : "single choice";
    snprintf(line, sizeof(line), "- [%s] %s (options: %zu, %s, %s)", entry->label, entry->poll.question,
             entry->poll.option_count, status, mode);
    session_send_system_line(ctx, line);
  }
}

static bool chat_history_entry_build_reaction_summary(const chat_history_entry_t *entry, char *buffer, size_t length) {
  if (entry == NULL || buffer == NULL || length == 0U) {
    return false;
  }

  buffer[0] = '\0';
  bool any = false;
  size_t offset = 0U;

  for (size_t idx = 0U; idx < SSH_CHATTER_REACTION_KIND_COUNT; ++idx) {
    uint32_t count = entry->reaction_counts[idx];
    if (count == 0U) {
      continue;
    }

    const reaction_descriptor_t *descriptor = &REACTION_DEFINITIONS[idx];
    char chunk[64];
    snprintf(chunk, sizeof(chunk), "%s x%u", descriptor->icon, count);

    size_t chunk_len = strlen(chunk);
    if (chunk_len + 1U >= length - offset) {
      break;
    }

    if (any) {
      buffer[offset++] = ' ';
    }
    memcpy(buffer + offset, chunk, chunk_len);
    offset += chunk_len;
    buffer[offset] = '\0';
    any = true;
  }

  return any;
}

static const char *chat_attachment_type_label(chat_attachment_type_t type) {
  switch (type) {
  case CHAT_ATTACHMENT_IMAGE:
    return "image";
  case CHAT_ATTACHMENT_VIDEO:
    return "video";
  case CHAT_ATTACHMENT_AUDIO:
    return "audio";
  case CHAT_ATTACHMENT_FILE:
    return "file";
  case CHAT_ATTACHMENT_NONE:
  default:
    return "attachment";
  }
}

static void session_send_history(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL || !session_transport_active(ctx)) {
    return;
  }

  size_t total = host_history_total(ctx->owner);
  if (total == 0U) {
    return;
  }

  size_t window = SSH_CHATTER_SCROLLBACK_CHUNK;
  if (window == 0U) {
    window = 1U;
  }
  if (window > total) {
    window = total;
  }

  chat_history_entry_t snapshot[SSH_CHATTER_SCROLLBACK_CHUNK];
  size_t start_index = total - window;
  size_t copied = host_history_copy_range(ctx->owner, start_index, snapshot, window);
  if (copied == 0U) {
    return;
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  if (total > copied) {
    snprintf(header, sizeof(header), "Recent activity (last %zu of %zu messages):", copied, total);
  } else {
    snprintf(header, sizeof(header), "Recent activity (last %zu message%s):", copied, copied == 1U ? "" : "s");
  }
  session_render_separator(ctx, "Recent activity");
  session_send_system_line(ctx, header);

  for (size_t idx = 0; idx < copied; ++idx) {
    session_send_history_entry(ctx, &snapshot[idx]);
  }

  session_send_system_line(ctx, "Use the Up/Down arrow keys to browse stored chat history.");
  session_render_separator(ctx, "Chatroom");
  ctx->history_scroll_position = 0U;
}

static bool session_handle_service_request(ssh_message message) {
  if (message == NULL) {
    return false;
  }

  const char *service = ssh_message_service_service(message);
  if (service == NULL) {
    return false;
  }

  if (strcmp(service, "ssh-userauth") == 0 || strcmp(service, "ssh-connection") == 0) {
    ssh_message_service_reply_success(message);
    return true;
  }

  return false;
}

static int session_authenticate(session_ctx_t *ctx) {
  ssh_message message = NULL;
  bool authenticated = false;
  if (ctx != NULL) {
    ctx->lan_operator_credentials_valid = false;
  }

  while (!authenticated && (message = ssh_message_get(ctx->session)) != NULL) {
    const int message_type = ssh_message_type(message);
    switch (message_type) {
      case SSH_REQUEST_SERVICE:
        if (!session_handle_service_request(message)) {
          ssh_message_reply_default(message);
        }
        break;
      case SSH_REQUEST_AUTH:
        {
          const char *username = ssh_message_auth_user(message);
          if (username != NULL && username[0] != '\0') {
            snprintf(ctx->user.name, sizeof(ctx->user.name), "%.*s", SSH_CHATTER_USERNAME_LEN - 1, username);
          }

          bool reserved_name = false;
          lan_operator_credential_t *credential = NULL;
          if (ctx->owner != NULL) {
            credential = host_find_lan_operator_credential(ctx->owner, ctx->user.name);
            reserved_name = credential != NULL;
          }

          if (!reserved_name) {
            ssh_message_auth_reply_success(message, 0);
            authenticated = true;
            break;
          }

          if (!session_is_lan_client(ctx->client_ip)) {
            ssh_message_auth_set_methods(message, SSH_AUTH_METHOD_PASSWORD);
            ssh_message_reply_default(message);
            break;
          }

          const int auth_method = ssh_message_subtype(message);
          if (auth_method != SSH_AUTH_METHOD_PASSWORD) {
            ssh_message_auth_set_methods(message, SSH_AUTH_METHOD_PASSWORD);
            ssh_message_reply_default(message);
            break;
          }

          const char *password = ssh_message_auth_password(message);
          if (credential == NULL || password == NULL || credential->password[0] == '\0' || strcmp(credential->password, password) != 0) {
            ssh_message_auth_set_methods(message, SSH_AUTH_METHOD_PASSWORD);
            ssh_message_reply_default(message);
            break;
          }

          ctx->lan_operator_credentials_valid = true;
          snprintf(ctx->user.name, sizeof(ctx->user.name), "%s", credential->nickname);
          ssh_message_auth_reply_success(message, 0);
          authenticated = true;
        }
        break;
      default:
        ssh_message_reply_default(message);
        break;
    }
    ssh_message_free(message);
  }

  return authenticated ? 0 : -1;
}

static int session_accept_channel(session_ctx_t *ctx) {
  ssh_message message = NULL;

  while ((message = ssh_message_get(ctx->session)) != NULL) {
    const int message_type = ssh_message_type(message);
    if (message_type == SSH_REQUEST_SERVICE) {
      if (!session_handle_service_request(message)) {
        ssh_message_reply_default(message);
      }
      ssh_message_free(message);
      continue;
    }

    if (message_type == SSH_REQUEST_CHANNEL_OPEN && ssh_message_subtype(message) == SSH_CHANNEL_SESSION) {
      ssh_channel channel = ssh_message_channel_request_open_reply_accept(message);
      if (channel == NULL) {
        accept_channel_fn_t accept_channel = resolve_accept_channel_fn();
        if (accept_channel != NULL) {
          channel = ssh_channel_new(ctx->session);
          if (channel != NULL) {
            if (accept_channel(message, channel) != SSH_OK) {
              ssh_channel_free(channel);
              channel = NULL;
            }
          }
        }
      }

      if (channel != NULL) {
        ctx->channel = channel;
        ssh_message_free(message);
        break;
      }

      ssh_message_reply_default(message);
      ssh_message_free(message);
      continue;
    }

    ssh_message_reply_default(message);
    ssh_message_free(message);
  }

  return session_transport_active(ctx) ? 0 : -1;
}

static int session_prepare_shell(session_ctx_t *ctx) {
  ssh_message message = NULL;
  bool shell_ready = false;

  while (!shell_ready && (message = ssh_message_get(ctx->session)) != NULL) {
    if (ssh_message_type(message) == SSH_REQUEST_CHANNEL) {
      const int subtype = ssh_message_subtype(message);
      if (subtype == SSH_CHANNEL_REQUEST_PTY || subtype == SSH_CHANNEL_REQUEST_SHELL) {
        ssh_message_channel_request_reply_success(message);
        if (subtype == SSH_CHANNEL_REQUEST_SHELL) {
          shell_ready = true;
        }
      } else {
        ssh_message_reply_default(message);
      }
    } else {
      ssh_message_reply_default(message);
    }
    ssh_message_free(message);
  }

  return shell_ready ? 0 : -1;
}

static const char *session_captcha_question_for_language(const captcha_prompt_t *prompt, captcha_language_t language) {
  if (prompt == NULL) {
    return NULL;
  }

  switch (language) {
    case CAPTCHA_LANGUAGE_EN:
      return prompt->question_en;
    case CAPTCHA_LANGUAGE_ZH:
      return prompt->question_zh;
    case CAPTCHA_LANGUAGE_RU:
      return prompt->question_ru;
    case CAPTCHA_LANGUAGE_KO:
    default:
      return prompt->question_ko;
  }
}

static const char *session_captcha_label_for_language(captcha_language_t language) {
  switch (language) {
    case CAPTCHA_LANGUAGE_EN:
      return "Captcha: ";
    case CAPTCHA_LANGUAGE_ZH:
      return "驗證碼: ";
    case CAPTCHA_LANGUAGE_RU:
      return "Капча: ";
    case CAPTCHA_LANGUAGE_KO:
    default:
      return "캡챠: ";
  }
}

static captcha_language_t session_captcha_language_from_ui(session_ui_language_t language) {
  switch (language) {
    case SESSION_UI_LANGUAGE_EN:
      return CAPTCHA_LANGUAGE_EN;
    case SESSION_UI_LANGUAGE_ZH:
      return CAPTCHA_LANGUAGE_ZH;
    case SESSION_UI_LANGUAGE_RU:
      return CAPTCHA_LANGUAGE_RU;
    case SESSION_UI_LANGUAGE_JP:
      return CAPTCHA_LANGUAGE_EN;
    case SESSION_UI_LANGUAGE_KO:
    default:
      return CAPTCHA_LANGUAGE_KO;
  }
}

static captcha_language_t session_captcha_primary_language(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return CAPTCHA_LANGUAGE_KO;
  }

  session_ui_language_t preferred = session_ui_language_current(ctx);
  captcha_language_t preferred_language = session_captcha_language_from_ui(preferred);
  if (preferred != SESSION_UI_LANGUAGE_KO || preferred_language != CAPTCHA_LANGUAGE_KO) {
    return preferred_language;
  }

  session_ui_language_t geo_language = session_client_geo_language(ctx);
  if (geo_language != SESSION_UI_LANGUAGE_COUNT) {
      return session_captcha_language_from_ui(geo_language);
  }

  char label[64];
  if (session_detect_provider_ip(ctx->client_ip, label, sizeof(label))) {
    if (string_contains_case_insensitive(label, "Chinese")) {
      return CAPTCHA_LANGUAGE_ZH;
    }
    if (string_contains_case_insensitive(label, "Russian")) {
      return CAPTCHA_LANGUAGE_RU;
    }
    if (string_contains_case_insensitive(label, "Korean")) {
      return CAPTCHA_LANGUAGE_KO;
    }
  }

  return CAPTCHA_LANGUAGE_EN;
}

static bool session_captcha_add_language(captcha_language_t *order, size_t capacity, size_t *count, bool used[],
                                         captcha_language_t language) {
  if (order == NULL || count == NULL || used == NULL) {
    return false;
  }

  size_t index = (size_t)language;
  if (index >= CAPTCHA_LANGUAGE_COUNT) {
    return false;
  }

  if (used[index] || *count >= capacity) {
    return false;
  }

  order[*count] = language;
  used[index] = true;
  ++(*count);
  return true;
}

static size_t session_collect_captcha_languages(const session_ctx_t *ctx, captcha_language_t *order, size_t capacity) {
  if (order == NULL || capacity == 0U) {
    return 0U;
  }

  bool used[CAPTCHA_LANGUAGE_COUNT] = {false};
  size_t count = 0U;

  captcha_language_t primary = session_captcha_primary_language(ctx);
  session_captcha_add_language(order, capacity, &count, used, primary);

  if (ctx != NULL) {
    captcha_language_t user_pref = session_captcha_language_from_ui(session_ui_language_current(ctx));
    session_captcha_add_language(order, capacity, &count, used, user_pref);

    char label[64];
    if (session_detect_provider_ip(ctx->client_ip, label, sizeof(label))) {
      if (string_contains_case_insensitive(label, "Chinese")) {
        session_captcha_add_language(order, capacity, &count, used, CAPTCHA_LANGUAGE_ZH);
      }
      if (string_contains_case_insensitive(label, "Russian")) {
        session_captcha_add_language(order, capacity, &count, used, CAPTCHA_LANGUAGE_RU);
      }
      if (string_contains_case_insensitive(label, "Korean")) {
        session_captcha_add_language(order, capacity, &count, used, CAPTCHA_LANGUAGE_KO);
      }
    }
  }

  session_captcha_add_language(order, capacity, &count, used, CAPTCHA_LANGUAGE_EN);
  session_captcha_add_language(order, capacity, &count, used, CAPTCHA_LANGUAGE_KO);

  static const captcha_language_t kFallbackOrder[] = {
      CAPTCHA_LANGUAGE_ZH,
      CAPTCHA_LANGUAGE_RU,
      CAPTCHA_LANGUAGE_EN,
      CAPTCHA_LANGUAGE_KO,
  };

  for (size_t idx = 0U; idx < sizeof(kFallbackOrder) / sizeof(kFallbackOrder[0]); ++idx) {
    session_captcha_add_language(order, capacity, &count, used, kFallbackOrder[idx]);
  }

  return count;
}

static void session_send_captcha_prompt(session_ctx_t *ctx, const captcha_prompt_t *prompt,
                                        const captcha_language_t *order, size_t count) {
  if (ctx == NULL || prompt == NULL || order == NULL || count == 0U) {
    return;
  }

  for (size_t idx = 0U; idx < count; ++idx) {
    captcha_language_t language = order[idx];
    const char *label = session_captcha_label_for_language(language);
    const char *question = session_captcha_question_for_language(prompt, language);
    if (label == NULL || question == NULL || question[0] == '\0') {
      continue;
    }

    char line[sizeof(prompt->question_en) + 32];
    int written = snprintf(line, sizeof(line), "%s%s", label, question);
    if (written <= 0) {
      continue;
    }

    session_send_system_line(ctx, line);
  }
}

static void host_update_last_captcha_prompt(host_t *host, const captcha_prompt_t *prompt,
                                            const captcha_language_t *order, size_t count) {
  if (host == NULL || prompt == NULL) {
    return;
  }

  static const captcha_language_t kDefaultOrder[] = {
      CAPTCHA_LANGUAGE_KO,
      CAPTCHA_LANGUAGE_EN,
      CAPTCHA_LANGUAGE_ZH,
      CAPTCHA_LANGUAGE_RU,
  };

  const captcha_language_t *languages = order;
  size_t language_count = count;
  if (languages == NULL || language_count == 0U) {
    languages = kDefaultOrder;
    language_count = sizeof(kDefaultOrder) / sizeof(kDefaultOrder[0]);
  }

  char combined_question[sizeof(prompt->question_en) + sizeof(prompt->question_ko) + sizeof(prompt->question_ru) +
                         sizeof(prompt->question_zh) + 64];
  combined_question[0] = '\0';
  size_t combined_length = 0U;

  for (size_t idx = 0U; idx < language_count; ++idx) {
    const char *label = session_captcha_label_for_language(languages[idx]);
    const char *question = session_captcha_question_for_language(prompt, languages[idx]);
    if (label == NULL || question == NULL || question[0] == '\0') {
      continue;
    }

    char line[sizeof(prompt->question_en) + 32];
    int written = snprintf(line, sizeof(line), "%s%s", label, question);
    if (written <= 0) {
      continue;
    }

    size_t line_length = (size_t)written;
    if (combined_length > 0U && combined_length + 1U < sizeof(combined_question)) {
      combined_question[combined_length++] = '\n';
    }

    if (combined_length >= sizeof(combined_question)) {
      break;
    }

    size_t available = sizeof(combined_question) - combined_length;
    if (available == 0U) {
      break;
    }

    if (line_length >= available) {
      line_length = available - 1U;
    }

    memcpy(combined_question + combined_length, line, line_length);
    combined_length += line_length;
    combined_question[combined_length] = '\0';
  }

  pthread_mutex_lock(&host->lock);
  snprintf(host->last_captcha_question, sizeof(host->last_captcha_question), "%s", combined_question);
  snprintf(host->last_captcha_answer, sizeof(host->last_captcha_answer), "%s", prompt->answer);
  host->has_last_captcha = host->last_captcha_question[0] != '\0' && host->last_captcha_answer[0] != '\0';
  if (host->has_last_captcha) {
    if (clock_gettime(CLOCK_REALTIME, &host->last_captcha_generated) != 0) {
      host->last_captcha_generated.tv_sec = time(NULL);
      host->last_captcha_generated.tv_nsec = 0L;
    }
  } else {
    host->last_captcha_generated.tv_sec = 0;
    host->last_captcha_generated.tv_nsec = 0L;
  }
  pthread_mutex_unlock(&host->lock);
}

static bool session_run_captcha(session_ctx_t *ctx) {
  if (ctx == NULL || !session_transport_active(ctx)) {
    return false;
  }

  captcha_prompt_t prompt;
  session_build_captcha_prompt(ctx, &prompt);
  captcha_language_t languages[CAPTCHA_LANGUAGE_COUNT];
  size_t language_count = session_collect_captcha_languages(ctx, languages,
                                                            sizeof(languages) / sizeof(languages[0]));
  if (language_count == 0U) {
    languages[0] = CAPTCHA_LANGUAGE_KO;
    language_count = 1U;
  }

  host_update_last_captcha_prompt(ctx->owner, &prompt, languages, language_count);

  bool include_chinese = false;
  for (size_t idx = 0U; idx < language_count; ++idx) {
    if (languages[idx] == CAPTCHA_LANGUAGE_ZH) {
      include_chinese = true;
      break;
    }
  }

  session_send_system_line(ctx, "For Windows users: CHANGE TERMINAL ENCODING TO UTF-8");
  if (include_chinese) {
    session_send_system_line(ctx,
                             "INFO: Chinese question is in Traditional one to cover regions those are NOT Mainland China.");
  }
  session_send_system_line(ctx, "Before entering the room, solve this small puzzle.");
  session_send_captcha_prompt(ctx, &prompt, languages, language_count);
  session_send_system_line(ctx, "Type your answer and press Enter:");

  char answer[sizeof(prompt.answer)];
  size_t length = 0U;
  while (length + 1U < sizeof(answer)) {
    char ch = '\0';
    const int read_result = session_transport_read(ctx, &ch, 1, -1);
    if (read_result <= 0) {
      return false;
    }

    if (ch == '\r' || ch == '\n') {
      session_local_echo_char(ctx, '\n');
      break;
    }

    if (ch == '\b' || (unsigned char)ch == 0x7fU) {
      if (length > 0U) {
        --length;
        session_send_raw_text(ctx, "\b \b");
      }
      continue;
    }

    if ((unsigned char)ch < 0x20U) {
      continue;
    }

    answer[length++] = ch;
    session_local_echo_char(ctx, ch);
  }
  answer[length] = '\0';
  trim_whitespace_inplace(answer);

  if (answer[0] == '\0') {
    session_send_system_line(ctx, "Captcha answer missing. Disconnecting.");
    return false;
  }

  if (strcasecmp(prompt.answer, "dog") == 0 && strcmp(answer, "개") == 0) {
    snprintf(answer, sizeof(answer), "%s", "dog");
  }

  if (strcasecmp(answer, prompt.answer) == 0) {
    session_send_system_line(ctx, "Captcha solved. Welcome aboard!");
    return true;
  }

  session_send_system_line(ctx, "Captcha failed. Disconnecting.");
  return false;
}

static bool session_is_captcha_exempt(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->user.name[0] == '\0') {
    return false;
  }

  char lowered[sizeof(ctx->user.name)];
  size_t idx = 0U;
  for (; idx + 1U < sizeof(lowered) && ctx->user.name[idx] != '\0'; ++idx) {
    lowered[idx] = (char)tolower((unsigned char)ctx->user.name[idx]);
  }
  if (idx < sizeof(lowered)) {
    lowered[idx] = '\0';
  } else {
    lowered[sizeof(lowered) - 1U] = '\0';
  }

  return strcmp(lowered, "gpt") == 0;
}

static void session_print_help(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);

  if (locale->help_title != NULL && locale->help_title[0] != '\0') {
    session_send_system_line(ctx, locale->help_title);
  }

  session_help_send_entries(ctx, kSessionHelpEssential,
                            sizeof(kSessionHelpEssential) / sizeof(kSessionHelpEssential[0]));

  session_send_system_line(ctx, "");

  if (locale->help_hint_extra != NULL && locale->help_hint_extra[0] != '\0') {
    const char *args[] = {prefix};
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(locale->help_hint_extra, args, sizeof(args) / sizeof(args[0]), line, sizeof(line));
    session_send_system_line(ctx, line);
  }

  if (locale->help_scroll_hint != NULL && locale->help_scroll_hint[0] != '\0') {
    session_send_system_line(ctx, locale->help_scroll_hint);
  }

  if (locale->help_regular_hint != NULL && locale->help_regular_hint[0] != '\0') {
    session_send_system_line(ctx, locale->help_regular_hint);
  }
}

static void session_print_help_extra(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);

  if (locale->help_extra_title != NULL && locale->help_extra_title[0] != '\0') {
    session_send_system_line(ctx, locale->help_extra_title);
  }

  session_help_send_entries(ctx, kSessionHelpExtended,
                            sizeof(kSessionHelpExtended) / sizeof(kSessionHelpExtended[0]));

  session_send_system_line(ctx, "");

  if (locale->help_extra_hint != NULL && locale->help_extra_hint[0] != '\0') {
    const char *args[] = {prefix};
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(locale->help_extra_hint, args, sizeof(args) / sizeof(args[0]), line, sizeof(line));
    session_send_system_line(ctx, line);
  }

  if (ctx->user.is_operator || ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "");
    if (locale->help_operator_title != NULL && locale->help_operator_title[0] != '\0') {
      session_send_system_line(ctx, locale->help_operator_title);
    }
    session_help_send_entries(ctx, kSessionHelpOperator,
                              sizeof(kSessionHelpOperator) / sizeof(kSessionHelpOperator[0]));
  }
}

static bool session_line_is_exit_command(const char *line) {
  if (line == NULL) {
    return false;
  }

  if (strncmp(line, "/exit", 5) != 0) {
    return false;
  }

  const char trailing = line[5];
  if (trailing == '\0') {
    return true;
  }

  if (!isspace((unsigned char)trailing)) {
    return false;
  }

  for (size_t idx = 6U; line[idx] != '\0'; ++idx) {
    if (!isspace((unsigned char)line[idx])) {
      return false;
    }
  }

  return true;
}

static void session_handle_username_conflict_input(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL) {
    return;
  }

  if (session_line_is_exit_command(line)) {
    ctx->ops->handle_exit(ctx);
    return;
  }

  char reminder[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(reminder, sizeof(reminder), "The username '%s' is already in use.", ctx->user.name);
  session_send_system_line(ctx, reminder);
  session_send_system_line(ctx,
                           "Reconnect with a different username by running: ssh newname@<server> (or ssh -l newname <server>)");
  session_send_system_line(ctx, "Type /exit to quit.");
}

static void session_process_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || line == NULL) {
    return;
  }

  char normalized[SSH_CHATTER_MAX_INPUT_LEN];
  snprintf(normalized, sizeof(normalized), "%s", line);
  session_normalize_newlines(normalized);

  if (ctx->bbs_post_pending) {
    session_bbs_capture_body_text(ctx, normalized);
    return;
  }

  if (ctx->asciiart_pending) {
    session_asciiart_capture_text(ctx, normalized);
    return;
  }

  if (normalized[0] == '\0') {
    return;
  }

  if (ctx->game.active) {
    if (strcmp(normalized, "/suspend!") == 0) {
      session_game_suspend(ctx, "Game suspended.");
      return;
    }

    if (normalized[0] == '/') {
      session_send_system_line(ctx, "Finish the current game with /suspend! first.");
      return;
    }

    if (ctx->game.type == SESSION_GAME_TETRIS) {
      session_game_tetris_handle_line(ctx, normalized);
    } else if (ctx->game.type == SESSION_GAME_LIARGAME) {
      session_game_liar_handle_line(ctx, normalized);
    } else if (ctx->game.type == SESSION_GAME_ALPHA) {
      session_game_alpha_handle_line(ctx, normalized);
    }
    return;
  }

  if (ctx->in_rss_mode) {
    if (strcmp(normalized, "/exit") == 0) {
      session_rss_exit(ctx, NULL);
    } else {
      const char *rss_args = NULL;
      if (session_parse_command(normalized, "/rss", &rss_args)) {
        session_rss_exit(ctx, NULL);
        session_handle_rss(ctx, rss_args);
      } else {
        session_send_system_line(ctx, "RSS reader active. Use /rss exit Ctrl+Z, or Terminate to return to chat.");
      }
    }
    return;
  }

  bool translation_bypass = false;
  char bypass_buffer[SSH_CHATTER_MAX_INPUT_LEN];
  if (translation_strip_no_translate_prefix(normalized, bypass_buffer, sizeof(bypass_buffer))) {
    translation_bypass = true;
    snprintf(normalized, sizeof(normalized), "%s", bypass_buffer);
  }

  if (normalized[0] == '\0') {
    return;
  }

  printf("[%s] %s\n", ctx->user.name, normalized);

  const struct timespec tiny_delay = {.tv_sec = 0, .tv_nsec = 5000000L};
  nanosleep(&tiny_delay, NULL);

  if (ctx->username_conflict) {
    session_handle_username_conflict_input(ctx, normalized);
    return;
  }

  if (!translation_bypass && normalized[0] == '/') {
    if (session_try_localized_command_forward(ctx, normalized)) {
      return;
    }
    ctx->ops->dispatch_command(ctx, normalized);
    return;
  }

  const char *trimmed = normalized;
  while (*trimmed == ' ' || *trimmed == '\t') {
    ++trimmed;
  }

  if (!translation_bypass && ctx->input_mode == SESSION_INPUT_MODE_COMMAND && *trimmed != '\0') {
    const char *command_text = trimmed;
    char command_buffer[SSH_CHATTER_MAX_INPUT_LEN];
    if (command_text[0] != '/') {
      command_buffer[0] = '/';
      size_t command_len = strnlen(command_text, sizeof(command_buffer) - 2U);
      memcpy(&command_buffer[1], command_text, command_len);
      command_buffer[command_len + 1U] = '\0';
      command_text = command_buffer;
    }
    ctx->ops->dispatch_command(ctx, command_text);
    return;
  }

  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now) != 0) {
    now.tv_sec = time(NULL);
    now.tv_nsec = 0L;
  }

  const bool asciiart_active = ctx->asciiart_pending;
  bool ascii_profile_command = asciiart_active;
  if (!ascii_profile_command && normalized[0] == '/') {
    const char *command_args = NULL;
    if (session_parse_command(normalized, "/asciiart", &command_args) ||
        session_parse_command(normalized, "/profilepic", &command_args)) {
      ascii_profile_command = true;
    }
  }

  const bool translation_throttle =
      ctx->translation_enabled && ctx->input_translation_enabled && ctx->input_translation_language[0] != '\0';
  const bool chat_throttle = ctx->input_mode == SESSION_INPUT_MODE_CHAT;
  if ((translation_throttle || chat_throttle) && ctx->has_last_message_time) {
    time_t sec_delta = now.tv_sec - ctx->last_message_time.tv_sec;
    long nsec_delta = now.tv_nsec - ctx->last_message_time.tv_nsec;
    if (nsec_delta < 0L) {
      --sec_delta;
      nsec_delta += 1000000000L;
    }
    if (translation_throttle && (sec_delta < 0 || (sec_delta == 0 && nsec_delta < 1000000000L))) {
      session_send_system_line(ctx, "Please wait at least one second before sending another message.");
      return;
    }
    if (!translation_throttle && chat_throttle && !ascii_profile_command && !ctx->bracket_paste_active &&
        (sec_delta < 0 || (sec_delta == 0 && nsec_delta < 300000000L))) {
      session_send_system_line(ctx, "Please wait at least 300 milliseconds before sending another chat message.");
      return;
    }
  }

  ctx->last_message_time = now;
  ctx->has_last_message_time = true;

  if (!translation_bypass && ctx->translation_enabled && ctx->input_translation_enabled &&
      ctx->input_translation_language[0] != '\0') {
    if (session_translation_queue_input(ctx, normalized)) {
      return;
    }
    session_send_system_line(ctx, "Translation unavailable; sending your original message.");
  }

  session_deliver_outgoing_message(ctx, normalized, true);
}

static void session_handle_kick(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator) {
    session_send_system_line(ctx, "You are not allowed to kick users.");
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /kick <username>");
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%s", arguments);
  trim_whitespace_inplace(target_name);

  if (target_name[0] == '\0') {
    session_send_system_line(ctx, "Usage: /kick <username>");
    return;
  }

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, target_name);
  if (target == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "User '%s' is not connected.", target_name);
    session_send_system_line(ctx, message);
    return;
  }

  if (target == ctx) {
    session_send_system_line(ctx, "You cannot kick yourself.");
    return;
  }

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* [%s] has been kicked by [%s]", target->user.name, ctx->user.name);
  host_history_record_system(ctx->owner, notice);
  chat_room_broadcast(&ctx->owner->room, notice, NULL);

  const bool target_active = session_transport_active(target);
  if (!target_active || (target->transport_kind == SESSION_TRANSPORT_SSH && target->session == NULL)) {
    target->should_exit = true;
    target->has_joined_room = false;
    chat_room_remove(&ctx->owner->room, target);
    session_send_system_line(ctx, "User removed from the chat.");
  } else {
    session_send_system_line(target, "You have been kicked by an operator.");
    target->should_exit = true;
    session_transport_request_close(target);
    target->has_joined_room = false;
    chat_room_remove(&ctx->owner->room, target);
    session_send_system_line(ctx, "User removed from the chat.");
  }

  printf("[kick] %s kicked %s\n", ctx->user.name, target->user.name);
}

static void session_handle_ban_name(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (!ctx->user.is_operator) {
    session_send_system_line(ctx, "You are not allowed to ban nicknames.");
    return;
  }

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "Host unavailable.");
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /banname <nickname>");
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%s", arguments);
  trim_whitespace_inplace(target_name);

  if (target_name[0] == '\0') {
    session_send_system_line(ctx, "Usage: /banname <nickname>");
    return;
  }

  for (size_t idx = 0U; target_name[idx] != '\0'; ++idx) {
    const unsigned char ch = (unsigned char)target_name[idx];
    if (ch <= 0x1FU || ch == 0x7FU || ch == ' ' || ch == '\t') {
      session_send_system_line(ctx, "Nicknames may not include control characters or whitespace.");
      return;
    }
  }

  if (host_is_username_banned(ctx->owner, target_name)) {
    session_send_system_line(ctx, "That nickname is already blocked for bot detection.");
    return;
  }

  if (!host_add_ban_entry(ctx->owner, target_name, "")) {
    session_send_system_line(ctx, "Unable to add ban entry (list full?).");
    return;
  }

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* Nickname '%s' blocked for bot detection by [%s]", target_name, ctx->user.name);
  host_history_record_system(ctx->owner, notice);
  chat_room_broadcast(&ctx->owner->room, notice, NULL);
  session_send_system_line(ctx, "Nickname ban applied.");
  printf("[banname] %s banned nickname %s\n", ctx->user.name, target_name);

  session_ctx_t *active = chat_room_find_user(&ctx->owner->room, target_name);
  if (active != NULL) {
    session_send_system_line(active,
                             "Your nickname is now blocked for bot detection. Use /nick <name> to change immediately.");
  }
}

static void session_handle_ban(session_ctx_t *ctx, const char *arguments) {
  if (!ctx->user.is_operator) {
    session_send_system_line(ctx, "You are not allowed to ban users.");
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /ban <username>");
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%s", arguments);
  trim_whitespace_inplace(target_name);

  if (target_name[0] == '\0') {
    session_send_system_line(ctx, "Usage: /ban <username>");
    return;
  }

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, target_name);
  if (target == NULL) {
    bool valid_ip = false;
    unsigned char inet_buffer[sizeof(struct in6_addr)];
    if (inet_pton(AF_INET, target_name, inet_buffer) == 1 ||
        inet_pton(AF_INET6, target_name, inet_buffer) == 1) {
      valid_ip = true;
    }

    bool valid_cidr = false;
    if (!valid_ip && strchr(target_name, '/') != NULL) {
      uint32_t ipv4_network = 0U;
      uint32_t ipv4_mask = 0U;
      struct in6_addr ipv6_network;
      struct in6_addr ipv6_mask;
      memset(&ipv6_network, 0, sizeof(ipv6_network));
      memset(&ipv6_mask, 0, sizeof(ipv6_mask));
      valid_cidr =
          host_parse_ipv4_cidr(target_name, &ipv4_network, &ipv4_mask) ||
          host_parse_ipv6_cidr(target_name, &ipv6_network, &ipv6_mask);
    }

    if (valid_ip || valid_cidr) {
      if (host_add_ban_entry(ctx->owner, "", target_name)) {
        char notice[SSH_CHATTER_MESSAGE_LIMIT];
        const char *label = valid_cidr ? "CIDR" : "IP";
        snprintf(notice, sizeof(notice), "%s '%s' has been banned.", label, target_name);
        session_send_system_line(ctx, notice);
      } else {
        session_send_system_line(ctx, "Unable to add ban entry (list full?).");
      }
    } else {
      char not_found[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(not_found, sizeof(not_found), "User '%s' is not connected.", target_name);
      session_send_system_line(ctx, not_found);
    }
    return;
  }

  if (target->user.is_lan_operator) {
    session_send_system_line(ctx, "LAN operators cannot be banned.");
    return;
  }

  const char *target_ip = target->client_ip[0] != '\0' ? target->client_ip : "";
  if (!host_add_ban_entry(ctx->owner, target->user.name, target_ip)) {
    session_send_system_line(ctx, "Unable to add ban entry (list full?).");
    return;
  }

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* [%s] has been banned by [%s]", target->user.name, ctx->user.name);
  host_history_record_system(ctx->owner, notice);
  chat_room_broadcast(&ctx->owner->room, notice, NULL);
  session_send_system_line(ctx, "Ban applied.");
  printf("[ban] %s banned %s (%s)\n", ctx->user.name, target->user.name, target_ip[0] != '\0' ? target_ip : "unknown");

  if (session_transport_active(target)) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "You have been banned by [%s].", ctx->user.name);
    session_send_system_line(target, message);
    target->should_exit = true;
    session_transport_request_close(target);
  }
}

static void session_handle_ban_list(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (!ctx->user.is_operator) {
    session_send_system_line(ctx, "You are not allowed to view the ban list.");
    return;
  }

  if (arguments != NULL) {
    while (*arguments != '\0' && isspace((unsigned char)*arguments)) {
      ++arguments;
    }
    if (*arguments != '\0') {
      session_send_system_line(ctx, "Usage: /banlist");
      return;
    }
  }

  host_t *host = ctx->owner;
  if (host == NULL) {
    session_send_system_line(ctx, "Host unavailable.");
    return;
  }

  typedef struct ban_snapshot {
    char username[SSH_CHATTER_USERNAME_LEN];
    char ip[SSH_CHATTER_IP_LEN];
  } ban_snapshot_t;

  ban_snapshot_t entries[SSH_CHATTER_MAX_BANS];
  size_t entry_count = 0U;

  pthread_mutex_lock(&host->lock);
  entry_count = host->ban_count;
  if (entry_count > SSH_CHATTER_MAX_BANS) {
    entry_count = SSH_CHATTER_MAX_BANS;
  }
  for (size_t idx = 0U; idx < entry_count; ++idx) {
    snprintf(entries[idx].username, sizeof(entries[idx].username), "%s", host->bans[idx].username);
    snprintf(entries[idx].ip, sizeof(entries[idx].ip), "%s", host->bans[idx].ip);
  }
  pthread_mutex_unlock(&host->lock);

  if (entry_count == 0U) {
    session_send_system_line(ctx, "No active bans.");
    return;
  }

  session_send_system_line(ctx, "Active bans:");
  for (size_t idx = 0U; idx < entry_count; ++idx) {
    const char *username = entries[idx].username;
    const char *ip = entries[idx].ip;
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    if (username[0] != '\0' && ip[0] != '\0') {
      snprintf(message, sizeof(message), "%zu. user: %s, ip: %s", idx + 1U, username, ip);
    } else if (username[0] != '\0') {
      snprintf(message, sizeof(message), "%zu. user: %s", idx + 1U, username);
    } else if (ip[0] != '\0') {
      snprintf(message, sizeof(message), "%zu. ip: %s", idx + 1U, ip);
    } else {
      snprintf(message, sizeof(message), "%zu. <empty>", idx + 1U);
    }
    session_send_system_line(ctx, message);
  }
}

static void session_handle_getaddr(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "You are not allowed to run that command.");
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /getaddr <username>");
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%s", arguments);
  trim_whitespace_inplace(target_name);

  if (target_name[0] == '\0') {
    session_send_system_line(ctx, "Usage: /getaddr <username>");
    return;
  }

  host_t *host = ctx->owner;
  if (host == NULL) {
    session_send_system_line(ctx, "Host unavailable.");
    return;
  }

  char ip[SSH_CHATTER_IP_LEN];
  if (!host_lookup_last_ip(host, target_name, ip, sizeof(ip)) || ip[0] == '\0') {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No recorded address for '%s'.", target_name);
    session_send_system_line(ctx, message);
    return;
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Last known address for '%s': %s", target_name, ip);
  session_send_system_line(ctx, message);
}

static void session_handle_poke(session_ctx_t *ctx, const char *arguments) {
  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /poke <username>");
    return;
  }

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, arguments);
  if (target == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "User '%s' is not connected.", arguments);
    session_send_system_line(ctx, message);
    return;
  }

  printf("[poke] %s pokes %s\n", ctx->user.name, target->user.name);
  session_channel_write(target, "\a", 1U);
  session_send_system_line(ctx, "Poke sent.");
}

static void session_handle_block(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /block <username|ip|list|confirm <username> <only|ip>>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/block", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  if (strcasecmp(working, "list") == 0) {
    session_blocklist_show(ctx);
    return;
  }

  if (strncasecmp(working, "confirm", 7) == 0 &&
      (working[7] == '\0' || isspace((unsigned char)working[7]))) {
    char *cursor = working + 7;
    while (*cursor != '\0' && isspace((unsigned char)*cursor)) {
      ++cursor;
    }

    if (*cursor == '\0') {
      session_send_system_line(ctx, usage);
      return;
    }

    char username[SSH_CHATTER_USERNAME_LEN];
    size_t name_len = 0U;
    while (*cursor != '\0' && !isspace((unsigned char)*cursor) && name_len + 1U < sizeof(username)) {
      username[name_len++] = *cursor++;
    }
    username[name_len] = '\0';

    while (*cursor != '\0' && isspace((unsigned char)*cursor)) {
      ++cursor;
    }

    if (*cursor == '\0') {
      session_send_system_line(ctx, usage);
      return;
    }

    char mode[16];
    size_t mode_len = 0U;
    while (*cursor != '\0' && !isspace((unsigned char)*cursor) && mode_len + 1U < sizeof(mode)) {
      mode[mode_len++] = *cursor++;
    }
    mode[mode_len] = '\0';

    if (!ctx->block_pending.active) {
      session_send_system_line(ctx, "No provider block is awaiting confirmation.");
      return;
    }

    if (strncmp(ctx->block_pending.username, username, SSH_CHATTER_USERNAME_LEN) != 0) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Pending block is for [%s], not [%s].", ctx->block_pending.username, username);
      session_send_system_line(ctx, message);
      return;
    }

    bool block_ip = false;
    if (strcasecmp(mode, "ip") == 0 || strcasecmp(mode, "all") == 0 || strcasecmp(mode, "full") == 0) {
      block_ip = true;
    } else if (strcasecmp(mode, "only") == 0 || strcasecmp(mode, "user") == 0 || strcasecmp(mode, "name") == 0) {
      block_ip = false;
    } else {
      session_send_system_line(ctx, usage);
      return;
    }

    bool already_present = false;
    if (!session_blocklist_add(ctx, ctx->block_pending.ip, ctx->block_pending.username, block_ip, &already_present)) {
      if (already_present) {
        session_send_system_line(ctx, "That target is already blocked.");
      } else {
        session_send_system_line(ctx, "Unable to add block entry (limit reached?).");
      }
    } else {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      if (block_ip) {
        snprintf(message, sizeof(message), "Blocking all users from %.63s.", ctx->block_pending.ip);
      } else {
        snprintf(message, sizeof(message), "Blocking [%.23s] only (IP %.63s).", ctx->block_pending.username,
                 ctx->block_pending.ip);
      }
      session_send_system_line(ctx, message);
    }

    ctx->block_pending.active = false;
    ctx->block_pending.username[0] = '\0';
    ctx->block_pending.ip[0] = '\0';
    ctx->block_pending.provider_label[0] = '\0';
    return;
  }

  unsigned char inet_buffer[sizeof(struct in6_addr)];
  if (inet_pton(AF_INET, working, inet_buffer) == 1 || inet_pton(AF_INET6, working, inet_buffer) == 1) {
    bool already_present = false;
    char label[64];
    bool provider = session_detect_provider_ip(working, label, sizeof(label));
    if (provider && label[0] != '\0') {
      char warning[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(warning, sizeof(warning),
               "Error: You cannot ban a country."
               "%.256s is flagged as %.63s; other people may also be hidden.", working, label);
      session_send_system_line(ctx, warning);
      return;
    }
    if (!session_blocklist_add(ctx, working, "", true, &already_present)) {
      if (already_present) {
        session_send_system_line(ctx, "That IP is already blocked.");
      } else {
        session_send_system_line(ctx, "Unable to add block entry (limit reached?).");
      }
    } else {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Blocking all users from %.256s.", working);
      session_send_system_line(ctx, message);
    }
    return;
  }

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "Block list unavailable right now.");
    return;
  }

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, working);
  if (target == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "User '%.256s' is not connected.", working);
    session_send_system_line(ctx, message);
    return;
  }

  if (target == ctx) {
    session_send_system_line(ctx, "You do not need to block yourself.");
    return;
  }

  if (target->client_ip[0] == '\0') {
    session_send_system_line(ctx, "Unable to identify that user's IP address right now.");
    return;
  }

  char label[64];
  if (session_detect_provider_ip(target->client_ip, label, sizeof(label))) {
    memset(&ctx->block_pending, 0, sizeof(ctx->block_pending));
    ctx->block_pending.active = true;
    snprintf(ctx->block_pending.username, sizeof(ctx->block_pending.username), "%s", target->user.name);
    snprintf(ctx->block_pending.ip, sizeof(ctx->block_pending.ip), "%s", target->client_ip);
    snprintf(ctx->block_pending.provider_label, sizeof(ctx->block_pending.provider_label), "%.31s", label);

    char warning[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(warning, sizeof(warning), "%.63s appears to belong to %.63s.", target->client_ip, label);
    session_send_system_line(ctx, warning);

    char prompt[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(prompt, sizeof(prompt),
             "Use /block confirm %.23s only to hide just [%.23s] or /block confirm %.23s ip to hide everyone from that IP.",
             target->user.name, target->user.name, target->user.name);
    session_send_system_line(ctx, prompt);
    return;
  }

  bool already_present = false;
  if (!session_blocklist_add(ctx, target->client_ip, target->user.name, true, &already_present)) {
    if (already_present) {
      session_send_system_line(ctx, "That address is already blocked.");
    } else {
      session_send_system_line(ctx, "Unable to add block entry (limit reached?).");
    }
  } else {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Blocking all users from %.63s (triggered by [%.23s]).", target->client_ip,
             target->user.name);
    session_send_system_line(ctx, message);
  }
}

static void session_handle_unblock(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /unblock <username|ip|all>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/unblock", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  if (strcasecmp(working, "all") == 0) {
    size_t removed = 0U;
    for (size_t idx = 0U; idx < SSH_CHATTER_MAX_BLOCKED; ++idx) {
      if (ctx->block_entries[idx].in_use) {
        memset(&ctx->block_entries[idx], 0, sizeof(ctx->block_entries[idx]));
        ++removed;
      }
    }
    ctx->block_entry_count = 0U;
    ctx->block_pending.active = false;
    ctx->block_pending.username[0] = '\0';
    ctx->block_pending.ip[0] = '\0';
    ctx->block_pending.provider_label[0] = '\0';

    if (removed == 0U) {
      session_send_system_line(ctx, "No blocked entries to remove.");
    } else {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Removed %zu blocked entr%s.", removed, removed == 1U ? "y" : "ies");
      session_send_system_line(ctx, message);
    }
    return;
  }

  if (session_blocklist_remove(ctx, working)) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Removed block for %.256s.", working);
    session_send_system_line(ctx, message);
  } else {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No block entry matched '%.256s'.", working);
    session_send_system_line(ctx, message);
  }
}

static void session_handle_pm(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /pm <username> <message>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/pm", kUsage, usage, sizeof(usage));

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "Private messages are unavailable right now.");
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *cursor = working;
  while (*cursor != '\0' && !isspace((unsigned char)*cursor)) {
    ++cursor;
  }

  if (*cursor == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  *cursor = '\0';
  char *message = cursor + 1;
  while (*message != '\0' && isspace((unsigned char)*message)) {
    ++message;
  }

  if (*message == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%.*s", (int)sizeof(target_name) - 1, working);

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, target_name);
  const bool target_is_eliza = strcasecmp(target_name, "eliza") == 0;
  const bool eliza_active = target_is_eliza && atomic_load(&ctx->owner->eliza_enabled);

  if (target == NULL) {
    if (target_is_eliza) {
      if (!eliza_active) {
        session_send_system_line(ctx, "eliza isn't around right now.");
        return;
      }
      session_send_system_line(ctx, "Connecting you with eliza...");
    } else {
      char not_found[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(not_found, sizeof(not_found), "User '%s' is not connected.", target_name);
      session_send_system_line(ctx, not_found);
      return;
    }
  }

  char prepared[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(prepared, sizeof(prepared), "%s", message);

  char stripped[SSH_CHATTER_MESSAGE_LIMIT];
  bool translation_bypass = translation_strip_no_translate_prefix(prepared, stripped, sizeof(stripped));
  const char *deliver_body = translation_bypass ? stripped : prepared;

  const char *target_display = target != NULL ? target->user.name : target_name;
  printf("[pm] %s -> %s: %s\n", ctx->user.name, target_display, deliver_body);

  char to_target_label[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(to_target_label, sizeof(to_target_label), "%s -> you", ctx->user.name);

  char to_sender_label[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(to_sender_label, sizeof(to_sender_label), "you -> %s", target_display);

  bool attempt_translation = (target != NULL) && !translation_bypass && ctx->translation_enabled &&
                             ctx->input_translation_enabled && ctx->input_translation_language[0] != '\0';

  if (attempt_translation) {
    if (session_translation_queue_private_message(ctx, target, deliver_body)) {
      return;
    }
    session_send_system_line(ctx, "Translation unavailable; sending your original message.");
  }

  if (target != NULL) {
    session_send_private_message_line(target, ctx, to_target_label, deliver_body);
    session_send_private_message_line(ctx, ctx, to_sender_label, deliver_body);
    return;
  }

  session_send_private_message_line(ctx, ctx, to_sender_label, deliver_body);
  host_eliza_handle_private_message(ctx, deliver_body);
}

static bool username_contains(const char *username, const char *needle) {
  if (username == NULL || needle == NULL) {
    return false;
  }

  const size_t needle_len = strlen(needle);
  if (needle_len == 0U) {
    return false;
  }

  const size_t name_len = strlen(username);
  if (needle_len > name_len) {
    return false;
  }

  for (size_t offset = 0U; offset + needle_len <= name_len; ++offset) {
    bool match = true;
    for (size_t idx = 0U; idx < needle_len; ++idx) {
      const unsigned char user_ch = (unsigned char)username[offset + idx];
      const unsigned char needle_ch = (unsigned char)needle[idx];
      if (tolower(user_ch) != tolower(needle_ch)) {
        match = false;
        break;
      }
    }
    if (match) {
      return true;
    }
  }

  return false;
}

static void session_handle_search(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "Search is unavailable at the moment.");
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /search <text>");
    return;
  }

  char query[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(query, sizeof(query), "%s", arguments);
  trim_whitespace_inplace(query);

  if (query[0] == '\0') {
    session_send_system_line(ctx, "Usage: /search <text>");
    return;
  }

  char listing[SSH_CHATTER_MESSAGE_LIMIT];
  listing[0] = '\0';
  size_t match_count = 0U;

  pthread_mutex_lock(&ctx->owner->room.lock);
  for (size_t idx = 0U; idx < ctx->owner->room.member_count; ++idx) {
    session_ctx_t *member = ctx->owner->room.members[idx];
    if (member == NULL) {
      continue;
    }
    if (!username_contains(member->user.name, query)) {
      continue;
    }

    char name[SSH_CHATTER_USERNAME_LEN];
    snprintf(name, sizeof(name), "%s", member->user.name);
    size_t current_len = strnlen(listing, sizeof(listing));
    size_t name_len = strnlen(name, sizeof(name));
    size_t prefix_len = (match_count == 0U) ? 0U : 2U;

    if (current_len + prefix_len + name_len >= sizeof(listing)) {
      continue;
    }

    if (match_count > 0U) {
      listing[current_len++] = ',';
      listing[current_len++] = ' ';
    }
    memcpy(listing + current_len, name, name_len);
    listing[current_len + name_len] = '\0';
    ++match_count;
  }
  pthread_mutex_unlock(&ctx->owner->room.lock);

  if (match_count == 0U) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    char display_query[64];
    size_t copy_len = strnlen(query, sizeof(display_query) - 1U);
    memcpy(display_query, query, copy_len);
    display_query[copy_len] = '\0';
    snprintf(message, sizeof(message), "No users matching '%s'.", display_query);
    session_send_system_line(ctx, message);
    return;
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Matching users (%zu):", match_count);
  session_send_system_line(ctx, header);
  session_send_system_line(ctx, listing);
}

static void session_handle_chat_lookup(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /chat <message-id>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/chat", kUsage, usage, sizeof(usage));

  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[64];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *endptr = NULL;
  unsigned long long parsed = strtoull(working, &endptr, 10);
  if (parsed == 0ULL || (endptr != NULL && *endptr != '\0')) {
    session_send_system_line(ctx, usage);
    return;
  }

  uint64_t message_id = (uint64_t)parsed;
  chat_history_entry_t entry = {0};
  if (!host_history_find_entry_by_id(ctx->owner, message_id, &entry)) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Message #%" PRIu64 " was not found.", message_id);
    session_send_system_line(ctx, message);
    return;
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Message #%" PRIu64 ":", message_id);
  session_send_system_line(ctx, header);
  session_send_history_entry(ctx, &entry);
  session_send_reply_tree(ctx, entry.message_id, 0U, 1U);
}

static void session_handle_reply(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(usage, sizeof(usage), "Usage: %s <message-id|r<reply-id>> <text>",
           session_command_alias_preferred_by_canonical(ctx, "/reply"));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *target = strtok_r(working, " \t", &saveptr);
  if (target == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char *text = NULL;
  if (saveptr != NULL) {
    text = saveptr;
    while (*text == ' ' || *text == '\t') {
      ++text;
    }
  }

  if (text == NULL || *text == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  bool targeting_reply = false;
  if (*target == '#') {
    ++target;
  }
  if (*target == 'r' || *target == 'R') {
    targeting_reply = true;
    ++target;
  }

  if (*target == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *endptr = NULL;
  unsigned long long parsed = strtoull(target, &endptr, 10);
  if (parsed == 0ULL || (endptr != NULL && *endptr != '\0')) {
    session_send_system_line(ctx, usage);
    return;
  }

  uint64_t identifier = (uint64_t)parsed;

  chat_reply_entry_t parent_reply = {0};
  uint64_t parent_reply_id = 0U;
  uint64_t parent_message_id = 0U;

  if (targeting_reply) {
    if (!host_replies_find_entry_by_id(ctx->owner, identifier, &parent_reply)) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Reply r#%" PRIu64 " was not found.", identifier);
      session_send_system_line(ctx, message);
      return;
    }
    parent_message_id = parent_reply.parent_message_id;
    parent_reply_id = parent_reply.reply_id;
  } else {
    chat_history_entry_t parent_entry = {0};
    if (host_history_find_entry_by_id(ctx->owner, identifier, &parent_entry)) {
      parent_message_id = parent_entry.message_id;
    } else if (host_replies_find_entry_by_id(ctx->owner, identifier, &parent_reply)) {
      parent_message_id = parent_reply.parent_message_id;
      parent_reply_id = parent_reply.reply_id;
    } else {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Message or reply #%" PRIu64 " was not found.", identifier);
      session_send_system_line(ctx, message);
      return;
    }
  }

  if (parent_message_id == 0U) {
    session_send_system_line(ctx, "Unable to determine reply target.");
    return;
  }

  char normalized[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(normalized, sizeof(normalized), "%s", text);
  session_normalize_newlines(normalized);
  trim_whitespace_inplace(normalized);
  for (size_t idx = 0U; normalized[idx] != '\0'; ++idx) {
    if (normalized[idx] == '\n') {
      normalized[idx] = ' ';
    }
  }
  trim_whitespace_inplace(normalized);

  if (normalized[0] == '\0') {
    session_send_system_line(ctx, "Reply text cannot be empty.");
    return;
  }

  chat_reply_entry_t entry = {0};
  entry.parent_message_id = parent_message_id;
  entry.parent_reply_id = parent_reply_id;
  entry.created_at = time(NULL);
  snprintf(entry.username, sizeof(entry.username), "%s", ctx->user.name);
  snprintf(entry.message, sizeof(entry.message), "%s", normalized);

  chat_reply_entry_t stored = {0};
  if (!host_replies_commit_entry(ctx->owner, &entry, &stored)) {
    session_send_system_line(ctx, "Unable to record reply.");
    return;
  }

  host_broadcast_reply(ctx->owner, &stored);
}

static void session_handle_image(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /image <url> [caption]";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/image", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *url = strtok_r(working, " \t", &saveptr);
  if (url == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char *caption = NULL;
  if (saveptr != NULL) {
    caption = saveptr;
    while (*caption == ' ' || *caption == '\t') {
      ++caption;
    }
    if (*caption == '\0') {
      caption = NULL;
    }
  }

  if (strnlen(url, SSH_CHATTER_ATTACHMENT_TARGET_LEN) >= SSH_CHATTER_ATTACHMENT_TARGET_LEN) {
    session_send_system_line(ctx, "Image URL is too long.");
    return;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, ctx, "shared an image");
  entry.attachment_type = CHAT_ATTACHMENT_IMAGE;
  snprintf(entry.attachment_target, sizeof(entry.attachment_target), "%s", url);
  if (caption != NULL) {
    trim_whitespace_inplace(caption);
    snprintf(entry.attachment_caption, sizeof(entry.attachment_caption), "%s", caption);
  }

  chat_history_entry_t stored = {0};
  if (!host_history_commit_entry(ctx->owner, &entry, &stored)) {
    session_send_system_line(ctx, "Unable to record image message.");
    return;
  }

  session_send_history_entry(ctx, &stored);
  chat_room_broadcast_entry(&ctx->owner->room, &stored, ctx);
  host_notify_external_clients(ctx->owner, &stored);
}

static void session_handle_video(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /video <url> [caption]";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/video", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *url = strtok_r(working, " \t", &saveptr);
  if (url == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char *caption = NULL;
  if (saveptr != NULL) {
    caption = saveptr;
    while (*caption == ' ' || *caption == '\t') {
      ++caption;
    }
    if (*caption == '\0') {
      caption = NULL;
    }
  }

  if (strnlen(url, SSH_CHATTER_ATTACHMENT_TARGET_LEN) >= SSH_CHATTER_ATTACHMENT_TARGET_LEN) {
    session_send_system_line(ctx, "Video link is too long.");
    return;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, ctx, "shared a video");
  entry.attachment_type = CHAT_ATTACHMENT_VIDEO;
  snprintf(entry.attachment_target, sizeof(entry.attachment_target), "%s", url);
  if (caption != NULL) {
    trim_whitespace_inplace(caption);
    snprintf(entry.attachment_caption, sizeof(entry.attachment_caption), "%s", caption);
  }

  chat_history_entry_t stored = {0};
  if (!host_history_commit_entry(ctx->owner, &entry, &stored)) {
    session_send_system_line(ctx, "Unable to record video message.");
    return;
  }

  session_send_history_entry(ctx, &stored);
  chat_room_broadcast_entry(&ctx->owner->room, &stored, ctx);
  host_notify_external_clients(ctx->owner, &stored);
}

static void session_handle_audio(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /audio <url> [caption]";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/audio", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *url = strtok_r(working, " \t", &saveptr);
  if (url == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char *caption = NULL;
  if (saveptr != NULL) {
    caption = saveptr;
    while (*caption == ' ' || *caption == '\t') {
      ++caption;
    }
    if (*caption == '\0') {
      caption = NULL;
    }
  }

  if (strnlen(url, SSH_CHATTER_ATTACHMENT_TARGET_LEN) >= SSH_CHATTER_ATTACHMENT_TARGET_LEN) {
    session_send_system_line(ctx, "Audio link is too long.");
    return;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, ctx, "shared an audio clip");
  entry.attachment_type = CHAT_ATTACHMENT_AUDIO;
  snprintf(entry.attachment_target, sizeof(entry.attachment_target), "%s", url);
  if (caption != NULL) {
    trim_whitespace_inplace(caption);
    snprintf(entry.attachment_caption, sizeof(entry.attachment_caption), "%s", caption);
  }

  chat_history_entry_t stored = {0};
  if (!host_history_commit_entry(ctx->owner, &entry, &stored)) {
    session_send_system_line(ctx, "Unable to record audio message.");
    return;
  }

  session_send_history_entry(ctx, &stored);
  chat_room_broadcast_entry(&ctx->owner->room, &stored, ctx);
  host_notify_external_clients(ctx->owner, &stored);
}

static void session_handle_files(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /files <url> [caption]";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/files", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *url = strtok_r(working, " \t", &saveptr);
  if (url == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char *caption = NULL;
  if (saveptr != NULL) {
    caption = saveptr;
    while (*caption == ' ' || *caption == '\t') {
      ++caption;
    }
    if (*caption == '\0') {
      caption = NULL;
    }
  }

  if (strnlen(url, SSH_CHATTER_ATTACHMENT_TARGET_LEN) >= SSH_CHATTER_ATTACHMENT_TARGET_LEN) {
    session_send_system_line(ctx, "File link is too long.");
    return;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, ctx, "shared a file");
  entry.attachment_type = CHAT_ATTACHMENT_FILE;
  snprintf(entry.attachment_target, sizeof(entry.attachment_target), "%s", url);
  if (caption != NULL) {
    trim_whitespace_inplace(caption);
    snprintf(entry.attachment_caption, sizeof(entry.attachment_caption), "%s", caption);
  }

  chat_history_entry_t stored = {0};
  if (!host_history_commit_entry(ctx->owner, &entry, &stored)) {
    session_send_system_line(ctx, "Unable to record file message.");
    return;
  }

  session_send_history_entry(ctx, &stored);
  chat_room_broadcast_entry(&ctx->owner->room, &stored, ctx);
  host_notify_external_clients(ctx->owner, &stored);
}

static void session_mail_render_inbox(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (!session_user_data_load(ctx)) {
    session_send_system_line(ctx, "Mailbox storage is unavailable.");
    return;
  }

  if (ctx->user_data.mailbox_count == 0U) {
    session_send_system_line(ctx, "Your mailbox is empty.");
    return;
  }

  char header[128];
  snprintf(header, sizeof(header), "Mailbox (%u message%s):", (unsigned int)ctx->user_data.mailbox_count,
           ctx->user_data.mailbox_count == 1U ? "" : "s");
  session_send_system_line(ctx, header);

  for (size_t idx = 0U; idx < ctx->user_data.mailbox_count; ++idx) {
    const user_data_mail_entry_t *entry = &ctx->user_data.mailbox[idx];
    time_t stamp = (time_t)entry->timestamp;
    struct tm when;
    char stamp_text[32];
    if (stamp != 0 && localtime_r(&stamp, &when) != NULL) {
      if (strftime(stamp_text, sizeof(stamp_text), "%Y-%m-%d %H:%M", &when) == 0U) {
        snprintf(stamp_text, sizeof(stamp_text), "%s", "(time unknown)");
      }
    } else {
      snprintf(stamp_text, sizeof(stamp_text), "%s", "(time unknown)");
    }

    char body[USER_DATA_MAILBOX_MESSAGE_LEN];
    snprintf(body, sizeof(body), "%s", entry->message);
    for (size_t pos = 0U; body[pos] != '\0'; ++pos) {
      unsigned char ch = (unsigned char)body[pos];
      if (ch < ' ' && ch != '\n' && ch != '\t') {
        body[pos] = ' ';
      }
      if (body[pos] == '\n') {
        body[pos] = ' ';
      }
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "[%s] %s: %s", stamp_text,
             entry->sender[0] != '\0' ? entry->sender : "(unknown)", body);
    session_send_system_line(ctx, line);
  }
}

static void session_handle_mail(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!session_user_data_available(ctx) && !ctx->owner->user_data_ready) {
    session_send_system_line(ctx, "Mailbox storage is unavailable.");
    return;
  }

  const char *cursor = arguments != NULL ? arguments : "";
  char command[16];
  cursor = session_consume_token(cursor, command, sizeof(command));

  if (command[0] == '\0' || strcasecmp(command, "inbox") == 0) {
    session_mail_render_inbox(ctx);
    return;
  }

  if (strcasecmp(command, "send") == 0) {
    char target_token[SSH_CHATTER_USERNAME_LEN + SSH_CHATTER_IP_LEN];
    cursor = session_consume_token(cursor, target_token, sizeof(target_token));
    if (target_token[0] == '\0' || cursor == NULL || cursor[0] == '\0') {
      session_send_system_line(ctx, "Usage: /mail send <user[@ip]> <message>");
      return;
    }

    char target[SSH_CHATTER_USERNAME_LEN];
    char target_ip[SSH_CHATTER_IP_LEN];
    target_ip[0] = '\0';
    const char *at = strchr(target_token, '@');
    if (at != NULL) {
      size_t name_len = (size_t)(at - target_token);
      if (name_len == 0U || name_len >= sizeof(target)) {
        session_send_system_line(ctx, "Invalid mailbox recipient.");
        return;
      }
      memcpy(target, target_token, name_len);
      target[name_len] = '\0';
      const char *ip_part = at + 1;
      if (ip_part[0] != '\0') {
        if (strlen(ip_part) >= sizeof(target_ip)) {
          session_send_system_line(ctx, "Recipient IP is too long.");
          return;
        }
        snprintf(target_ip, sizeof(target_ip), "%s", ip_part);
      }
    } else {
      snprintf(target, sizeof(target), "%s", target_token);
    }

    if (target[0] == '\0') {
      session_send_system_line(ctx, "Invalid mailbox recipient.");
      return;
    }

    char message[USER_DATA_MAILBOX_MESSAGE_LEN];
    snprintf(message, sizeof(message), "%s", cursor);
    trim_whitespace_inplace(message);
    if (message[0] == '\0') {
      session_send_system_line(ctx, "Mailbox message cannot be empty.");
      return;
    }

    char error[128];
    if (!host_user_data_send_mail(ctx->owner, target, target_ip[0] != '\0' ? target_ip : NULL, ctx->user.name,
                                  message, error, sizeof(error))) {
      if (error[0] != '\0') {
        session_send_system_line(ctx, error);
      } else {
        session_send_system_line(ctx, "Unable to deliver mailbox message.");
      }
      return;
    }

    if (strcasecmp(target, ctx->user.name) == 0) {
      (void)session_user_data_load(ctx);
    }

    char confirmation[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(confirmation, sizeof(confirmation), "Delivered mailbox message to %s.", target);
    session_send_system_line(ctx, confirmation);
    return;
  }

  if (strcasecmp(command, "clear") == 0) {
    if (!session_user_data_load(ctx)) {
      session_send_system_line(ctx, "Mailbox storage is unavailable.");
      return;
    }

    ctx->user_data.mailbox_count = 0U;
    memset(ctx->user_data.mailbox, 0, sizeof(ctx->user_data.mailbox));
    if (session_user_data_commit(ctx)) {
      session_send_system_line(ctx, "Mailbox cleared.");
    } else {
      session_send_system_line(ctx, "Failed to update mailbox.");
    }
    return;
  }

  session_send_system_line(ctx, "Usage: /mail [inbox|send <user> <message>|clear]");
}

static void session_profile_picture_normalize(const char *input, char *output, size_t length) {
  if (output == NULL || length == 0U) {
    return;
  }

  output[0] = '\0';
  if (input == NULL) {
    return;
  }

  size_t out_idx = 0U;
  size_t idx = 0U;
  while (input[idx] != '\0') {
    size_t skip = host_column_reset_sequence_length(&input[idx]);
    if (skip > 0U) {
      idx += skip;
      continue;
    }

    unsigned char ch = (unsigned char)input[idx];
    ++idx;
    if (ch == '\r') {
      continue;
    }
    if (ch >= 32U || ch == '\n' || ch == '\t') {
      if (out_idx + 1U < length) {
        output[out_idx++] = (char)ch;
      }
    }
  }

  if (out_idx < length) {
    output[out_idx] = '\0';
  } else {
    output[length - 1U] = '\0';
  }
}

static void session_handle_profile_picture(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!session_user_data_available(ctx) && !ctx->owner->user_data_ready) {
    session_send_system_line(ctx, "Profile storage is unavailable.");
    return;
  }

  const char *cursor = arguments != NULL ? arguments : "";
  char mode[16];
  cursor = session_consume_token(cursor, mode, sizeof(mode));

  if (mode[0] != '\0' && strcasecmp(mode, "ascii") != 0) {
    session_send_system_line(ctx, "Usage: /profilepic");
    return;
  }

  if (cursor != NULL && *cursor != '\0') {
    session_send_system_line(ctx, "Usage: /profilepic");
    return;
  }

  session_asciiart_begin(ctx, SESSION_ASCIIART_TARGET_PROFILE_PICTURE);
}

static void session_handle_reaction(session_ctx_t *ctx, size_t reaction_index, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL || reaction_index >= SSH_CHATTER_REACTION_KIND_COUNT) {
    return;
  }

  const reaction_descriptor_t *descriptor = &REACTION_DEFINITIONS[reaction_index];

  char usage[64];
  char canonical[32];
  int written = snprintf(canonical, sizeof(canonical), "/%s", descriptor->command);
  if (written < 0 || (size_t)written >= sizeof(canonical)) {
    canonical[0] = '\0';
  }
  const char *command_label = canonical[0] != '\0' ? session_command_alias_preferred_by_canonical(ctx, canonical) : NULL;
  if (command_label == NULL || command_label[0] == '\0') {
    command_label = canonical;
  }

  snprintf(usage, sizeof(usage), "Usage: %s <message-id>", command_label != NULL ? command_label : "");

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[64];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *endptr = NULL;
  unsigned long long parsed = strtoull(working, &endptr, 10);
  if (parsed == 0ULL || (endptr != NULL && *endptr != '\0')) {
    session_send_system_line(ctx, usage);
    return;
  }

  uint64_t message_id = (uint64_t)parsed;
  chat_history_entry_t updated = {0};
  if (!host_history_apply_reaction(ctx->owner, message_id, reaction_index, &updated)) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Message #%" PRIu64 " was not found or cannot be reacted to.", message_id);
    session_send_system_line(ctx, message);
    return;
  }

  char confirmation[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(confirmation, sizeof(confirmation), "Added %s %s to message #%" PRIu64 ".", descriptor->icon, descriptor->label,
           message_id);
  session_send_system_line(ctx, confirmation);
  chat_room_broadcast_reaction_update(ctx->owner, &updated);
  host_notify_external_clients(ctx->owner, &updated);
}

static void session_handle_usercount(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  size_t count = 0U;
  pthread_mutex_lock(&ctx->owner->room.lock);
  count = ctx->owner->room.member_count;
  pthread_mutex_unlock(&ctx->owner->room.lock);

  const bool eliza_active = atomic_load(&ctx->owner->eliza_enabled);
  size_t displayed = count;
  if (eliza_active) {
    if (SIZE_MAX - displayed > 0U) {
      ++displayed;
    }
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  if (eliza_active && displayed > count) {
    snprintf(message, sizeof(message), "There %s currently %zu user%s connected (including eliza).",
             displayed == 1U ? "is" : "are", displayed, displayed == 1U ? "" : "s");
  } else {
    snprintf(message, sizeof(message), "There %s currently %zu user%s connected.",
             displayed == 1U ? "is" : "are", displayed, displayed == 1U ? "" : "s");
  }

  host_history_record_system(ctx->owner, message);
  chat_room_broadcast(&ctx->owner->room, message, NULL);
}

static void session_handle_today(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  time_t now = time(NULL);
  struct tm tm_now;
#if defined(_POSIX_THREAD_SAFE_FUNCTIONS)
  if (localtime_r(&now, &tm_now) == NULL) {
    session_send_system_line(ctx, "Unable to determine local time.");
    return;
  }
#else
  struct tm *tmp = localtime(&now);
  if (tmp == NULL) {
    session_send_system_line(ctx, "Unable to determine local time.");
    return;
  }
  tm_now = *tmp;
#endif

  int year = tm_now.tm_year + 1900;
  int yday = tm_now.tm_yday;

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref == NULL) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "Unable to track today's function right now.");
    return;
  }

  if (!host->random_seeded) {
    unsigned seed = (unsigned)(now ^ (time_t)getpid());
    srand(seed);
    host->random_seeded = true;
  }

  const char *chosen = NULL;
  bool already = false;
  if (pref->daily_year == year && pref->daily_yday == yday && pref->daily_function[0] != '\0') {
    chosen = pref->daily_function;
    already = true;
  } else {
    const size_t function_count = sizeof(DAILY_FUNCTIONS) / sizeof(DAILY_FUNCTIONS[0]);
    if (function_count == 0U) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "No functions available today.");
      return;
    }
    size_t index = (size_t)rand() % function_count;
    chosen = DAILY_FUNCTIONS[index];
    pref->daily_year = year;
    pref->daily_yday = yday;
    snprintf(pref->daily_function, sizeof(pref->daily_function), "%s", chosen);
  }

  ctx->daily_year = pref->daily_year;
  ctx->daily_yday = pref->daily_yday;
  snprintf(ctx->daily_function, sizeof(ctx->daily_function), "%s", chosen);

  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  if (already) {
    snprintf(message, sizeof(message), "You've already discovered today's function: %s", chosen);
  } else {
    snprintf(message, sizeof(message), "Today's function for you is: %s", chosen);
  }
  session_send_system_line(ctx, message);
}

static void session_handle_date(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /date <Area/Location>";

  if (ctx == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/date", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char sanitized[PATH_MAX];
  if (!timezone_sanitize_identifier(working, sanitized, sizeof(sanitized))) {
    session_send_system_line(ctx, "Timezone names may only include letters, numbers, '/', '_', '-', '+', or '.'.");
    return;
  }

  char resolved[PATH_MAX];
  if (!timezone_resolve_identifier(sanitized, resolved, sizeof(resolved))) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Unknown timezone '%.128s'.", working);
    session_send_system_line(ctx, message);
    return;
  }

  const char *previous_tz = getenv("TZ");
  char previous_copy[PATH_MAX];
  bool had_previous = false;
  if (previous_tz != NULL) {
    int prev_written = snprintf(previous_copy, sizeof(previous_copy), "%s", previous_tz);
    if (prev_written >= 0 && (size_t)prev_written < sizeof(previous_copy)) {
      had_previous = true;
    }
  }

  bool tz_applied = false;

  if (setenv("TZ", resolved, 1) != 0) {
    session_send_system_line(ctx, "Unable to adjust timezone right now.");
    return;
  }

  tzset();
  tz_applied = true;

  time_t now = time(NULL);
  if (now == (time_t)-1) {
    session_send_system_line(ctx, "Unable to determine current time.");
    goto cleanup;
  }

  struct tm tm_now;
#if defined(_POSIX_THREAD_SAFE_FUNCTIONS)
  if (localtime_r(&now, &tm_now) == NULL) {
    session_send_system_line(ctx, "Unable to compute the requested local time.");
    goto cleanup;
  }
#else
  struct tm *tmp = localtime(&now);
  if (tmp == NULL) {
    session_send_system_line(ctx, "Unable to compute the requested local time.");
    goto cleanup;
  }
  tm_now = *tmp;
#endif

  char formatted[128];
  if (strftime(formatted, sizeof(formatted), "%Y-%m-%d %H:%M:%S %Z (UTC%z)", &tm_now) == 0) {
    session_send_system_line(ctx, "Unable to format the requested time.");
    goto cleanup;
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "%.128s -> %s", resolved, formatted);
  session_send_system_line(ctx, message);

cleanup:
  if (tz_applied) {
    if (had_previous) {
      setenv("TZ", previous_copy, 1);
    } else {
      unsetenv("TZ");
    }
    tzset();
  }
}

static void session_handle_os(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage =
      "Usage: /os <windows|macos|linux|freebsd|ios|android|watchos|solaris|openbsd|netbsd|dragonflybsd|reactos|tyzen|kdos|pcdos|msdos|drdos|bsd|haiku|zealos|templeos>";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/os", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_OS_NAME_LEN];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  for (size_t idx = 0U; working[idx] != '\0'; ++idx) {
    working[idx] = (char)tolower((unsigned char)working[idx]);
  }

  const os_descriptor_t *descriptor = session_lookup_os_descriptor(working);
  if (descriptor == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  snprintf(ctx->os_name, sizeof(ctx->os_name), "%s", descriptor->name);
  host_store_user_os(ctx->owner, ctx);
  session_refresh_output_encoding(ctx);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Recorded your operating system as %s.", descriptor->display);
  session_send_system_line(ctx, message);
}

static void session_handle_getos(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /getos <username>";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/getos", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char target[SSH_CHATTER_USERNAME_LEN];
  snprintf(target, sizeof(target), "%s", arguments);
  trim_whitespace_inplace(target);
  if (target[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char os_buffer[SSH_CHATTER_OS_NAME_LEN];
  if (!host_lookup_user_os(ctx->owner, target, os_buffer, sizeof(os_buffer))) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No operating system is recorded for %s.", target);
    session_send_system_line(ctx, message);
    return;
  }

  const os_descriptor_t *descriptor = session_lookup_os_descriptor(os_buffer);
  const char *display = descriptor != NULL ? descriptor->display : os_buffer;

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "%s reports using %s.", target, display);
  session_send_system_line(ctx, message);
}

static void session_handle_pair(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (ctx->os_name[0] == '\0') {
    session_send_system_line(ctx, "Set your operating system first with /os <name>.");
    return;
  }

  char matches[SSH_CHATTER_MESSAGE_LIMIT];
  matches[0] = '\0';
  size_t offset = 0U;
  size_t match_count = 0U;

  pthread_mutex_lock(&ctx->owner->room.lock);
  for (size_t idx = 0U; idx < ctx->owner->room.member_count; ++idx) {
    session_ctx_t *member = ctx->owner->room.members[idx];
    if (member == NULL || member == ctx) {
      continue;
    }
    if (member->os_name[0] == '\0') {
      continue;
    }
    if (strcasecmp(member->os_name, ctx->os_name) != 0) {
      continue;
    }

    size_t name_len = strnlen(member->user.name, sizeof(member->user.name));
    const size_t prefix = match_count == 0U ? 0U : 2U;
    if (offset + prefix + name_len >= sizeof(matches)) {
      break;
    }
    if (match_count > 0U) {
      matches[offset++] = ',';
      matches[offset++] = ' ';
    }
    memcpy(matches + offset, member->user.name, name_len);
    offset += name_len;
    matches[offset] = '\0';
    ++match_count;
  }
  pthread_mutex_unlock(&ctx->owner->room.lock);

  const os_descriptor_t *descriptor = session_lookup_os_descriptor(ctx->os_name);
  const char *display = descriptor != NULL ? descriptor->display : ctx->os_name;

  if (match_count == 0U) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No connected users currently share your %s setup.", display);
    session_send_system_line(ctx, message);
    return;
  }

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Users sharing your %s setup:", display);
  session_send_system_line(ctx, header);
  session_send_system_line(ctx, matches);
}

static void session_handle_connected(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char buffer[SSH_CHATTER_MESSAGE_LIMIT];
  size_t offset = 0U;
  size_t count = 0U;

  pthread_mutex_lock(&ctx->owner->room.lock);
  for (size_t idx = 0U; idx < ctx->owner->room.member_count; ++idx) {
    session_ctx_t *member = ctx->owner->room.members[idx];
    if (member == NULL) {
      continue;
    }

    const size_t prefix = count == 0U ? 0U : 2U;
    size_t name_len = strnlen(member->user.name, sizeof(member->user.name));
    if (offset + prefix + name_len >= sizeof(buffer)) {
      break;
    }
    if (count > 0U) {
      buffer[offset++] = ',';
      buffer[offset++] = ' ';
    }
    memcpy(buffer + offset, member->user.name, name_len);
    offset += name_len;
    buffer[offset] = '\0';
    ++count;
  }
  pthread_mutex_unlock(&ctx->owner->room.lock);

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Connected users (%zu):", count);
  session_send_system_line(ctx, header);
  if (count > 0U) {
    session_send_system_line(ctx, buffer);
  }
}

static void session_handle_alpha_centauri_landers(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  alpha_lander_entry_t entries[ALPHA_LANDERS_MAX_RECORDS];
  size_t entry_count = 0U;

  if (!host_alpha_landers_snapshot(ctx->owner, entries, ALPHA_LANDERS_MAX_RECORDS, &entry_count)) {
    session_send_system_line(ctx, "Unable to inspect landing records right now.");
    return;
  }

  session_send_system_line(ctx, "Alpha Centauri Landers — Immigrants' Flag Hall of Fame:");

  if (entry_count == 0U) {
    session_send_system_line(ctx, "No landings logged yet. Finish the expedition to claim the first flag!");
    return;
  }

  qsort(entries, entry_count, sizeof(entries[0]), alpha_lander_entry_compare);

  size_t display_count = entry_count < ALPHA_LANDERS_DISPLAY_LIMIT ? entry_count : ALPHA_LANDERS_DISPLAY_LIMIT;
  for (size_t idx = 0U; idx < display_count; ++idx) {
    const alpha_lander_entry_t *lander = &entries[idx];
    char when[64];
    when[0] = '\0';
    if (lander->last_flag_timestamp != 0U) {
      time_t when_time = (time_t)lander->last_flag_timestamp;
      struct tm tm_buf;
      if (gmtime_r(&when_time, &tm_buf) != NULL) {
        strftime(when, sizeof(when), "%Y-%m-%d %H:%M UTC", &tm_buf);
      }
    }
    if (when[0] == '\0') {
      snprintf(when, sizeof(when), "unknown");
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "#%zu %s — flags planted: %u (last landing %s)", idx + 1U, lander->username,
             lander->flag_count, when);
    session_send_system_line(ctx, line);
  }

  if (entry_count > display_count) {
    size_t remaining = entry_count - display_count;
    char summary[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(summary, sizeof(summary), "…and %zu more landers recorded in the archives.", remaining);
    session_send_system_line(ctx, summary);
  }
}

static bool session_parse_birthday(const char *input, char *normalized, size_t length) {
  if (input == NULL || normalized == NULL || length < 11U) {
    return false;
  }

  char working[32];
  snprintf(working, sizeof(working), "%s", input);
  trim_whitespace_inplace(working);

  if (strlen(working) != 10U || working[4] != '-' || working[7] != '-') {
    return false;
  }

  for (size_t idx = 0U; idx < 10U; ++idx) {
    if (idx == 4U || idx == 7U) {
      continue;
    }
    if (!isdigit((unsigned char)working[idx])) {
      return false;
    }
  }

  int year = atoi(working);
  int month = atoi(working + 5);
  int day = atoi(working + 8);

  if (year < 1900 || year > 9999 || month < 1 || month > 12 || day < 1) {
    return false;
  }

  static const int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  int max_day = days_in_month[month - 1];
  bool leap = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
  if (month == 2 && leap) {
    max_day = 29;
  }
  if (day > max_day) {
    return false;
  }

  char formatted[16];
  int written = snprintf(formatted, sizeof(formatted), "%04d-%02d-%02d", year, month, day);
  if (written <= 0 || written >= (int)sizeof(formatted)) {
    return false;
  }
  if ((size_t)(written + 1) > length) {
    return false;
  }
  snprintf(normalized, length, "%s", formatted);
  return true;
}

static void session_handle_birthday(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /birthday YYYY-MM-DD");
    return;
  }

  char normalized[16];
  if (!session_parse_birthday(arguments, normalized, sizeof(normalized))) {
    session_send_system_line(ctx, "Invalid date. Use /birthday YYYY-MM-DD.");
    return;
  }

  ctx->has_birthday = true;
  snprintf(ctx->birthday, sizeof(ctx->birthday), "%s", normalized);
  host_store_birthday(ctx->owner, ctx, normalized);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Birthday recorded as %s.", normalized);
  session_send_system_line(ctx, message);
}

static void session_handle_soulmate(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->has_birthday) {
    session_send_system_line(ctx, "Set your birthday first with /birthday YYYY-MM-DD.");
    return;
  }

  char matches[SSH_CHATTER_MESSAGE_LIMIT];
  matches[0] = '\0';
  size_t count = 0U;

  pthread_mutex_lock(&ctx->owner->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    const user_preference_t *pref = &ctx->owner->preferences[idx];
    if (!pref->in_use || !pref->has_birthday) {
      continue;
    }
    if (strncmp(pref->birthday, ctx->birthday, sizeof(pref->birthday)) != 0) {
      continue;
    }
    if (strncmp(pref->username, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) {
      continue;
    }
    size_t current_len = strnlen(matches, sizeof(matches));
    size_t name_len = strnlen(pref->username, sizeof(pref->username));
    size_t prefix_len = count == 0U ? 0U : 2U;
    if (current_len + prefix_len + name_len >= sizeof(matches)) {
      continue;
    }
    if (count > 0U) {
      matches[current_len++] = ',';
      matches[current_len++] = ' ';
    }
    memcpy(matches + current_len, pref->username, name_len);
    matches[current_len + name_len] = '\0';
    ++count;
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  if (count == 0U) {
    session_send_system_line(ctx, "No birthday matches found right now.");
    return;
  }

  session_send_system_line(ctx, "Birthday soulmates:");
  session_send_system_line(ctx, matches);
}

static void session_handle_grant(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only LAN operators may grant operator privileges.");
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /grant <ip-address>");
    return;
  }

  char ip[SSH_CHATTER_IP_LEN];
  snprintf(ip, sizeof(ip), "%s", arguments);
  trim_whitespace_inplace(ip);
  if (ip[0] == '\0') {
    session_send_system_line(ctx, "Usage: /grant <ip-address>");
    return;
  }

  unsigned char buf[sizeof(struct in6_addr)];
  if (inet_pton(AF_INET, ip, buf) != 1 && inet_pton(AF_INET6, ip, buf) != 1) {
    session_send_system_line(ctx, "Provide a valid IPv4 or IPv6 address.");
    return;
  }

  bool already_granted = false;
  bool added = false;
  pthread_mutex_lock(&ctx->owner->lock);
  already_granted = host_ip_has_grant_locked(ctx->owner, ip);
  if (!already_granted) {
    added = host_add_operator_grant_locked(ctx->owner, ip);
    if (added) {
      host_state_save_locked(ctx->owner);
    }
  } else {
    added = true;
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  if (!added) {
    session_send_system_line(ctx, "Cannot store more grants right now.");
    return;
  }

  if (already_granted) {
    session_send_system_line(ctx, "That IP already has operator privileges.");
  } else {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Operator privileges will be applied to %s.", ip);
    session_send_system_line(ctx, message);
  }
  host_apply_grant_to_ip(ctx->owner, ip);
}

static void session_handle_revoke(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only LAN administrators may revoke operator privileges.");
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /revoke <ip-address>");
    return;
  }

  char ip[SSH_CHATTER_IP_LEN];
  snprintf(ip, sizeof(ip), "%s", arguments);
  trim_whitespace_inplace(ip);
  if (ip[0] == '\0') {
    session_send_system_line(ctx, "Usage: /revoke <ip-address>");
    return;
  }

  unsigned char buf[sizeof(struct in6_addr)];
  if (inet_pton(AF_INET, ip, buf) != 1 && inet_pton(AF_INET6, ip, buf) != 1) {
    session_send_system_line(ctx, "Provide a valid IPv4 or IPv6 address.");
    return;
  }

  bool removed = false;
  pthread_mutex_lock(&ctx->owner->lock);
  removed = host_remove_operator_grant_locked(ctx->owner, ip);
  if (removed) {
    host_state_save_locked(ctx->owner);
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  if (!removed) {
    session_send_system_line(ctx, "No stored grant exists for that IP address.");
    return;
  }

  host_revoke_grant_from_ip(ctx->owner, ip);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Operator privileges revoked for %s.", ip);
  session_send_system_line(ctx, message);
}

static void session_handle_delete_message(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may delete messages.");
    return;
  }

  static const char *kUsage = "Usage: /delete-msg <id|start-end>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/delete-msg", kUsage, usage, sizeof(usage));
  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  uint64_t start_id = 0U;
  uint64_t end_id = 0U;
  char *dash = strchr(working, '-');
  if (dash != NULL) {
    *dash = '\0';
    char *end_token = dash + 1;
    trim_whitespace_inplace(working);
    trim_whitespace_inplace(end_token);
    if (working[0] == '\0' || end_token[0] == '\0') {
      session_send_system_line(ctx, usage);
      return;
    }

    char *endptr = NULL;
    errno = 0;
    unsigned long long start_value = strtoull(working, &endptr, 10);
    if (errno != 0 || endptr == NULL || *endptr != '\0' || start_value == 0ULL) {
      session_send_system_line(ctx, usage);
      return;
    }

    errno = 0;
    unsigned long long end_value = strtoull(end_token, &endptr, 10);
    if (errno != 0 || endptr == NULL || *endptr != '\0' || end_value == 0ULL) {
      session_send_system_line(ctx, usage);
      return;
    }

    start_id = (uint64_t)start_value;
    end_id = (uint64_t)end_value;
    if (start_id > end_id) {
      session_send_system_line(ctx, "Start identifier must be less than or equal to the end identifier.");
      return;
    }
  } else {
    char *endptr = NULL;
    errno = 0;
    unsigned long long value = strtoull(working, &endptr, 10);
    if (errno != 0 || endptr == NULL || *endptr != '\0' || value == 0ULL) {
      session_send_system_line(ctx, usage);
      return;
    }
    start_id = (uint64_t)value;
    end_id = start_id;
  }

  uint64_t first_removed = 0U;
  uint64_t last_removed = 0U;
  size_t replies_removed = 0U;
  size_t removed = host_history_delete_range(ctx->owner, start_id, end_id, &first_removed, &last_removed, &replies_removed);
  if (removed == 0U) {
    session_send_system_line(ctx, "No chat messages matched that identifier.");
    return;
  }

  char range_label[64];
  if (last_removed != 0U && last_removed != first_removed) {
    snprintf(range_label, sizeof(range_label), "#%" PRIu64 "-#%" PRIu64, first_removed, last_removed);
  } else {
    snprintf(range_label, sizeof(range_label), "#%" PRIu64, first_removed);
  }

  char reply_note[64];
  if (replies_removed > 0U) {
    snprintf(reply_note, sizeof(reply_note), " (%zu repl%s removed)", replies_removed, replies_removed == 1U ? "y" : "ies");
  } else {
    reply_note[0] = '\0';
  }

  char acknowledgement[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(acknowledgement, sizeof(acknowledgement), "Removed %zu message%s (%s)%s.", removed,
           removed == 1U ? "" : "s", range_label, reply_note);
  session_send_system_line(ctx, acknowledgement);

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* [%s] removed %s %s%s.", ctx->user.name, removed == 1U ? "message" : "messages",
           range_label, reply_note);
  host_history_record_system(ctx->owner, notice);
  chat_room_broadcast(&ctx->owner->room, notice, NULL);
}

static void session_handle_poll(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage =
      "Usage: /poll <question>|<option1>|<option2>[|option3][|option4][|option5] or /poll to view current poll";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/poll", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_poll_summary(ctx);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_send_poll_summary(ctx);
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may modify the main poll.");
    return;
  }

  char *tokens[1 + 5];
  size_t token_count = 0U;
  char *cursor = working;
  while (cursor != NULL && token_count < sizeof(tokens) / sizeof(tokens[0])) {
    char *next = strchr(cursor, '|');
    if (next != NULL) {
      *next = '\0';
    }
    trim_whitespace_inplace(cursor);
    tokens[token_count++] = cursor;
    cursor = next != NULL ? next + 1 : NULL;
  }

  if (token_count < 3U) {
    session_send_system_line(ctx, usage);
    return;
  }

  size_t option_count = token_count - 1U;
  if (option_count > 5U) {
    option_count = 5U;
  }

  for (size_t idx = 1U; idx <= option_count; ++idx) {
    if (tokens[idx][0] == '\0') {
      session_send_system_line(ctx, "Poll options cannot be empty.");
      return;
    }
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  if (host->poll.id == UINT64_MAX) {
    host->poll.id = 0U;
  }
  host->poll.id += 1U;
  host->poll.active = true;
  host->poll.option_count = option_count;
  host->poll.allow_multiple = false;
  snprintf(host->poll.question, sizeof(host->poll.question), "%s", tokens[0]);
  for (size_t idx = 0U; idx < option_count; ++idx) {
    snprintf(host->poll.options[idx].text, sizeof(host->poll.options[idx].text), "%s", tokens[idx + 1U]);
    host->poll.options[idx].votes = 0U;
  }
  for (size_t idx = option_count; idx < sizeof(host->poll.options) / sizeof(host->poll.options[0]); ++idx) {
    host->poll.options[idx].text[0] = '\0';
    host->poll.options[idx].votes = 0U;
  }
  host_vote_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  char announce[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(announce, sizeof(announce), "* [%s] started poll #%" PRIu64 ": %s", ctx->user.name, host->poll.id, tokens[0]);
  chat_room_broadcast(&host->room, announce, NULL);

  for (size_t idx = 0U; idx < option_count; ++idx) {
    char option_line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(option_line, sizeof(option_line), "  /%zu - %s", idx + 1U, tokens[idx + 1U]);
    chat_room_broadcast(&host->room, option_line, NULL);
  }

  session_send_system_line(ctx, "Poll created successfully.");
  session_send_poll_summary(ctx);
}

static void session_handle_vote(session_ctx_t *ctx, size_t option_index) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  if (!host->poll.active || option_index >= host->poll.option_count) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "There is no active poll for that choice.");
    return;
  }

  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref == NULL) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "Unable to record your vote right now.");
    return;
  }

  if (pref->last_poll_id == host->poll.id && pref->last_poll_choice == (int)option_index) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "You have already voted for that option.");
    return;
  }

  if (pref->last_poll_id == host->poll.id && pref->last_poll_choice >= 0 &&
      (size_t)pref->last_poll_choice < host->poll.option_count) {
    if (host->poll.options[pref->last_poll_choice].votes > 0U) {
      host->poll.options[pref->last_poll_choice].votes -= 1U;
    }
  }

  host->poll.options[option_index].votes += 1U;
  pref->last_poll_id = host->poll.id;
  pref->last_poll_choice = (int)option_index;
  host_vote_state_save_locked(host);
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Vote recorded for option /%zu.", option_index + 1U);
  session_send_system_line(ctx, message);
  session_send_poll_summary(ctx);
}

// Record a vote in a named poll, ensuring a user can move their vote between options.
static void session_handle_named_vote(session_ctx_t *ctx, size_t option_index, const char *label) {
  if (ctx == NULL || ctx->owner == NULL || label == NULL || label[0] == '\0') {
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  named_poll_state_t *poll = host_find_named_poll_locked(host, label);
  if (poll == NULL || !poll->poll.active || option_index >= poll->poll.option_count) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "There is no active poll with that label.");
    return;
  }

  const bool allow_multiple = poll->poll.allow_multiple;
  const uint32_t option_bit = (option_index < 32U) ? (1U << option_index) : 0U;

  size_t voter_slot = SIZE_MAX;
  for (size_t idx = 0U; idx < poll->voter_count; ++idx) {
    if (poll->voters[idx].username[0] == '\0') {
      continue;
    }
    if (strcasecmp(poll->voters[idx].username, ctx->user.name) == 0) {
      voter_slot = idx;
      break;
    }
  }

  if (voter_slot == SIZE_MAX) {
    if (poll->voter_count >= SSH_CHATTER_MAX_NAMED_VOTERS) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "Vote tracking is full for this poll right now.");
      return;
    }
    voter_slot = poll->voter_count++;
    snprintf(poll->voters[voter_slot].username, sizeof(poll->voters[voter_slot].username), "%s", ctx->user.name);
    poll->voters[voter_slot].choice = -1;
    poll->voters[voter_slot].choices_mask = 0U;
  }

  uint32_t *mask = &poll->voters[voter_slot].choices_mask;
  if (allow_multiple) {
    if (option_bit != 0U && (*mask & option_bit) != 0U) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "You have already voted for that option.");
      return;
    }
  } else {
    if (poll->voters[voter_slot].choice == (int)option_index) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "You have already voted for that option.");
      return;
    }
    if (poll->voters[voter_slot].choice >= 0) {
      int previous = poll->voters[voter_slot].choice;
      if (previous >= 0 && (size_t)previous < poll->poll.option_count && poll->poll.options[previous].votes > 0U) {
        poll->poll.options[previous].votes -= 1U;
      }
    }
  }

  poll->poll.options[option_index].votes += 1U;
  if (allow_multiple) {
    if (option_bit != 0U) {
      *mask |= option_bit;
    }
    poll->voters[voter_slot].choice = -1;
  } else {
    poll->voters[voter_slot].choice = (int)option_index;
    poll->voters[voter_slot].choices_mask = (option_bit != 0U) ? option_bit : 0U;
  }

  char resolved_label[SSH_CHATTER_POLL_LABEL_LEN];
  snprintf(resolved_label, sizeof(resolved_label), "%s", poll->label);
  host_vote_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Vote recorded for /%zu %s.", option_index + 1U, resolved_label);
  session_send_system_line(ctx, message);
  session_send_poll_summary_generic(ctx, &poll->poll, resolved_label);
}

// Allow voting in a named poll by specifying the label and desired choice directly.
static void session_handle_elect_command(session_ctx_t *ctx, const char *arguments) {
  static const char *kUsage = "Usage: /elect <label> <choice>";
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/elect", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *label = working;
  char *choice = working;
  while (*choice != '\0' && !isspace((unsigned char)*choice)) {
    ++choice;
  }
  if (*choice != '\0') {
    *choice++ = '\0';
  }
  while (*choice == ' ' || *choice == '\t') {
    ++choice;
  }

  if (label[0] == '\0' || *choice == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  trim_whitespace_inplace(choice);

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  named_poll_state_t *poll = host_find_named_poll_locked(host, label);
  if (poll == NULL || !poll->poll.active) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "There is no active poll with that label.");
    return;
  }

  char canonical_label[SSH_CHATTER_POLL_LABEL_LEN];
  snprintf(canonical_label, sizeof(canonical_label), "%s", poll->label);

  size_t option_index = SIZE_MAX;
  const size_t option_count = poll->poll.option_count;

  const char *numeric_start = choice;
  if (*numeric_start == '/') {
    ++numeric_start;
  }
  if (*numeric_start != '\0') {
    char *endptr = NULL;
    unsigned long parsed = strtoul(numeric_start, &endptr, 10);
    if (endptr != NULL && endptr != numeric_start && *endptr == '\0' && parsed >= 1UL && parsed <= option_count) {
      option_index = (size_t)(parsed - 1UL);
    }
  }

  if (option_index == SIZE_MAX) {
    for (size_t idx = 0U; idx < option_count; ++idx) {
      if (poll->poll.options[idx].text[0] == '\0') {
        continue;
      }
      if (strcasecmp(poll->poll.options[idx].text, choice) == 0) {
        option_index = idx;
        break;
      }
    }
  }

  pthread_mutex_unlock(&host->lock);

  if (option_index == SIZE_MAX) {
    session_send_system_line(ctx, "That choice is not available in this poll.");
    return;
  }

  session_handle_named_vote(ctx, option_index, canonical_label);
}

// Parse the /vote command to manage named polls, including listing, creation, and closure.
static void session_handle_vote_command(session_ctx_t *ctx, const char *arguments, bool allow_multiple) {
  const char *usage_template = allow_multiple
                                   ? "Usage: /vote <label> <question>|<option1>|<option2>[|option3][|option4][|option5]"
                                   : "Usage: /vote-single <label> <question>|<option1>|<option2>[|option3][|option4][|option5]";
  const char *canonical = allow_multiple ? "/vote" : "/vote-single";
  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, canonical, usage_template, usage, sizeof(usage));
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (arguments == NULL) {
    session_list_named_polls(ctx);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_list_named_polls(ctx);
    return;
  }

  const char *close_command = NULL;
  if (strncmp(working, "@close", 6) == 0 && (working[6] == '\0' || isspace((unsigned char)working[6]))) {
    close_command = "@close";
  } else if (strncmp(working, "@종료", 7) == 0 && (working[7] == '\0' || isspace((unsigned char)working[7]))) {
    close_command = "@종료";
  }

  if (close_command != NULL) {
    const char *label_start = working + strlen(close_command);
    while (*label_start != '\0' && isspace((unsigned char)*label_start)) {
      ++label_start;
    }
    if (*label_start == '\0') {
      session_send_system_line(ctx, "Usage: /vote @close <label>");
      return;
    }

    char label[SSH_CHATTER_POLL_LABEL_LEN];
    size_t close_len = 0U;
    while (label_start[close_len] != '\0' && !isspace((unsigned char)label_start[close_len])) {
      if (close_len + 1U >= sizeof(label)) {
        session_send_system_line(ctx, "Poll label is too long.");
        return;
      }
      label[close_len] = label_start[close_len];
      ++close_len;
    }
    label[close_len] = '\0';
    if (!poll_label_is_valid(label)) {
      session_send_system_line(ctx, "Poll labels may contain only letters, numbers, hyphens, or underscores.");
      return;
    }

    host_t *host = ctx->owner;
    pthread_mutex_lock(&host->lock);
    named_poll_state_t *poll = host_find_named_poll_locked(host, label);
    if (poll == NULL || !poll->poll.active) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "That poll is not currently active.");
      return;
    }

    bool has_privilege = ctx->user.is_operator || ctx->user.is_lan_operator ||
                         (poll->owner[0] != '\0' && strcasecmp(poll->owner, ctx->user.name) == 0);
    if (!has_privilege) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "Only the poll owner or an operator may close this poll.");
      return;
    }

    poll_state_reset(&poll->poll);
    poll->voter_count = 0U;
    host_recount_named_polls_locked(host);
    host_vote_state_save_locked(host);
    pthread_mutex_unlock(&host->lock);

    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "* [%s] closed poll [%s].", ctx->user.name, label);
    chat_room_broadcast(&host->room, message, NULL);
    session_send_system_line(ctx, "Poll closed.");
    return;
  }

  char label[SSH_CHATTER_POLL_LABEL_LEN];
  size_t label_len = 0U;
  const char *cursor = working;
  while (*cursor != '\0' && !isspace((unsigned char)*cursor)) {
    if (label_len + 1U >= sizeof(label)) {
      session_send_system_line(ctx, "Poll label is too long.");
      return;
    }
    label[label_len++] = *cursor++;
  }
  label[label_len] = '\0';
  if (!poll_label_is_valid(label)) {
    session_send_system_line(ctx, "Poll labels may contain only letters, numbers, hyphens, or underscores.");
    return;
  }

  while (*cursor != '\0' && isspace((unsigned char)*cursor)) {
    ++cursor;
  }

  if (*cursor == '\0') {
    host_t *host = ctx->owner;
    pthread_mutex_lock(&host->lock);
    named_poll_state_t *poll = host_find_named_poll_locked(host, label);
    named_poll_state_t snapshot = {0};
    if (poll != NULL) {
      snapshot = *poll;
    }
    pthread_mutex_unlock(&host->lock);

    if (poll == NULL) {
      session_send_system_line(ctx, "No poll exists with that label.");
      return;
    }

    session_send_poll_summary_generic(ctx, &snapshot.poll, snapshot.label);
    return;
  }

  char definition[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(definition, sizeof(definition), "%s", cursor);
  trim_whitespace_inplace(definition);
  if (definition[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *tokens[1 + 5];
  size_t token_count = 0U;
  char *token_cursor = definition;
  while (token_cursor != NULL && token_count < sizeof(tokens) / sizeof(tokens[0])) {
    char *next = strchr(token_cursor, '|');
    if (next != NULL) {
      *next = '\0';
    }
    trim_whitespace_inplace(token_cursor);
    tokens[token_count++] = token_cursor;
    token_cursor = next != NULL ? next + 1 : NULL;
  }

  if (token_count < 3U) {
    session_send_system_line(ctx, "Provide at least a question and two options.");
    return;
  }

  size_t option_count = token_count - 1U;
  if (option_count > 5U) {
    option_count = 5U;
  }

  for (size_t idx = 1U; idx <= option_count; ++idx) {
    if (tokens[idx][0] == '\0') {
      session_send_system_line(ctx, "Poll options cannot be empty.");
      return;
    }
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  named_poll_state_t *poll = host_ensure_named_poll_locked(host, label);
  if (poll == NULL) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "Too many named polls are already registered.");
    return;
  }

  if (poll->poll.active && poll->owner[0] != '\0' && strcasecmp(poll->owner, ctx->user.name) != 0 &&
      !ctx->user.is_operator && !ctx->user.is_lan_operator) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "Only the poll owner or an operator may restart this poll.");
    return;
  }

  if (poll->poll.id == UINT64_MAX) {
    poll->poll.id = 0U;
  }
  poll->poll.id += 1U;
  poll->poll.active = true;
  poll->poll.option_count = option_count;
  poll->poll.allow_multiple = allow_multiple;
  snprintf(poll->poll.question, sizeof(poll->poll.question), "%s", tokens[0]);
  for (size_t idx = 0U; idx < option_count; ++idx) {
    snprintf(poll->poll.options[idx].text, sizeof(poll->poll.options[idx].text), "%s", tokens[idx + 1U]);
    poll->poll.options[idx].votes = 0U;
  }
  for (size_t idx = option_count; idx < sizeof(poll->poll.options) / sizeof(poll->poll.options[0]); ++idx) {
    poll->poll.options[idx].text[0] = '\0';
    poll->poll.options[idx].votes = 0U;
  }
  snprintf(poll->owner, sizeof(poll->owner), "%s", ctx->user.name);
  poll->voter_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_VOTERS; ++idx) {
    poll->voters[idx].username[0] = '\0';
    poll->voters[idx].choice = -1;
    poll->voters[idx].choices_mask = 0U;
  }
  host_recount_named_polls_locked(host);
  named_poll_state_t snapshot = *poll;
  host_vote_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  char announce[SSH_CHATTER_MESSAGE_LIMIT];
  int question_preview = (int)strnlen(snapshot.poll.question, sizeof(snapshot.poll.question));
  if (question_preview > 120) {
    question_preview = 120;
  }
  snprintf(announce, sizeof(announce), "* [%s] started poll [%s] #%" PRIu64 ": %.*s", ctx->user.name, label, snapshot.poll.id,
           question_preview, snapshot.poll.question);
  chat_room_broadcast(&host->room, announce, NULL);

  for (size_t idx = 0U; idx < snapshot.poll.option_count; ++idx) {
    char option_line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(option_line, sizeof(option_line), "  /%zu %s - %s", idx + 1U, label, snapshot.poll.options[idx].text);
    chat_room_broadcast(&host->room, option_line, NULL);
  }

  session_send_system_line(ctx, "Named poll created successfully.");
  session_send_poll_summary_generic(ctx, &snapshot.poll, snapshot.label);
}

// Format a timestamp for BBS displays in a compact form.
static void bbs_format_time(time_t value, char *buffer, size_t length) {
  if (buffer == NULL || length == 0U) {
    return;
  }
  struct tm tm_value;
  if (localtime_r(&value, &tm_value) == NULL) {
    snprintf(buffer, length, "-");
    return;
  }
  strftime(buffer, length, "%Y-%m-%d %H:%M", &tm_value);
}

// Return a post by identifier while the host lock is held.
static bbs_post_t *host_find_bbs_post_locked(host_t *host, uint64_t id) {
  if (host == NULL || id == 0U) {
    return NULL;
  }
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (!host->bbs_posts[idx].in_use) {
      continue;
    }
    if (host->bbs_posts[idx].id == id) {
      return &host->bbs_posts[idx];
    }
  }
  return NULL;
}

// Allocate a new post slot, returning NULL if capacity has been reached.
static bbs_post_t *host_allocate_bbs_post_locked(host_t *host) {
  if (host == NULL) {
    return NULL;
  }
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (host->bbs_posts[idx].in_use) {
      continue;
    }
    bbs_post_t *post = &host->bbs_posts[idx];
    post->in_use = true;
    post->id = host->next_bbs_id++;
    post->tag_count = 0U;
    post->comment_count = 0U;
    post->created_at = time(NULL);
    post->bumped_at = post->created_at;
    post->title[0] = '\0';
    post->body[0] = '\0';
    post->author[0] = '\0';
    for (size_t tag = 0U; tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
      post->tags[tag][0] = '\0';
    }
    for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
      post->comments[comment].author[0] = '\0';
      post->comments[comment].text[0] = '\0';
      post->comments[comment].created_at = 0;
    }
    if (host->bbs_post_count < SSH_CHATTER_BBS_MAX_POSTS) {
      host->bbs_post_count += 1U;
    }
    return post;
  }
  return NULL;
}

static void host_reset_bbs_post(bbs_post_t *post) {
  if (post == NULL) {
    return;
  }

  post->in_use = false;
  post->id = 0U;
  post->author[0] = '\0';
  post->title[0] = '\0';
  post->body[0] = '\0';
  post->tag_count = 0U;
  post->created_at = 0;
  post->bumped_at = 0;
  post->comment_count = 0U;
  for (size_t tag = 0U; tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
    post->tags[tag][0] = '\0';
  }
  for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
    post->comments[comment].author[0] = '\0';
    post->comments[comment].text[0] = '\0';
    post->comments[comment].created_at = 0;
  }
}

static void host_clear_bbs_post_locked(host_t *host, bbs_post_t *post) {
  if (host == NULL || post == NULL) {
    return;
  }

  host_reset_bbs_post(post);

  size_t write_index = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    if (!host->bbs_posts[idx].in_use) {
      continue;
    }

    if (write_index != idx) {
      host->bbs_posts[write_index] = host->bbs_posts[idx];
    }

    ++write_index;
  }

  for (size_t idx = write_index; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    host_reset_bbs_post(&host->bbs_posts[idx]);
  }

  host->bbs_post_count = write_index;
}

static void session_bbs_queue_translation(session_ctx_t *ctx, const bbs_post_t *post) {
  if (ctx == NULL || post == NULL || !post->in_use) {
    return;
  }

  if (!ctx->translation_enabled || !ctx->output_translation_enabled ||
      ctx->output_translation_language[0] == '\0') {
    return;
  }

  char payload[SSH_CHATTER_TRANSLATION_WORKING_LEN];
  size_t offset = 0U;

  offset = session_append_fragment(payload, sizeof(payload), offset, "Title: ");
  offset = session_append_fragment(payload, sizeof(payload), offset, post->title);
  offset = session_append_fragment(payload, sizeof(payload), offset, "\nAuthor: ");
  offset = session_append_fragment(payload, sizeof(payload), offset, post->author);

  char created_buffer[32];
  char bumped_buffer[32];
  bbs_format_time(post->created_at, created_buffer, sizeof(created_buffer));
  bbs_format_time(post->bumped_at, bumped_buffer, sizeof(bumped_buffer));
  offset = session_append_fragment(payload, sizeof(payload), offset, "\nCreated: ");
  offset = session_append_fragment(payload, sizeof(payload), offset, created_buffer);
  offset = session_append_fragment(payload, sizeof(payload), offset, " (bumped ");
  offset = session_append_fragment(payload, sizeof(payload), offset, bumped_buffer);
  offset = session_append_fragment(payload, sizeof(payload), offset, ")\n");

  if (post->tag_count > 0U) {
    offset = session_append_fragment(payload, sizeof(payload), offset, "Tags: ");
    for (size_t idx = 0U; idx < post->tag_count; ++idx) {
      if (idx > 0U) {
        offset = session_append_fragment(payload, sizeof(payload), offset, ",");
      }
      offset = session_append_fragment(payload, sizeof(payload), offset, post->tags[idx]);
    }
  } else {
    offset = session_append_fragment(payload, sizeof(payload), offset, "Tags: (none)");
  }

  offset = session_append_fragment(payload, sizeof(payload), offset, "\nBody:\n");
  if (post->body[0] != '\0') {
    offset = session_append_fragment(payload, sizeof(payload), offset, post->body);
  } else {
    offset = session_append_fragment(payload, sizeof(payload), offset, "(empty)");
  }

  if (post->comment_count > 0U) {
    offset = session_append_fragment(payload, sizeof(payload), offset, "\nComments:\n");
    for (size_t idx = 0U; idx < post->comment_count; ++idx) {
      const bbs_comment_t *comment = &post->comments[idx];
      offset = session_append_fragment(payload, sizeof(payload), offset, comment->author);
      offset = session_append_fragment(payload, sizeof(payload), offset, ": ");
      offset = session_append_fragment(payload, sizeof(payload), offset, comment->text);
      offset = session_append_fragment(payload, sizeof(payload), offset, "\n");
    }
  } else {
    offset = session_append_fragment(payload, sizeof(payload), offset, "\nComments: none");
  }

  payload[offset < sizeof(payload) ? offset : sizeof(payload) - 1U] = '\0';

  if (payload[0] == '\0') {
    return;
  }

  if (session_translation_queue_caption(ctx, payload, 0U)) {
    session_translation_flush_ready(ctx);
  }
}

// Render an ASCII framed view of a post, including metadata and comments.
static void session_bbs_emit_line_if_visible(session_ctx_t *ctx, const char *line, bool column_reset,
                                             size_t offset, size_t window, bool emit, size_t *line_index) {
  if (line_index == NULL) {
    return;
  }

  const char *text = (line != NULL) ? line : "";
  (void)column_reset;

  if (!emit) {
    ++(*line_index);
    return;
  }

  size_t start = offset;
  size_t end = (window == 0U || offset > SIZE_MAX - window) ? SIZE_MAX : offset + window;
  if (*line_index >= start && *line_index < end) {
    if (host_contains_column_reset(text)) {
      char sanitized[SSH_CHATTER_MESSAGE_LIMIT];
      sanitized[0] = '\0';
      snprintf(sanitized, sizeof(sanitized), "%s", text);
      host_strip_column_reset(sanitized);
      session_send_system_line(ctx, sanitized);
    } else {
      session_send_system_line(ctx, text);
    }
  }

  ++(*line_index);
}

static size_t session_bbs_render_post_iterate(session_ctx_t *ctx, const bbs_post_t *post, const char *notice,
                                              size_t offset, size_t window, bool emit) {
  size_t line_index = 0U;

  char header_label[64];
  snprintf(header_label, sizeof(header_label), "BBS Post #%" PRIu64, post->id);
  char separator_line[SSH_CHATTER_MESSAGE_LIMIT];
  session_format_separator_line(ctx, header_label, separator_line, sizeof(separator_line));
  session_bbs_emit_line_if_visible(ctx, separator_line, false, offset, window, emit, &line_index);

  if (notice != NULL && notice[0] != '\0') {
    session_bbs_emit_line_if_visible(ctx, notice, false, offset, window, emit, &line_index);
    session_bbs_emit_line_if_visible(ctx, "", false, offset, window, emit, &line_index);
  }

  char created_buffer[32];
  char bumped_buffer[32];
  bbs_format_time(post->created_at, created_buffer, sizeof(created_buffer));
  bbs_format_time(post->bumped_at, bumped_buffer, sizeof(bumped_buffer));

  char metadata[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(metadata, sizeof(metadata), "Title : %s", post->title);
  session_bbs_emit_line_if_visible(ctx, metadata, false, offset, window, emit, &line_index);
  snprintf(metadata, sizeof(metadata), "Author: %s", post->author);
  session_bbs_emit_line_if_visible(ctx, metadata, false, offset, window, emit, &line_index);
  snprintf(metadata, sizeof(metadata), "Created: %s (bumped %s)", created_buffer, bumped_buffer);
  session_bbs_emit_line_if_visible(ctx, metadata, false, offset, window, emit, &line_index);

  if (post->tag_count > 0U) {
    char tag_line[SSH_CHATTER_MESSAGE_LIMIT];
    int header_written = snprintf(tag_line, sizeof(tag_line), "Tags  : ");
    size_t tag_offset = header_written > 0 ? (size_t)header_written : 0U;
    if (tag_offset >= sizeof(tag_line)) {
      tag_offset = sizeof(tag_line) - 1U;
    }
    for (size_t idx = 0U; idx < post->tag_count; ++idx) {
      size_t tag_len = strlen(post->tags[idx]);
      if (tag_offset + tag_len + 2U >= sizeof(tag_line)) {
        break;
      }
      if (idx > 0U) {
        tag_line[tag_offset++] = ',';
      }
      memcpy(tag_line + tag_offset, post->tags[idx], tag_len);
      tag_offset += tag_len;
      tag_line[tag_offset] = '\0';
    }
    session_bbs_emit_line_if_visible(ctx, tag_line, false, offset, window, emit, &line_index);
  } else {
    session_bbs_emit_line_if_visible(ctx, "Tags  : (none)", false, offset, window, emit, &line_index);
  }

  if (ctx != NULL && ctx->owner != NULL) {
    user_data_record_t author_record;
    if (host_user_data_find_profile_picture(ctx->owner, post->author, &author_record)) {
      session_format_separator_line(ctx, "Profile Picture", separator_line, sizeof(separator_line));
      session_bbs_emit_line_if_visible(ctx, separator_line, false, offset, window, emit, &line_index);

      const char *picture_cursor = author_record.profile_picture;
      while (picture_cursor != NULL && *picture_cursor != '\0') {
        const char *newline = strchr(picture_cursor, '\n');
        if (newline == NULL) {
          session_bbs_emit_line_if_visible(ctx, picture_cursor, true, offset, window, emit, &line_index);
          break;
        }

        size_t len = (size_t)(newline - picture_cursor);
        if (len >= SSH_CHATTER_MESSAGE_LIMIT) {
          len = SSH_CHATTER_MESSAGE_LIMIT - 1U;
        }

        char line[SSH_CHATTER_MESSAGE_LIMIT];
        memcpy(line, picture_cursor, len);
        line[len] = '\0';
        session_bbs_emit_line_if_visible(ctx, line, true, offset, window, emit, &line_index);
        picture_cursor = newline + 1;
      }

      session_bbs_emit_line_if_visible(ctx, "", false, offset, window, emit, &line_index);
    }
  }

  session_format_separator_line(ctx, "Body", separator_line, sizeof(separator_line));
  session_bbs_emit_line_if_visible(ctx, separator_line, false, offset, window, emit, &line_index);

  if (post->body[0] != '\0') {
    const char *body_cursor = post->body;
    while (body_cursor != NULL && *body_cursor != '\0') {
      const char *newline = strchr(body_cursor, '\n');
      if (newline == NULL) {
        session_bbs_emit_line_if_visible(ctx, body_cursor, true, offset, window, emit, &line_index);
        break;
      }
      size_t len = (size_t)(newline - body_cursor);
      if (len >= SSH_CHATTER_MESSAGE_LIMIT) {
        len = SSH_CHATTER_MESSAGE_LIMIT - 1U;
      }
      char line[SSH_CHATTER_MESSAGE_LIMIT];
      memcpy(line, body_cursor, len);
      line[len] = '\0';
      session_bbs_emit_line_if_visible(ctx, line, true, offset, window, emit, &line_index);
      body_cursor = newline + 1;
    }
  } else {
    session_bbs_emit_line_if_visible(ctx, "(empty)", false, offset, window, emit, &line_index);
  }

  session_format_separator_line(ctx, "Comments", separator_line, sizeof(separator_line));
  session_bbs_emit_line_if_visible(ctx, separator_line, false, offset, window, emit, &line_index);

  if (post->comment_count == 0U) {
    session_bbs_emit_line_if_visible(ctx, "No comments yet.", false, offset, window, emit, &line_index);
  } else {
    for (size_t idx = 0U; idx < post->comment_count; ++idx) {
      const bbs_comment_t *comment = &post->comments[idx];
      char comment_time[32];
      bbs_format_time(comment->created_at, comment_time, sizeof(comment_time));
      char line[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(line, sizeof(line), "[%zu] %s (%s)", idx + 1U, comment->author, comment_time);
      session_bbs_emit_line_if_visible(ctx, line, false, offset, window, emit, &line_index);
      session_bbs_emit_line_if_visible(ctx, comment->text, true, offset, window, emit, &line_index);
    }
  }

  const bool translation_active = ctx->translation_enabled && ctx->output_translation_enabled &&
                                  ctx->output_translation_language[0] != '\0';
  if (translation_active && post->comment_count > 0U) {
    session_bbs_emit_line_if_visible(ctx, "", false, offset, window, emit, &line_index);
  }

  session_bbs_emit_line_if_visible(ctx, "", false, offset, window, emit, &line_index);
  session_format_separator_line(ctx, "Write a comment", separator_line, sizeof(separator_line));
  session_bbs_emit_line_if_visible(ctx, separator_line, false, offset, window, emit, &line_index);

  char reply_instruction[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(reply_instruction, sizeof(reply_instruction),
           "Reply with /bbs comment %" PRIu64 "|<message> (or /bbs exit to leave this view).", post->id);
  session_bbs_emit_line_if_visible(ctx, reply_instruction, false, offset, window, emit, &line_index);
  bool can_edit = (strncmp(post->author, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) || ctx->user.is_operator ||
                  ctx->user.is_lan_operator;
  if (can_edit) {
    char edit_instruction[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(edit_instruction, sizeof(edit_instruction), "Edit this post with /bbs edit %" PRIu64 ".", post->id);
    session_bbs_emit_line_if_visible(ctx, edit_instruction, false, offset, window, emit, &line_index);
  }
  session_bbs_emit_line_if_visible(ctx, "Need a new thread? Use /bbs post <title>[|tags...] instead.", false, offset,
                                   window, emit, &line_index);
  session_bbs_emit_line_if_visible(ctx, "Use Up/Down arrows or PgUp/PgDn to scroll this post.", false, offset, window,
                                   emit, &line_index);

  return line_index;
}

static void session_bbs_render_post(session_ctx_t *ctx, const bbs_post_t *post, const char *notice,
                                    bool reset_scroll, bool scroll_to_bottom) {
  if (ctx == NULL || post == NULL || !post->in_use) {
    return;
  }

  bool previous_override = session_translation_push_scope_override(ctx);

  bool same_post = ctx->bbs_view_active && ctx->bbs_view_post_id == post->id;
  if (!same_post || reset_scroll) {
    ctx->bbs_view_scroll_offset = 0U;
  }

  ctx->bbs_view_active = true;
  ctx->bbs_view_post_id = post->id;

  if (notice != NULL && notice[0] != '\0') {
    snprintf(ctx->bbs_view_notice, sizeof(ctx->bbs_view_notice), "%s", notice);
    ctx->bbs_view_notice_pending = true;
  }

  const char *active_notice = ctx->bbs_view_notice_pending ? ctx->bbs_view_notice : NULL;

  size_t window = SSH_CHATTER_BBS_VIEW_WINDOW;
  if (window == 0U) {
    window = 1U;
  }

  size_t total_lines = session_bbs_render_post_iterate(ctx, post, active_notice, 0U, window, false);
  if (total_lines == 0U) {
    total_lines = 1U;
  }
  ctx->bbs_view_total_lines = total_lines;

  size_t max_offset = (total_lines > window) ? (total_lines - window) : 0U;
  size_t desired_offset = ctx->bbs_view_scroll_offset;
  if (scroll_to_bottom) {
    desired_offset = max_offset;
  }
  if (desired_offset > max_offset) {
    desired_offset = max_offset;
  }
  ctx->bbs_view_scroll_offset = desired_offset;

  session_bbs_prepare_canvas(ctx);
  session_bbs_render_post_iterate(ctx, post, active_notice, desired_offset, window, true);
  ctx->bbs_view_notice_pending = false;

  session_bbs_queue_translation(ctx, post);
  session_translation_pop_scope_override(ctx, previous_override);
}

static bool session_bbs_refresh_view(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL || !ctx->bbs_view_active || ctx->bbs_view_post_id == 0U) {
    return false;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, ctx->bbs_view_post_id);
  bbs_post_t snapshot = {0};
  if (post != NULL) {
    snapshot = *post;
  }
  pthread_mutex_unlock(&host->lock);

  if (post == NULL || !snapshot.in_use) {
    ctx->bbs_view_active = false;
    ctx->bbs_view_post_id = 0U;
    ctx->bbs_view_total_lines = 0U;
    ctx->bbs_view_scroll_offset = 0U;
    session_send_system_line(ctx, "That post is no longer available.");
    return false;
  }

  session_bbs_render_post(ctx, &snapshot, NULL, false, false);
  return true;
}

static bool session_bbs_scroll(session_ctx_t *ctx, int direction, size_t step) {
  if (ctx == NULL || ctx->owner == NULL || !ctx->bbs_view_active || direction == 0) {
    return false;
  }

  size_t window = SSH_CHATTER_BBS_VIEW_WINDOW;
  if (window == 0U) {
    window = 1U;
  }

  size_t total = ctx->bbs_view_total_lines;
  if (total <= window) {
    if (direction > 0) {
      session_send_system_line(ctx, "Already viewing the top of this post.");
    } else if (direction < 0) {
      session_send_system_line(ctx, "Already viewing the end of this post.");
    }
    return true;
  }

  size_t max_offset = total - window;
  size_t offset = ctx->bbs_view_scroll_offset;
  size_t effective_step = step;
  if (effective_step == 0U) {
    effective_step = window;
  }
  if (effective_step == 0U) {
    effective_step = 1U;
  }

  size_t new_offset = offset;
  if (direction > 0) {
    if (offset == 0U) {
      session_send_system_line(ctx, "Already viewing the top of this post.");
      return true;
    }
    if (effective_step > offset) {
      effective_step = offset;
    }
    if (effective_step == 0U) {
      effective_step = 1U;
    }
    new_offset = offset - effective_step;
  } else if (direction < 0) {
    if (offset >= max_offset) {
      session_send_system_line(ctx, "Already viewing the end of this post.");
      return true;
    }
    size_t advance = effective_step;
    if (advance > max_offset - offset) {
      advance = max_offset - offset;
    }
    if (advance == 0U) {
      advance = 1U;
    }
    new_offset = offset + advance;
  }

  if (new_offset == offset) {
    if (direction > 0) {
      session_send_system_line(ctx, "Already viewing the top of this post.");
    } else if (direction < 0) {
      session_send_system_line(ctx, "Already viewing the end of this post.");
    }
    return true;
  }

  ctx->bbs_view_scroll_offset = new_offset;
  return session_bbs_refresh_view(ctx);
}

// Show the BBS dashboard and mark the session as being in BBS mode.
static void session_bbs_show_dashboard(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }
  ctx->in_bbs_mode = true;
  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;
  session_bbs_prepare_canvas(ctx);
  session_render_separator(ctx, "BBS Dashboard");
  session_send_system_line(ctx,
                           "Commands: list, read <id>, topic read <tag>, post <title> [tags...], comment <id>|<text>, regen <id>, delete <id>, exit");
  session_bbs_list(ctx);
}

// List posts sorted by most recent activity.
static void session_bbs_list(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  bool previous_override = session_translation_push_scope_override(ctx);
  typedef struct bbs_listing {
    uint64_t id;
    char title[SSH_CHATTER_BBS_TITLE_LEN];
    char author[SSH_CHATTER_USERNAME_LEN];
    char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
    size_t tag_count;
    time_t created_at;
    time_t bumped_at;
  } bbs_listing_t;

  bbs_listing_t listings[SSH_CHATTER_BBS_MAX_POSTS];
  size_t count = 0U;

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    const bbs_post_t *post = &host->bbs_posts[idx];
    if (!post->in_use) {
      continue;
    }
    listings[count].id = post->id;
    snprintf(listings[count].title, sizeof(listings[count].title), "%s", post->title);
    snprintf(listings[count].author, sizeof(listings[count].author), "%s", post->author);
    listings[count].tag_count = post->tag_count;
    for (size_t tag = 0U; tag < post->tag_count && tag < SSH_CHATTER_BBS_MAX_TAGS; ++tag) {
      snprintf(listings[count].tags[tag], sizeof(listings[count].tags[tag]), "%s", post->tags[tag]);
    }
    listings[count].created_at = post->created_at;
    listings[count].bumped_at = post->bumped_at;
    ++count;
    if (count >= SSH_CHATTER_BBS_MAX_POSTS) {
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (count == 0U) {
    char empty_hint[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(empty_hint, sizeof(empty_hint),
             "The bulletin board is empty. Use /bbs post <title> [tags...] to write something. Finish drafts with %s.",
             session_bbs_terminator(ctx));
    session_send_system_line(ctx, empty_hint);
    session_translation_pop_scope_override(ctx, previous_override);
    return;
  }

  for (size_t outer = 1U; outer < count; ++outer) {
    bbs_listing_t key = listings[outer];
    size_t position = outer;
    while (position > 0U && listings[position - 1U].bumped_at < key.bumped_at) {
      listings[position] = listings[position - 1U];
      --position;
    }
    listings[position] = key;
  }

  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;

  typedef struct bbs_topic_group {
    char name[SSH_CHATTER_BBS_TAG_LEN];
    size_t indexes[SSH_CHATTER_BBS_MAX_POSTS];
    size_t count;
  } bbs_topic_group_t;

  bbs_topic_group_t topics[SSH_CHATTER_BBS_MAX_POSTS];
  size_t topic_count = 0U;
  memset(topics, 0, sizeof(topics));

  for (size_t idx = 0U; idx < count; ++idx) {
    const char *topic_name = (listings[idx].tag_count > 0U) ? listings[idx].tags[0] : SSH_CHATTER_BBS_DEFAULT_TAG;
    size_t match = topic_count;
    for (size_t topic_idx = 0U; topic_idx < topic_count; ++topic_idx) {
      if (strcasecmp(topics[topic_idx].name, topic_name) == 0) {
        match = topic_idx;
        break;
      }
    }
    if (match == topic_count) {
      if (topic_count >= SSH_CHATTER_BBS_MAX_POSTS) {
        continue;
      }
      snprintf(topics[match].name, sizeof(topics[match].name), "%s", topic_name);
      topics[match].count = 0U;
      ++topic_count;
    }
    if (topics[match].count < SSH_CHATTER_BBS_MAX_POSTS) {
      topics[match].indexes[topics[match].count++] = idx;
    }
  }

  for (size_t outer = 1U; outer < topic_count; ++outer) {
    bbs_topic_group_t key = topics[outer];
    size_t position = outer;
    while (position > 0U && strcasecmp(topics[position - 1U].name, key.name) > 0) {
      topics[position] = topics[position - 1U];
      --position;
    }
    topics[position] = key;
  }

  session_render_separator(ctx, "BBS Posts by Topic");
  for (size_t topic_idx = 0U; topic_idx < topic_count; ++topic_idx) {
    char section_label[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(section_label, sizeof(section_label), "Topic: %s", topics[topic_idx].name);
    session_render_separator(ctx, section_label);

    for (size_t entry_idx = 0U; entry_idx < topics[topic_idx].count; ++entry_idx) {
      size_t listing_index = topics[topic_idx].indexes[entry_idx];
      const bbs_listing_t *entry = &listings[listing_index];
      char created_buffer[32];
      bbs_format_time(entry->bumped_at, created_buffer, sizeof(created_buffer));
      char line[SSH_CHATTER_MESSAGE_LIMIT];
      int title_preview = (int)strnlen(entry->title, sizeof(entry->title));
      if (title_preview > 80) {
        title_preview = 80;
      }
      if (entry->tag_count == 0U) {
        snprintf(line, sizeof(line), "#%" PRIu64 " [%s] %.*s|(no tags)", entry->id, created_buffer, title_preview,
                 entry->title);
      } else {
        char tag_buffer[SSH_CHATTER_MESSAGE_LIMIT];
        size_t buffer_offset = 0U;
        tag_buffer[0] = '\0';
        for (size_t tag = 0U; tag < entry->tag_count; ++tag) {
          size_t len = strlen(entry->tags[tag]);
          if (buffer_offset + len + 2U >= sizeof(tag_buffer)) {
            break;
          }
          if (tag > 0U) {
            tag_buffer[buffer_offset++] = ',';
          }
          memcpy(tag_buffer + buffer_offset, entry->tags[tag], len);
          buffer_offset += len;
          tag_buffer[buffer_offset] = '\0';
        }
        int tags_preview = (int)strnlen(tag_buffer, sizeof(tag_buffer));
        if (tags_preview > 80) {
          tags_preview = 80;
        }
        snprintf(line, sizeof(line), "#%" PRIu64 " [%s] %.*s|%.*s", entry->id, created_buffer, title_preview,
                 entry->title, tags_preview, tag_buffer);
      }
      session_send_system_line(ctx, line);
    }
  }

  session_render_separator(ctx, "End");
  session_translation_pop_scope_override(ctx, previous_override);
}

static void session_bbs_list_topic(session_ctx_t *ctx, const char *topic) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  char working_topic[SSH_CHATTER_BBS_TAG_LEN];
  if (topic != NULL) {
    snprintf(working_topic, sizeof(working_topic), "%s", topic);
  } else {
    working_topic[0] = '\0';
  }
  trim_whitespace_inplace(working_topic);

  if (working_topic[0] == '\0') {
    session_send_system_line(ctx, "Specify a topic to read.");
    return;
  }

  bool previous_override = session_translation_push_scope_override(ctx);

  typedef struct bbs_listing {
    uint64_t id;
    char title[SSH_CHATTER_BBS_TITLE_LEN];
    char author[SSH_CHATTER_USERNAME_LEN];
    char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
    size_t tag_count;
    time_t created_at;
    time_t bumped_at;
  } bbs_listing_t;

  bbs_listing_t listings[SSH_CHATTER_BBS_MAX_POSTS];
  size_t count = 0U;

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    const bbs_post_t *post = &host->bbs_posts[idx];
    if (!post->in_use) {
      continue;
    }
    listings[count].id = post->id;
    snprintf(listings[count].title, sizeof(listings[count].title), "%s", post->title);
    snprintf(listings[count].author, sizeof(listings[count].author), "%s", post->author);
    listings[count].tag_count = post->tag_count;
    for (size_t tag_idx = 0U; tag_idx < post->tag_count && tag_idx < SSH_CHATTER_BBS_MAX_TAGS; ++tag_idx) {
      snprintf(listings[count].tags[tag_idx], sizeof(listings[count].tags[tag_idx]), "%s", post->tags[tag_idx]);
    }
    listings[count].created_at = post->created_at;
    listings[count].bumped_at = post->bumped_at;
    ++count;
    if (count >= SSH_CHATTER_BBS_MAX_POSTS) {
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (count == 0U) {
    session_send_system_line(ctx, "The bulletin board is empty.");
    session_translation_pop_scope_override(ctx, previous_override);
    return;
  }

  for (size_t outer = 1U; outer < count; ++outer) {
    bbs_listing_t key = listings[outer];
    size_t position = outer;
    while (position > 0U && listings[position - 1U].bumped_at < key.bumped_at) {
      listings[position] = listings[position - 1U];
      --position;
    }
    listings[position] = key;
  }

  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;

  char section_label[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(section_label, sizeof(section_label), "BBS Topic: %s", working_topic);
  session_render_separator(ctx, section_label);

  bool found = false;
  for (size_t idx = 0U; idx < count; ++idx) {
    const bbs_listing_t *entry = &listings[idx];
    const char *entry_topic = (entry->tag_count > 0U) ? entry->tags[0] : SSH_CHATTER_BBS_DEFAULT_TAG;
    if (strcasecmp(entry_topic, working_topic) != 0) {
      continue;
    }

    char created_buffer[32];
    bbs_format_time(entry->bumped_at, created_buffer, sizeof(created_buffer));

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    int title_preview = (int)strnlen(entry->title, sizeof(entry->title));
    if (title_preview > 80) {
      title_preview = 80;
    }

    if (entry->tag_count <= 1U) {
      snprintf(line, sizeof(line), "#%" PRIu64 " [%s] %.*s", entry->id, created_buffer, title_preview, entry->title);
    } else {
      char tag_buffer[SSH_CHATTER_MESSAGE_LIMIT];
      size_t buffer_offset = 0U;
      tag_buffer[0] = '\0';
      for (size_t tag_idx = 0U; tag_idx < entry->tag_count; ++tag_idx) {
        const char *tag_value = entry->tags[tag_idx];
        if (tag_value[0] == '\0') {
          continue;
        }
        size_t len = strlen(tag_value);
        if (buffer_offset + len + 2U >= sizeof(tag_buffer)) {
          break;
        }
        if (buffer_offset > 0U) {
          tag_buffer[buffer_offset++] = ',';
        }
        memcpy(tag_buffer + buffer_offset, tag_value, len);
        buffer_offset += len;
        tag_buffer[buffer_offset] = '\0';
      }
      int tags_preview = (int)strnlen(tag_buffer, sizeof(tag_buffer));
      if (tags_preview > 80) {
        tags_preview = 80;
      }
      snprintf(line, sizeof(line), "#%" PRIu64 " [%s] %.*s|%.*s", entry->id, created_buffer, title_preview, entry->title,
               tags_preview, tag_buffer);
    }

    session_send_system_line(ctx, line);
    found = true;
  }

  if (!found) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No posts found for topic '%s'.", working_topic);
    session_send_system_line(ctx, message);
  }

  session_render_separator(ctx, "End");
  session_translation_pop_scope_override(ctx, previous_override);
}

// Display a single post to the user.
static void session_bbs_read(session_ctx_t *ctx, uint64_t id) {
  if (ctx == NULL || ctx->owner == NULL || id == 0U) {
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, id);
  bbs_post_t snapshot = {0};
  if (post != NULL) {
    snapshot = *post;
  }
  pthread_mutex_unlock(&host->lock);

  if (post == NULL || !snapshot.in_use) {
    session_send_system_line(ctx, "No post exists with that identifier.");
    return;
  }

  session_bbs_render_post(ctx, &snapshot, NULL, true, false);
}

// Create a new post using the provided argument format.
static bool session_bbs_is_admin_only_tag(const char *tag) {
  if (tag == NULL || tag[0] == '\0') {
    return false;
  }

  if (strcasecmp(tag, "manual") == 0 || strcasecmp(tag, "notice") == 0) {
    return true;
  }

  if (strcmp(tag, "설명서") == 0 || strcmp(tag, "공지") == 0) {
    return true;
  }

  return false;
}

static void session_bbs_reset_pending_post(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  ctx->bbs_post_pending = false;
  ctx->editor_mode = SESSION_EDITOR_MODE_NONE;
  ctx->pending_bbs_edit_id = 0U;
  ctx->pending_bbs_title[0] = '\0';
  ctx->pending_bbs_body[0] = '\0';
  ctx->pending_bbs_body_length = 0U;
  ctx->pending_bbs_tag_count = 0U;
  ctx->pending_bbs_line_count = 0U;
  ctx->pending_bbs_cursor_line = 0U;
  ctx->pending_bbs_editing_line = false;
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_TAGS; ++idx) {
    ctx->pending_bbs_tags[idx][0] = '\0';
  }
  ctx->bbs_breaking_count = 0U;
  memset(ctx->bbs_breaking_messages, 0, sizeof(ctx->bbs_breaking_messages));
  ctx->bbs_rendering_editor = false;
}

static void session_bbs_commit_pending_post(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (!ctx->bbs_post_pending) {
    return;
  }

  if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
    session_asciiart_import_from_editor(ctx);
    if (ctx->asciiart_length == 0U) {
      const char *discard_message =
          (ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE) ? "Profile picture draft discarded."
                                                                            : "ASCII art draft discarded.";
      session_asciiart_cancel(ctx, discard_message);
      session_bbs_reset_pending_post(ctx);
      return;
    }

    session_asciiart_commit(ctx);
    session_bbs_reset_pending_post(ctx);
    return;
  }

  if (ctx->pending_bbs_body_length == 0U) {
    session_send_system_line(ctx, "Post body was empty. Draft discarded.");
    session_bbs_reset_pending_post(ctx);
    return;
  }

  if (session_security_check_text(ctx, "BBS post", ctx->pending_bbs_body, ctx->pending_bbs_body_length, false) !=
      HOST_SECURITY_SCAN_CLEAN) {
    session_bbs_reset_pending_post(ctx);
    return;
  }

  host_t *host = ctx->owner;
  if (host == NULL) {
    session_bbs_reset_pending_post(ctx);
    return;
  }

  pthread_mutex_lock(&host->lock);
  bbs_post_t snapshot = {0};
  if (ctx->editor_mode == SESSION_EDITOR_MODE_BBS_EDIT) {
    uint64_t edit_id = ctx->pending_bbs_edit_id;
    bbs_post_t *post = host_find_bbs_post_locked(host, edit_id);
    if (post == NULL || !post->in_use) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "No post exists with that identifier anymore.");
      session_bbs_reset_pending_post(ctx);
      return;
    }

    bool can_edit = (strncmp(post->author, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) || ctx->user.is_operator ||
                    ctx->user.is_lan_operator;
    if (!can_edit) {
      pthread_mutex_unlock(&host->lock);
      session_send_system_line(ctx, "Only the author or an operator may edit this post.");
      session_bbs_reset_pending_post(ctx);
      return;
    }

    snprintf(post->title, sizeof(post->title), "%s", ctx->pending_bbs_title);
    memcpy(post->body, ctx->pending_bbs_body, ctx->pending_bbs_body_length);
    post->body[ctx->pending_bbs_body_length] = '\0';
    host_strip_column_reset(post->title);
    host_strip_column_reset(post->body);
    post->tag_count = ctx->pending_bbs_tag_count;
    for (size_t idx = 0U; idx < post->tag_count; ++idx) {
      snprintf(post->tags[idx], sizeof(post->tags[idx]), "%s", ctx->pending_bbs_tags[idx]);
      host_strip_column_reset(post->tags[idx]);
    }

    post->bumped_at = time(NULL);
    snapshot = *post;
    host_bbs_state_save_locked(host);
    pthread_mutex_unlock(&host->lock);

    session_bbs_reset_pending_post(ctx);
    session_bbs_render_post(ctx, &snapshot, "Post updated.", false, false);
    return;
  }

  bbs_post_t *post = host_allocate_bbs_post_locked(host);
  if (post == NULL) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "The bulletin board is full right now.");
    return;
  }

  snprintf(post->author, sizeof(post->author), "%s", ctx->user.name);
  snprintf(post->title, sizeof(post->title), "%s", ctx->pending_bbs_title);
  memcpy(post->body, ctx->pending_bbs_body, ctx->pending_bbs_body_length);
  post->body[ctx->pending_bbs_body_length] = '\0';
  host_strip_column_reset(post->author);
  host_strip_column_reset(post->title);
  host_strip_column_reset(post->body);
  post->tag_count = ctx->pending_bbs_tag_count;
  for (size_t idx = 0U; idx < post->tag_count; ++idx) {
    snprintf(post->tags[idx], sizeof(post->tags[idx]), "%s", ctx->pending_bbs_tags[idx]);
    host_strip_column_reset(post->tags[idx]);
  }

  snapshot = *post;
  host_bbs_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  session_bbs_reset_pending_post(ctx);

  session_bbs_render_post(ctx, &snapshot, "Post created.", true, false);
}

static void session_bbs_begin_post(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->bbs_post_pending) {
    const char *terminator = session_editor_terminator(ctx);
    char warning[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(warning, sizeof(warning), "You are already composing a post. Finish it with %s.", terminator);
    session_send_system_line(ctx, warning);
    return;
  }

  ctx->bbs_breaking_count = 0U;
  memset(ctx->bbs_breaking_messages, 0, sizeof(ctx->bbs_breaking_messages));
  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "The bulletin board is unavailable right now.");
    return;
  }

  session_bbs_reset_pending_post(ctx);

  if (arguments == NULL) {
    session_bbs_send_usage(ctx, "post", "<title>[|tags...]");
    session_send_system_line(ctx, "Use | to separate tags when the title has spaces.");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_bbs_send_usage(ctx, "post", "<title>[|tags...]");
    session_send_system_line(ctx, "Use | to separate tags when the title has spaces.");
    return;
  }

  char title[SSH_CHATTER_BBS_TITLE_LEN];
  title[0] = '\0';
  char *tag_cursor = NULL;
  char *separator = strchr(working, '|');
  if (separator != NULL) {
    *separator = '\0';
    char *title_part = working;
    char *tags_part = separator + 1;
    trim_whitespace_inplace(title_part);
    trim_whitespace_inplace(tags_part);
    size_t title_len = strnlen(title_part, sizeof(title));
    if (title_len > 1U && (title_part[0] == '\"' || title_part[0] == '\'') && title_part[title_len - 1U] == title_part[0]) {
      title_part[title_len - 1U] = '\0';
      ++title_part;
      trim_whitespace_inplace(title_part);
    }
    size_t copy_len = strnlen(title_part, sizeof(title) - 1U);
    memcpy(title, title_part, copy_len);
    title[copy_len] = '\0';
    tag_cursor = tags_part;
  } else {
    char *cursor = working;
    if (*cursor == '\"' || *cursor == '\'') {
      char quote = *cursor++;
      char *closing = strchr(cursor, quote);
      if (closing == NULL) {
        session_send_system_line(ctx, "Missing closing quote for the title.");
        return;
      }
      size_t copy_len = (size_t)(closing - cursor);
      if (copy_len >= sizeof(title)) {
        copy_len = sizeof(title) - 1U;
      }
      memcpy(title, cursor, copy_len);
      title[copy_len] = '\0';
      cursor = closing + 1;
    } else {
      char *space = cursor;
      while (*space != '\0' && !isspace((unsigned char)*space)) {
        ++space;
      }
      size_t copy_len = (size_t)(space - cursor);
      if (copy_len >= sizeof(title)) {
        copy_len = sizeof(title) - 1U;
      }
      memcpy(title, cursor, copy_len);
      title[copy_len] = '\0';
      cursor = space;
    }

    trim_whitespace_inplace(cursor);
    tag_cursor = cursor;
  }

  if (title[0] == '\0') {
    session_send_system_line(ctx, "A title is required to create a post.");
    return;
  }

  size_t tag_count = 0U;
  bool discarded_tags = false;
  bool default_tag_applied = false;
  while (tag_cursor != NULL && *tag_cursor != '\0') {
    while (isspace((unsigned char)*tag_cursor)) {
      ++tag_cursor;
    }
    if (*tag_cursor == '\0') {
      break;
    }
    char *end = tag_cursor;
    while (*end != '\0' && !isspace((unsigned char)*end)) {
      ++end;
    }
    size_t length = (size_t)(end - tag_cursor);
    if (length > 0U) {
      if (tag_count < SSH_CHATTER_BBS_MAX_TAGS) {
        if (length >= SSH_CHATTER_BBS_TAG_LEN) {
          length = SSH_CHATTER_BBS_TAG_LEN - 1U;
        }
        char tag_value[SSH_CHATTER_BBS_TAG_LEN];
        memcpy(tag_value, tag_cursor, length);
        tag_value[length] = '\0';
        if (!ctx->user.is_operator && session_bbs_is_admin_only_tag(tag_value)) {
          char warning[SSH_CHATTER_MESSAGE_LIMIT];
          snprintf(warning, sizeof(warning), "The '%s' tag is reserved for administrators.", tag_value);
          session_send_system_line(ctx, warning);
          return;
        }
        snprintf(ctx->pending_bbs_tags[tag_count], sizeof(ctx->pending_bbs_tags[tag_count]), "%s", tag_value);
        ++tag_count;
      } else {
        discarded_tags = true;
      }
    }
    tag_cursor = end;
  }

  if (tag_count == 0U) {
    snprintf(ctx->pending_bbs_tags[0], sizeof(ctx->pending_bbs_tags[0]), "%s", SSH_CHATTER_BBS_DEFAULT_TAG);
    tag_count = 1U;
    default_tag_applied = true;
  }

  snprintf(ctx->pending_bbs_title, sizeof(ctx->pending_bbs_title), "%s", title);
  ctx->pending_bbs_tag_count = tag_count;
  ctx->pending_bbs_body[0] = '\0';
  ctx->pending_bbs_body_length = 0U;
  ctx->bbs_post_pending = true;
  ctx->editor_mode = SESSION_EDITOR_MODE_BBS_CREATE;
  ctx->pending_bbs_edit_id = 0U;

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  notice[0] = '\0';
  if (default_tag_applied) {
    snprintf(notice, sizeof(notice), "No tags provided; default tag '%s' applied.", SSH_CHATTER_BBS_DEFAULT_TAG);
  }
  if (discarded_tags) {
    if (notice[0] != '\0') {
      strncat(notice, "\n", sizeof(notice) - strlen(notice) - 1U);
    }
    strncat(notice, "Only the first four tags were kept. Extra tags were ignored.",
            sizeof(notice) - strlen(notice) - 1U);
  }

  session_bbs_render_editor(ctx, notice[0] != '\0' ? notice : NULL);
}

static void session_bbs_capture_body_text(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || !ctx->bbs_post_pending || text == NULL) {
    return;
  }

  session_capture_multiline_text(ctx, text, session_bbs_capture_body_line, session_bbs_capture_continue);
}

static void session_bbs_capture_body_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || !ctx->bbs_post_pending) {
    return;
  }

  char trimmed[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(trimmed, sizeof(trimmed), "%s", line != NULL ? line : "");
  trim_whitespace_inplace(trimmed);
  if (session_editor_matches_terminator(ctx, trimmed)) {
    session_bbs_commit_pending_post(ctx);
    return;
  }

  if (line == NULL) {
    line = "";
  }

  char status[SSH_CHATTER_MESSAGE_LIMIT];
  status[0] = '\0';

  session_bbs_recalculate_line_count(ctx);
  bool editing_line = ctx->pending_bbs_editing_line && ctx->pending_bbs_cursor_line < ctx->pending_bbs_line_count;

  bool updated = false;
  if (editing_line) {
    updated = session_bbs_replace_line(ctx, ctx->pending_bbs_cursor_line, line, status, sizeof(status));
  } else {
    updated = session_bbs_append_line(ctx, line, status, sizeof(status));
  }

  if (!updated && status[0] == '\0') {
    snprintf(status, sizeof(status), "Unable to update the draft right now.");
  }

  session_bbs_render_editor(ctx, status[0] != '\0' ? status : NULL);
}

static void session_bbs_begin_edit(session_ctx_t *ctx, uint64_t id) {
  if (ctx == NULL || id == 0U) {
    session_send_system_line(ctx, "Invalid post identifier.");
    return;
  }

  if (ctx->bbs_post_pending) {
    const char *terminator = session_editor_terminator(ctx);
    char warning[SSH_CHATTER_MESSAGE_LIMIT];
    if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
      snprintf(warning, sizeof(warning), "You are already composing ASCII art. Finish it with %s.", terminator);
    } else {
      snprintf(warning, sizeof(warning), "You are already composing a post. Finish it with %s.", terminator);
    }
    session_send_system_line(ctx, warning);
    return;
  }

  if (ctx->owner == NULL) {
    session_send_system_line(ctx, "The bulletin board is unavailable right now.");
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, id);
  bbs_post_t snapshot = {0};
  if (post != NULL && post->in_use) {
    snapshot = *post;
  }
  pthread_mutex_unlock(&host->lock);

  if (post == NULL || !snapshot.in_use) {
    session_send_system_line(ctx, "No post exists with that identifier.");
    return;
  }

  bool can_edit = (strncmp(snapshot.author, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) || ctx->user.is_operator ||
                  ctx->user.is_lan_operator;
  if (!can_edit) {
    session_send_system_line(ctx, "Only the author or an operator may edit this post.");
    return;
  }

  session_bbs_reset_pending_post(ctx);
  ctx->bbs_post_pending = true;
  ctx->editor_mode = SESSION_EDITOR_MODE_BBS_EDIT;
  ctx->pending_bbs_edit_id = id;

  snprintf(ctx->pending_bbs_title, sizeof(ctx->pending_bbs_title), "%s", snapshot.title);

  size_t body_len = strnlen(snapshot.body, sizeof(ctx->pending_bbs_body) - 1U);
  memcpy(ctx->pending_bbs_body, snapshot.body, body_len);
  ctx->pending_bbs_body[body_len] = '\0';
  ctx->pending_bbs_body_length = body_len;

  ctx->pending_bbs_tag_count = snapshot.tag_count;
  if (ctx->pending_bbs_tag_count > SSH_CHATTER_BBS_MAX_TAGS) {
    ctx->pending_bbs_tag_count = SSH_CHATTER_BBS_MAX_TAGS;
  }
  for (size_t idx = 0U; idx < ctx->pending_bbs_tag_count; ++idx) {
    snprintf(ctx->pending_bbs_tags[idx], sizeof(ctx->pending_bbs_tags[idx]), "%s", snapshot.tags[idx]);
  }

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "Editing post #%" PRIu64 ". Finish with %s to save changes.", id,
           session_bbs_terminator(ctx));
  session_bbs_render_editor(ctx, notice);
}

// Append a comment to a post.
static void session_bbs_add_comment(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL || arguments == NULL) {
    session_bbs_send_usage(ctx, "comment", "<id>|<text>");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_bbs_send_usage(ctx, "comment", "<id>|<text>");
    return;
  }

  char *separator = strchr(working, '|');
  if (separator == NULL) {
    session_bbs_send_usage(ctx, "comment", "<id>|<text>");
    return;
  }
  *separator = '\0';
  char *id_text = working;
  char *comment_text = separator + 1;
  trim_whitespace_inplace(id_text);
  trim_whitespace_inplace(comment_text);

  if (id_text[0] == '\0' || comment_text[0] == '\0') {
    session_bbs_send_usage(ctx, "comment", "<id>|<text>");
    return;
  }

  uint64_t id = (uint64_t)strtoull(id_text, NULL, 10);
  if (id == 0U) {
    session_send_system_line(ctx, "Invalid post identifier.");
    return;
  }

  size_t comment_scan_length = strnlen(comment_text, SSH_CHATTER_BBS_COMMENT_LEN);
  if (session_security_check_text(ctx, "BBS comment", comment_text, comment_scan_length, false) !=
      HOST_SECURITY_SCAN_CLEAN) {
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, id);
  if (post == NULL || !post->in_use) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "No post exists with that identifier.");
    return;
  }
  if (post->comment_count >= SSH_CHATTER_BBS_MAX_COMMENTS) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "This post has reached the comment limit.");
    return;
  }

  bbs_comment_t *comment = &post->comments[post->comment_count++];
  snprintf(comment->author, sizeof(comment->author), "%s", ctx->user.name);
  size_t comment_len = strnlen(comment_text, SSH_CHATTER_BBS_COMMENT_LEN - 1U);
  memcpy(comment->text, comment_text, comment_len);
  comment->text[comment_len] = '\0';
  host_strip_column_reset(comment->author);
  host_strip_column_reset(comment->text);
  comment->created_at = time(NULL);
  post->bumped_at = comment->created_at;
  bbs_post_t snapshot = *post;
  host_bbs_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  session_bbs_render_post(ctx, &snapshot, "Comment added.", false, true);
}

static void session_bbs_delete(session_ctx_t *ctx, uint64_t id) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (id == 0U) {
    session_send_system_line(ctx, "Invalid post identifier.");
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, id);
  if (post == NULL || !post->in_use) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "No post exists with that identifier.");
    return;
  }

  bool can_delete = (strncmp(post->author, ctx->user.name, SSH_CHATTER_USERNAME_LEN) == 0) || ctx->user.is_operator ||
                    ctx->user.is_lan_operator;
  if (!can_delete) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "Only the author or an operator may delete this post.");
    return;
  }

  host_clear_bbs_post_locked(host, post);
  host_bbs_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  session_send_system_line(ctx, "Post deleted.");
}

// Bump a post to the top of the list by refreshing its activity time.
static void session_bbs_regen_post(session_ctx_t *ctx, uint64_t id) {
  if (ctx == NULL || ctx->owner == NULL || id == 0U) {
    return;
  }

  host_t *host = ctx->owner;
  pthread_mutex_lock(&host->lock);
  bbs_post_t *post = host_find_bbs_post_locked(host, id);
  if (post == NULL || !post->in_use) {
    pthread_mutex_unlock(&host->lock);
    session_send_system_line(ctx, "No post exists with that identifier.");
    return;
  }

  post->bumped_at = time(NULL);
  bbs_post_t snapshot = *post;
  host_bbs_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);

  session_bbs_render_post(ctx, &snapshot, "Post bumped to the top.", false, false);
}

static void session_rss_clear(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  memset(&ctx->rss_view, 0, sizeof(ctx->rss_view));
  ctx->in_rss_mode = false;
}

static void session_rss_exit(session_ctx_t *ctx, const char *reason) {
  if (ctx == NULL) {
    return;
  }

  const bool was_active = ctx->in_rss_mode;
  session_rss_clear(ctx);

  if (reason != NULL && reason[0] != '\0') {
    session_send_system_line(ctx, reason);
  } else if (was_active) {
    session_send_system_line(ctx, "RSS reader closed.");
  }

  if (was_active) {
    session_render_prompt(ctx, false);
  }
}

static void session_rss_show_current(session_ctx_t *ctx) {
  if (ctx == NULL || !ctx->rss_view.active || ctx->rss_view.item_count == 0U) {
    return;
  }

  if (ctx->rss_view.cursor >= ctx->rss_view.item_count) {
    ctx->rss_view.cursor = ctx->rss_view.item_count - 1U;
  }

  const rss_session_item_t *item = &ctx->rss_view.items[ctx->rss_view.cursor];

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Feed %s (%zu/%zu)", ctx->rss_view.tag, ctx->rss_view.cursor + 1U,
           ctx->rss_view.item_count);
  session_render_separator(ctx, header);

  char line[SSH_CHATTER_MESSAGE_LIMIT];
  if (item->title[0] != '\0') {
    snprintf(line, sizeof(line), "Title : %s", item->title);
  } else {
    snprintf(line, sizeof(line), "Title : (untitled)");
  }
  session_send_system_line(ctx, line);

  if (item->link[0] != '\0') {
    snprintf(line, sizeof(line), "Link  : %s", item->link);
  } else {
    snprintf(line, sizeof(line), "Link  : (none)");
  }
  session_send_system_line(ctx, line);

  if (item->summary[0] != '\0') {
    session_send_system_line(ctx, "Summary:");
    char working[SSH_CHATTER_RSS_SUMMARY_LEN];
    snprintf(working, sizeof(working), "%s", item->summary);
    char *saveptr = NULL;
    char *fragment = strtok_r(working, "\r\n", &saveptr);
    while (fragment != NULL) {
      rss_trim_whitespace(fragment);
      if (fragment[0] != '\0') {
        snprintf(line, sizeof(line), "  %s", fragment);
        session_send_system_line(ctx, line);
      }
      fragment = strtok_r(NULL, "\r\n", &saveptr);
    }
  } else {
    session_send_system_line(ctx, "Summary: (none)");
  }
}

static void session_rss_begin(session_ctx_t *ctx, const char *tag, const rss_session_item_t *items, size_t count) {
  if (ctx == NULL || tag == NULL || tag[0] == '\0' || items == NULL || count == 0U) {
    return;
  }

  session_rss_clear(ctx);

  if (count > SSH_CHATTER_RSS_MAX_ITEMS) {
    count = SSH_CHATTER_RSS_MAX_ITEMS;
  }

  ctx->rss_view.active = true;
  ctx->rss_view.item_count = count;
  ctx->rss_view.cursor = 0U;
  snprintf(ctx->rss_view.tag, sizeof(ctx->rss_view.tag), "%s", tag);
  for (size_t idx = 0U; idx < count; ++idx) {
    ctx->rss_view.items[idx] = items[idx];
  }
  ctx->in_rss_mode = true;

  char intro[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(intro, sizeof(intro),
           "Browsing feed '%s'. Use Up/Down arrows to navigate. Type /exit or press Ctrl+Z to return.",
           ctx->rss_view.tag);
  session_render_separator(ctx, "RSS Reader");
  session_send_system_line(ctx, intro);
  session_rss_show_current(ctx);
}

static bool session_rss_move(session_ctx_t *ctx, int delta) {
  if (ctx == NULL || !ctx->rss_view.active || ctx->rss_view.item_count == 0U || delta == 0) {
    return false;
  }

  size_t current = ctx->rss_view.cursor;
  size_t next = current;

  if (delta > 0) {
    if (next + 1U < ctx->rss_view.item_count) {
      next += 1U;
    }
  } else {
    if (next > 0U) {
      next -= 1U;
    }
  }

  if (next == current) {
    return false;
  }

  ctx->rss_view.cursor = next;
  session_rss_show_current(ctx);
  return true;
}

static void session_rss_list(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  rss_feed_t snapshot[SSH_CHATTER_RSS_MAX_FEEDS];
  size_t count = 0U;

  pthread_mutex_lock(&ctx->owner->lock);
  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    if (!ctx->owner->rss_feeds[idx].in_use) {
      continue;
    }
    snapshot[count++] = ctx->owner->rss_feeds[idx];
    if (count >= SSH_CHATTER_RSS_MAX_FEEDS) {
      break;
    }
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  session_render_separator(ctx, "RSS Feeds");
  if (count == 0U) {
    session_send_system_line(ctx,
                             "No RSS feeds registered. Operators can add one with /rss add <url> <tag>.");
    return;
  }

  for (size_t idx = 0U; idx < count; ++idx) {
    const rss_feed_t *entry = &snapshot[idx];
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    if (entry->last_title[0] != '\0') {
      char preview[72];
      snprintf(preview, sizeof(preview), "%.64s", entry->last_title);
      snprintf(line, sizeof(line), "[%s] %s (last: %s)", entry->tag, entry->url, preview);
    } else {
      snprintf(line, sizeof(line), "[%s] %s", entry->tag, entry->url);
    }
    session_send_system_line(ctx, line);
  }
}

static void session_rss_read(session_ctx_t *ctx, const char *tag) {
  if (ctx == NULL || ctx->owner == NULL || tag == NULL || tag[0] == '\0') {
    session_send_system_line(ctx, "Usage: /rss read <tag>");
    return;
  }

  char working[SSH_CHATTER_RSS_TAG_LEN];
  snprintf(working, sizeof(working), "%s", tag);
  rss_trim_whitespace(working);
  if (!rss_tag_is_valid(working)) {
    session_send_system_line(ctx, "Tags may only contain letters, numbers, '-', '_' or '.'.");
    return;
  }

  rss_feed_t feed_snapshot = {0};
  pthread_mutex_lock(&ctx->owner->lock);
  rss_feed_t *entry = host_find_rss_feed_locked(ctx->owner, working);
  if (entry != NULL) {
    feed_snapshot = *entry;
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  if (feed_snapshot.tag[0] == '\0') {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "No RSS feed found for tag '%s'.", working);
    session_send_system_line(ctx, message);
    return;
  }

  rss_session_item_t items[SSH_CHATTER_RSS_MAX_ITEMS];
  size_t item_count = 0U;
  if (!host_rss_fetch_items(&feed_snapshot, items, SSH_CHATTER_RSS_MAX_ITEMS, &item_count)) {
    session_send_system_line(ctx, "Failed to fetch RSS feed. Try again later.");
    return;
  }

  if (item_count == 0U) {
    session_send_system_line(ctx, "The feed does not contain any recent entries.");
    return;
  }

  time_t now = time(NULL);
  pthread_mutex_lock(&ctx->owner->lock);
  entry = host_find_rss_feed_locked(ctx->owner, working);
  if (entry != NULL) {
    entry->last_checked = now;
    snprintf(entry->last_title, sizeof(entry->last_title), "%s", items[0].title);
    snprintf(entry->last_link, sizeof(entry->last_link), "%s", items[0].link);
    host_rss_state_save_locked(ctx->owner);
  }
  pthread_mutex_unlock(&ctx->owner->lock);

  session_rss_begin(ctx, feed_snapshot.tag, items, item_count);
}

static void session_handle_rss(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /rss <add <url> <tag>|del <tag>|read <tag>|list>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/rss", kUsage, usage, sizeof(usage));

  char working[SSH_CHATTER_MAX_INPUT_LEN];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  rss_trim_whitespace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char *saveptr = NULL;
  char *command = strtok_r(working, " \t", &saveptr);
  if (command == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  if (strcasecmp(command, "list") == 0) {
    session_rss_list(ctx);
    return;
  }

  if (strcasecmp(command, "add") == 0 || strcasecmp(command, "추가") == 0) {
    if (!ctx->user.is_operator) {
      session_send_system_line(ctx, "Only operators may add RSS feeds.");
      return;
    }

    char *url = strtok_r(NULL, " \t", &saveptr);
    char *tag = strtok_r(NULL, " \t", &saveptr);
    if (url == NULL || tag == NULL) {
      session_send_system_line(ctx, "Usage: /rss add <url> <tag>");
      return;
    }

    rss_trim_whitespace(url);
    rss_trim_whitespace(tag);
    if (url[0] == '\0' || tag[0] == '\0') {
      session_send_system_line(ctx, "Usage: /rss add <url> <tag>");
      return;
    }

    char error[128];
    if (host_rss_add_feed(ctx->owner, url, tag, error, sizeof(error))) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "RSS feed '%s' registered as '%s'.", url, tag);
      session_send_system_line(ctx, message);
      host_rss_start_backend(ctx->owner);
    } else {
      if (error[0] == '\0') {
        snprintf(error, sizeof(error), "Failed to add RSS feed.");
      }
      session_send_system_line(ctx, error);
    }
    return;
  }

  if (strcasecmp(command, "del") == 0 || strcasecmp(command, "삭제") == 0) {
    if (!ctx->user.is_operator) {
      session_send_system_line(ctx, "Only operators may delete RSS feeds.");
      return;
    }

    char *tag = strtok_r(NULL, " \t", &saveptr);
    if (tag == NULL) {
      session_send_system_line(ctx, "Usage: /rss del <tag>");
      return;
    }

    rss_trim_whitespace(tag);
    if (tag[0] == '\0') {
      session_send_system_line(ctx, "Usage: /rss del <tag>");
      return;
    }

    char error[128];
    if (host_rss_remove_feed(ctx->owner, tag, error, sizeof(error))) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "RSS feed '%s' deleted.", tag);
      session_send_system_line(ctx, message);
    } else {
      if (error[0] == '\0') {
        snprintf(error, sizeof(error), "Failed to delete RSS feed.");
      }
      session_send_system_line(ctx, error);
    }
    return;
  }

  if (strcasecmp(command, "read") == 0) {
    char *tag = strtok_r(NULL, " \t", &saveptr);
    if (tag == NULL) {
      session_send_system_line(ctx, "Usage: /rss read <tag>");
      return;
    }
    session_rss_read(ctx, tag);
    return;
  }

  session_send_system_line(ctx, usage);
}

static bool host_asciiart_cooldown_active(host_t *host, const char *ip, const struct timespec *now,
                                          long *remaining_seconds) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    if (remaining_seconds != NULL) {
      *remaining_seconds = 0L;
    }
    return false;
  }

  struct timespec current = {0, 0};
  if (now != NULL) {
    current = *now;
  } else if (clock_gettime(CLOCK_MONOTONIC, &current) != 0) {
    current.tv_sec = time(NULL);
    current.tv_nsec = 0L;
  }

  bool active = false;
  long remaining = 0L;

  pthread_mutex_lock(&host->lock);
  join_activity_entry_t *entry = host_find_join_activity_locked(host, ip);
  if (entry != NULL && entry->asciiart_has_cooldown) {
    struct timespec expiry = entry->last_asciiart_post;
    expiry.tv_sec += SSH_CHATTER_ASCIIART_COOLDOWN_SECONDS;
    if (timespec_compare(&current, &expiry) >= 0) {
      entry->asciiart_has_cooldown = false;
    } else {
      active = true;
      struct timespec diff = timespec_diff(&expiry, &current);
      remaining = diff.tv_sec;
      if (diff.tv_nsec > 0L) {
        ++remaining;
      }
      if (remaining < 0L) {
        remaining = 0L;
      }
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (remaining_seconds != NULL) {
    *remaining_seconds = active ? remaining : 0L;
  }

  return active;
}

static void host_asciiart_register_post(host_t *host, const char *ip, const struct timespec *when) {
  if (host == NULL || ip == NULL || ip[0] == '\0' || when == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  join_activity_entry_t *entry = host_ensure_join_activity_locked(host, ip);
  if (entry != NULL) {
    entry->last_asciiart_post = *when;
    entry->asciiart_has_cooldown = true;
  }
  pthread_mutex_unlock(&host->lock);
}

static void session_asciiart_reset(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  ctx->asciiart_pending = false;
  ctx->asciiart_target = SESSION_ASCIIART_TARGET_NONE;
  ctx->asciiart_buffer[0] = '\0';
  ctx->asciiart_length = 0U;
  ctx->asciiart_line_count = 0U;
}

static bool session_asciiart_cooldown_active(session_ctx_t *ctx, struct timespec *now, long *remaining_seconds) {
  if (ctx == NULL) {
    return false;
  }

  struct timespec current;
  if (clock_gettime(CLOCK_MONOTONIC, &current) != 0) {
    current.tv_sec = time(NULL);
    current.tv_nsec = 0L;
  }

  if (now != NULL) {
    *now = current;
  }

  long session_remaining = 0L;
  bool session_active = false;
  if (ctx->asciiart_has_cooldown) {
    struct timespec expiry = ctx->last_asciiart_post;
    expiry.tv_sec += SSH_CHATTER_ASCIIART_COOLDOWN_SECONDS;
    if (timespec_compare(&current, &expiry) >= 0) {
      ctx->asciiart_has_cooldown = false;
    } else {
      session_active = true;
      struct timespec diff = timespec_diff(&expiry, &current);
      session_remaining = diff.tv_sec;
      if (diff.tv_nsec > 0L) {
        ++session_remaining;
      }
      if (session_remaining < 0L) {
        session_remaining = 0L;
      }
    }
  }

  long ip_remaining = 0L;
  bool ip_active = host_asciiart_cooldown_active(ctx->owner, ctx->client_ip, &current, &ip_remaining);

  if (!session_active && !ip_active) {
    if (remaining_seconds != NULL) {
      *remaining_seconds = 0L;
    }
    return false;
  }

  long max_remaining = session_active ? session_remaining : 0L;
  if (ip_active && ip_remaining > max_remaining) {
    max_remaining = ip_remaining;
  }

  if (remaining_seconds != NULL) {
    *remaining_seconds = max_remaining;
  }

  return true;
}

static void session_asciiart_begin(session_ctx_t *ctx, session_asciiart_target_t target) {
  if (ctx == NULL || target == SESSION_ASCIIART_TARGET_NONE) {
    return;
  }

  if (ctx->bbs_post_pending) {
    if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
      const char *terminator = session_editor_terminator(ctx);
      char notice[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(notice, sizeof(notice), "You are already composing ASCII art. Finish it with %s.", terminator);
      session_send_system_line(ctx, notice);
    } else {
      session_send_system_line(ctx, "Finish your BBS draft before starting ASCII art.");
    }
    return;
  }

  if (ctx->asciiart_pending) {
    const char *terminator = session_asciiart_terminator(ctx);
    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice), "You are already composing ASCII art. Finish it with %s.", terminator);
    session_send_system_line(ctx, notice);
    return;
  }

  if (target == SESSION_ASCIIART_TARGET_CHAT) {
    struct timespec now;
    long remaining = 0L;
    if (session_asciiart_cooldown_active(ctx, &now, &remaining)) {
      if (remaining < 1L) {
        remaining = 1L;
      }
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "You can share another ASCII art in %ld second%s.", remaining,
               remaining == 1L ? "" : "s");
      session_send_system_line(ctx, message);
      return;
    }
  } else if (target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE) {
    if (!session_user_data_available(ctx) || !session_user_data_load(ctx)) {
      session_send_system_line(ctx, "Profile storage is unavailable.");
      return;
    }
  }

  session_asciiart_reset(ctx);
  ctx->asciiart_pending = true;
  ctx->asciiart_target = target;

  session_bbs_reset_pending_post(ctx);
  ctx->editor_mode = SESSION_EDITOR_MODE_ASCIIART;
  ctx->bbs_post_pending = true;

  size_t ascii_bytes = (size_t)SSH_CHATTER_ASCIIART_BUFFER_LEN;
  char status[SSH_CHATTER_MESSAGE_LIMIT];
  if (target == SESSION_ASCIIART_TARGET_CHAT) {
    snprintf(status, sizeof(status),
             "ASCII art composer ready (max %u lines, up to %zu bytes, 10-minute cooldown per IP).",
             SSH_CHATTER_ASCIIART_MAX_LINES, ascii_bytes);
  } else {
    snprintf(status, sizeof(status),
             "Profile picture composer ready (max %u lines, up to %zu bytes, stored privately).",
             SSH_CHATTER_ASCIIART_MAX_LINES, ascii_bytes);
  }

  session_bbs_render_editor(ctx, status);
}

static void session_asciiart_import_from_editor(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_bbs_recalculate_line_count(ctx);

  size_t copy_len = ctx->pending_bbs_body_length;
  if (copy_len >= sizeof(ctx->asciiart_buffer)) {
    copy_len = sizeof(ctx->asciiart_buffer) - 1U;
  }

  if (copy_len > 0U) {
    memcpy(ctx->asciiart_buffer, ctx->pending_bbs_body, copy_len);
  }
  ctx->asciiart_buffer[copy_len] = '\0';
  ctx->asciiart_length = copy_len;
  ctx->asciiart_line_count = ctx->pending_bbs_line_count;
  if (ctx->asciiart_line_count > SSH_CHATTER_ASCIIART_MAX_LINES) {
    ctx->asciiart_line_count = SSH_CHATTER_ASCIIART_MAX_LINES;
  }
}

static void session_asciiart_commit(session_ctx_t *ctx) {
  if (ctx == NULL || !ctx->asciiart_pending) {
    return;
  }

  const session_asciiart_target_t target = ctx->asciiart_target;

  if (ctx->asciiart_length == 0U) {
    const char *discard_message =
        (target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE) ? "Profile picture draft discarded."
                                                            : "ASCII art draft discarded.";
    session_asciiart_cancel(ctx, discard_message);
    return;
  }

  if (ctx->owner == NULL) {
    session_asciiart_reset(ctx);
    return;
  }

  const char *security_label =
      target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE ? "Profile picture" : "ASCII art";
  if (session_security_check_text(ctx, security_label, ctx->asciiart_buffer, ctx->asciiart_length, false) !=
      HOST_SECURITY_SCAN_CLEAN) {
    session_asciiart_reset(ctx);
    return;
  }

  if (target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE) {
    if (!session_user_data_available(ctx) || !session_user_data_load(ctx)) {
      session_send_system_line(ctx, "Profile storage is unavailable.");
      session_asciiart_reset(ctx);
      return;
    }

    if ((size_t)ctx->asciiart_length >= USER_DATA_PROFILE_PICTURE_LEN) {
      session_send_system_line(ctx, "Profile picture exceeds the storage limit.");
      session_asciiart_reset(ctx);
      return;
    }

    char normalized[USER_DATA_PROFILE_PICTURE_LEN];
    session_profile_picture_normalize(ctx->asciiart_buffer, normalized, sizeof(normalized));
    if (normalized[0] == '\0') {
      session_send_system_line(ctx, "Profile picture cannot be empty.");
      session_asciiart_reset(ctx);
      return;
    }

    snprintf(ctx->user_data.profile_picture, sizeof(ctx->user_data.profile_picture), "%s", normalized);
    if (session_user_data_commit(ctx)) {
      session_send_system_line(ctx, "Profile picture updated.");
    } else {
      session_send_system_line(ctx, "Failed to save profile picture.");
    }

    session_asciiart_reset(ctx);
    return;
  }

  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now) != 0) {
    now.tv_sec = time(NULL);
    now.tv_nsec = 0L;
  }

  ctx->last_asciiart_post = now;
  ctx->asciiart_has_cooldown = true;
  host_asciiart_register_post(ctx->owner, ctx->client_ip, &now);

  chat_history_entry_t entry = {0};
  if (!host_history_record_user(ctx->owner, ctx, ctx->asciiart_buffer, &entry)) {
    session_asciiart_reset(ctx);
    return;
  }

  session_send_history_entry(ctx, &entry);
  chat_room_broadcast_entry(&ctx->owner->room, &entry, ctx);
  host_notify_external_clients(ctx->owner, &entry);

  ctx->last_message_time = now;
  ctx->has_last_message_time = true;

  session_asciiart_reset(ctx);
}

static void session_asciiart_cancel(session_ctx_t *ctx, const char *reason) {
  if (ctx == NULL || !ctx->asciiart_pending) {
    return;
  }

  const bool used_editor = ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART;
  session_asciiart_reset(ctx);
  if (used_editor) {
    session_bbs_reset_pending_post(ctx);
  }
  if (reason != NULL && reason[0] != '\0') {
    session_send_system_line(ctx, reason);
  }
}

static bool session_asciiart_capture_continue(const session_ctx_t *ctx) {
  return ctx != NULL && ctx->asciiart_pending;
}

static bool session_bbs_capture_continue(const session_ctx_t *ctx) {
  return ctx != NULL && ctx->bbs_post_pending;
}

static void session_capture_multiline_text(session_ctx_t *ctx, const char *text, session_text_line_consumer_t consumer,
                                           session_text_continue_predicate_t should_continue) {
  if (ctx == NULL || text == NULL || consumer == NULL || should_continue == NULL) {
    return;
  }

  char line[SSH_CHATTER_MAX_INPUT_LEN];
  size_t line_length = 0U;
  bool emitted = false;

  const char *cursor = text;
  while (*cursor != '\0') {
    char ch = *cursor++;
    if (ch == '\\') {
      char next = *cursor;
      if (next == 'r') {
        ++cursor;
        if (*cursor == '\\' && cursor[1] == 'n') {
          cursor += 2;
        }
        line[line_length] = '\0';
        consumer(ctx, line);
        emitted = true;
        line_length = 0U;
        if (!should_continue(ctx)) {
          return;
        }
        continue;
      }
      if (next == 'n') {
        ++cursor;
        line[line_length] = '\0';
        consumer(ctx, line);
        emitted = true;
        line_length = 0U;
        if (!should_continue(ctx)) {
          return;
        }
        continue;
      }
      if (next == '\\') {
        ++cursor;
        ch = '\\';
      }
    }

    if (ch == '\r') {
      if (*cursor == '\n') {
        ++cursor;
      }
      line[line_length] = '\0';
      consumer(ctx, line);
      emitted = true;
      line_length = 0U;
      if (!should_continue(ctx)) {
        return;
      }
      continue;
    }

    if (ch == '\n') {
      line[line_length] = '\0';
      consumer(ctx, line);
      emitted = true;
      line_length = 0U;
      if (!should_continue(ctx)) {
        return;
      }
      continue;
    }

    if (line_length + 1U < sizeof(line)) {
      line[line_length++] = ch;
    }
  }

  if (line_length > 0U || !emitted) {
    line[line_length] = '\0';
    consumer(ctx, line);
  }
}

static void session_asciiart_capture_text(session_ctx_t *ctx, const char *text) {
  if (ctx == NULL || !ctx->asciiart_pending || text == NULL) {
    return;
  }

  session_capture_multiline_text(ctx, text, session_asciiart_capture_line, session_asciiart_capture_continue);
}

static void session_asciiart_capture_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || !ctx->asciiart_pending) {
    return;
  }

  char trimmed[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(trimmed, sizeof(trimmed), "%s", line != NULL ? line : "");
  trim_whitespace_inplace(trimmed);
  if (session_asciiart_matches_terminator(trimmed)) {
    session_asciiart_commit(ctx);
    return;
  }

  if (ctx->asciiart_line_count >= SSH_CHATTER_ASCIIART_MAX_LINES) {
    session_send_system_line(ctx, "ASCII art line limit reached. Use the terminator to finish.");
    return;
  }

  if (line == NULL) {
    line = "";
  }

  const bool profile_target = ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE;
  const char *full_message =
      profile_target ? "Profile picture buffer is full. Additional text ignored."
                      : "ASCII art buffer is full. Additional text ignored.";
  const char *truncate_message =
      profile_target ? "Line truncated to fit within the profile picture size limit."
                     : "Line truncated to fit within the ASCII art size limit.";

  size_t buffer_capacity = sizeof(ctx->asciiart_buffer);
  if (profile_target && buffer_capacity > USER_DATA_PROFILE_PICTURE_LEN) {
    buffer_capacity = USER_DATA_PROFILE_PICTURE_LEN;
  }

  if (ctx->asciiart_length >= buffer_capacity - 1U) {
    session_send_system_line(ctx, full_message);
    return;
  }

  size_t available = buffer_capacity - ctx->asciiart_length - 1U;
  const size_t newline_cost = ctx->asciiart_length > 0U ? 1U : 0U;
  if (available < newline_cost) {
    session_send_system_line(ctx, full_message);
    return;
  }

  size_t line_length = strlen(line);
  size_t max_line_length = (available > newline_cost) ? (available - newline_cost) : 0U;
  if (line_length > max_line_length) {
    line_length = max_line_length;
    session_send_system_line(ctx, truncate_message);
  }

  if (ctx->asciiart_length > 0U) {
    ctx->asciiart_buffer[ctx->asciiart_length++] = '\n';
  }

  if (line_length > 0U) {
    memcpy(ctx->asciiart_buffer + ctx->asciiart_length, line, line_length);
    ctx->asciiart_length += line_length;
  }

  ctx->asciiart_buffer[ctx->asciiart_length] = '\0';
  ctx->asciiart_line_count += 1U;
}

// Handle the /bbs command entry point.
static void session_handle_bbs(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_bbs_show_dashboard(ctx);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_bbs_show_dashboard(ctx);
    return;
  }

  char *command = working;
  char *rest = NULL;
  for (char *cursor = working; *cursor != '\0'; ++cursor) {
    if (isspace((unsigned char)*cursor)) {
      *cursor = '\0';
      rest = cursor + 1;
      break;
    }
  }
  if (rest != NULL) {
    trim_whitespace_inplace(rest);
  }

  if (strcmp(command, "exit") == 0) {
    ctx->in_bbs_mode = false;
    ctx->bbs_view_active = false;
    ctx->bbs_view_post_id = 0U;
    session_send_system_line(ctx, "Exited BBS mode.");
    return;
  }

  ctx->in_bbs_mode = true;

  const char *canonical_command = session_bbs_subcommand_canonicalize(ctx, command);
  if (canonical_command == NULL) {
    session_send_system_line(ctx, "Unknown /bbs subcommand. Try /bbs for usage.");
    return;
  }

  if (strcmp(canonical_command, "list") == 0) {
    session_bbs_prepare_canvas(ctx);
    session_bbs_list(ctx);
  } else if (strcmp(canonical_command, "read") == 0) {
    if (rest == NULL || rest[0] == '\0') {
      session_bbs_send_usage(ctx, "read", "<id>");
      return;
    }
    uint64_t id = (uint64_t)strtoull(rest, NULL, 10);
    session_bbs_read(ctx, id);
  } else if (strcmp(canonical_command, "topic") == 0) {
    if (rest == NULL || rest[0] == '\0') {
      session_bbs_send_usage(ctx, "topic", "read <tag>");
      return;
    }

    char topic_full[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(topic_full, sizeof(topic_full), "%s", rest);
    trim_whitespace_inplace(topic_full);
    if (topic_full[0] == '\0') {
      session_bbs_send_usage(ctx, "topic", "read <tag>");
      return;
    }

    char topic_args[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(topic_args, sizeof(topic_args), "%s", topic_full);

    char action_token[32];
    size_t action_len = 0U;
    char *cursor = topic_args;
    while (*cursor != '\0' && !isspace((unsigned char)*cursor)) {
      if (action_len + 1U < sizeof(action_token)) {
        action_token[action_len++] = *cursor;
      }
      ++cursor;
    }
    action_token[action_len] = '\0';

    char *remaining = NULL;
    if (*cursor != '\0') {
      *cursor = '\0';
      remaining = cursor + 1;
      trim_whitespace_inplace(remaining);
    }

    if (action_token[0] != '\0') {
      const char *canonical_action = session_bbs_subcommand_canonicalize(ctx, action_token);
      if (canonical_action != NULL && strcmp(canonical_action, "read") == 0) {
        if (remaining == NULL || remaining[0] == '\0') {
          session_bbs_send_usage(ctx, "topic", "read <tag>");
          return;
        }
        session_bbs_prepare_canvas(ctx);
        session_bbs_list_topic(ctx, remaining);
        return;
      }
    }

    session_bbs_prepare_canvas(ctx);
    session_bbs_list_topic(ctx, topic_full);
  } else if (strcmp(canonical_command, "post") == 0) {
    session_bbs_begin_post(ctx, rest);
  } else if (strcmp(canonical_command, "edit") == 0) {
    if (rest == NULL || rest[0] == '\0') {
      session_bbs_send_usage(ctx, "edit", "<id>");
      return;
    }
    uint64_t id = (uint64_t)strtoull(rest, NULL, 10);
    session_bbs_begin_edit(ctx, id);
  } else if (strcmp(canonical_command, "comment") == 0) {
    session_bbs_add_comment(ctx, rest);
  } else if (strcmp(canonical_command, "regen") == 0) {
    if (rest == NULL || rest[0] == '\0') {
      session_bbs_send_usage(ctx, "regen", "<id>");
      return;
    }
    uint64_t id = (uint64_t)strtoull(rest, NULL, 10);
    session_bbs_regen_post(ctx, id);
  } else if (strcmp(canonical_command, "delete") == 0) {
    if (rest == NULL || rest[0] == '\0') {
      session_bbs_send_usage(ctx, "delete", "<id>");
      return;
    }
    uint64_t id = (uint64_t)strtoull(rest, NULL, 10);
    session_bbs_delete(ctx, id);
  } else {
    session_send_system_line(ctx, "Unknown /bbs subcommand. Try /bbs for usage.");
  }
}

static void session_game_seed_rng(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->game.rng_seeded) {
    return;
  }

  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
    ts.tv_sec = time(NULL);
    ts.tv_nsec = 0L;
  }

  uint64_t seed = ((uint64_t)ts.tv_sec << 32) ^ (uint64_t)ts.tv_nsec ^ (uintptr_t)ctx ^ (uintptr_t)ctx->owner;
  if (seed == 0U) {
    seed = UINT64_C(0x9E3779B97F4A7C15);
  }
  ctx->game.rng_state = seed;
  ctx->game.rng_seeded = true;
}

static uint32_t session_game_random(session_ctx_t *ctx) {
  session_game_seed_rng(ctx);
  uint64_t x = ctx->game.rng_state;
  x ^= x >> 12;
  x ^= x << 25;
  x ^= x >> 27;
  ctx->game.rng_state = x;
  uint64_t result = x * UINT64_C(2685821657736338717);
  return (uint32_t)(result >> 32);
}

static int session_game_random_range(session_ctx_t *ctx, int max) {
  if (max <= 0) {
    return 0;
  }
  return (int)(session_game_random(ctx) % (uint32_t)max);
}

static void session_game_tetris_reset(tetris_game_state_t *state) {
  if (state == NULL) {
    return;
  }

  memset(state->board, 0, sizeof(state->board));
  state->current_piece = -1;
  state->rotation = 0;
  state->row = 0;
  state->column = 0;
  state->next_piece = 0;
  state->score = 0U;
  state->lines_cleared = 0U;
  state->game_over = false;
  state->bag_index = 0U;
  for (size_t idx = 0U; idx < 7U; ++idx) {
    state->bag[idx] = (int)idx;
  }
  state->gravity_counter = 0U;
  state->gravity_rate = SSH_CHATTER_TETRIS_GRAVITY_RATE;
  state->gravity_timer_initialized = false;
  state->gravity_timer_last.tv_sec = 0;
  state->gravity_timer_last.tv_nsec = 0;
  state->gravity_timer_accumulator_ns = 0U;
  state->round = 1U;
  state->next_round_line_goal = SSH_CHATTER_TETRIS_LINES_PER_ROUND;
  session_game_tetris_apply_round_settings(state);
  state->input_escape_active = false;
  state->input_escape_length = 0U;
  memset(state->input_escape_buffer, 0, sizeof(state->input_escape_buffer));
}

static void session_game_tetris_apply_round_settings(tetris_game_state_t *state) {
  if (state == NULL) {
    return;
  }

  if (state->round == 0U) {
    state->round = 1U;
  }

  unsigned reduction = state->round > 0U ? state->round - 1U : 0U;
  unsigned base_threshold = SSH_CHATTER_TETRIS_GRAVITY_THRESHOLD;
  unsigned threshold = base_threshold;
  if (reduction >= base_threshold) {
    threshold = 1U;
  } else {
    threshold = base_threshold - reduction;
  }

  if (threshold == 0U) {
    threshold = 1U;
  }

  state->gravity_threshold = threshold;
  state->gravity_counter = 0U;
  state->gravity_timer_initialized = false;
  state->gravity_timer_last.tv_sec = 0;
  state->gravity_timer_last.tv_nsec = 0;
  state->gravity_timer_accumulator_ns = 0U;
}

static void session_game_tetris_fill_bag(session_ctx_t *ctx) {
  tetris_game_state_t *state = &ctx->game.tetris;
  for (size_t idx = 0U; idx < 7U; ++idx) {
    state->bag[idx] = (int)idx;
  }
  for (int idx = 6; idx > 0; --idx) {
    int swap_index = session_game_random_range(ctx, idx + 1);
    int temp = state->bag[idx];
    state->bag[idx] = state->bag[swap_index];
    state->bag[swap_index] = temp;
  }
  state->bag_index = 0U;
}

static int session_game_tetris_take_piece(session_ctx_t *ctx) {
  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->bag_index >= 7U) {
    session_game_tetris_fill_bag(ctx);
  }
  return state->bag[state->bag_index++];
}

static bool session_game_tetris_cell_occupied(int piece, int rotation, int row, int column) {
  if (piece < 0 || piece >= 7) {
    return false;
  }
  rotation = rotation & 3;
  if (row < 0 || row >= SSH_CHATTER_TETROMINO_SIZE || column < 0 || column >= SSH_CHATTER_TETROMINO_SIZE) {
    return false;
  }
  const char *shape = TETROMINO_SHAPES[piece][rotation];
  char value = shape[row * SSH_CHATTER_TETROMINO_SIZE + column];
  return value != '.' && value != '\0';
}

static bool session_game_tetris_position_valid(const tetris_game_state_t *state, int piece, int rotation, int row,
                                              int column) {
  if (state == NULL) {
    return false;
  }
  for (int r = 0; r < SSH_CHATTER_TETROMINO_SIZE; ++r) {
    for (int c = 0; c < SSH_CHATTER_TETROMINO_SIZE; ++c) {
      if (!session_game_tetris_cell_occupied(piece, rotation, r, c)) {
        continue;
      }
      int board_row = row + r;
      int board_col = column + c;
      if (board_col < 0 || board_col >= SSH_CHATTER_TETRIS_WIDTH) {
        return false;
      }
      if (board_row >= SSH_CHATTER_TETRIS_HEIGHT) {
        return false;
      }
      if (board_row < 0) {
        continue;
      }
      if (state->board[board_row][board_col] != 0) {
        return false;
      }
    }
  }
  return true;
}

static bool session_game_tetris_spawn_piece(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }
  tetris_game_state_t *state = &ctx->game.tetris;
  state->current_piece = state->next_piece;
  state->rotation = 0;
  state->row = 0;
  state->column = (SSH_CHATTER_TETRIS_WIDTH / 2) - 2;
  state->gravity_counter = 0U;
  state->gravity_timer_initialized = false;
  state->gravity_timer_accumulator_ns = 0U;
  state->input_escape_active = false;
  state->input_escape_length = 0U;
  state->next_piece = session_game_tetris_take_piece(ctx);
  if (!session_game_tetris_position_valid(state, state->current_piece, state->rotation, state->row, state->column)) {
    state->game_over = true;
    return false;
  }
  return true;
}

static bool session_game_tetris_move(session_ctx_t *ctx, int drow, int dcol) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS) {
    return false;
  }
  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->current_piece < 0) {
    return false;
  }
  int new_row = state->row + drow;
  int new_col = state->column + dcol;
  if (!session_game_tetris_position_valid(state, state->current_piece, state->rotation, new_row, new_col)) {
    return false;
  }
  state->row = new_row;
  state->column = new_col;
  return true;
}

static bool session_game_tetris_soft_drop(session_ctx_t *ctx) {
  if (session_game_tetris_move(ctx, 1, 0)) {
    return true;
  }
  session_game_tetris_lock_piece(ctx);
  return false;
}

static bool session_game_tetris_apply_gravity(session_ctx_t *ctx, unsigned ticks) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return false;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->game_over || ticks == 0U) {
    return false;
  }

  if (state->gravity_threshold == 0U) {
    state->gravity_threshold = SSH_CHATTER_TETRIS_GRAVITY_THRESHOLD;
  }

  bool moved = false;
  state->gravity_counter += ticks;
  while (state->gravity_counter >= state->gravity_threshold) {
    if (!session_game_tetris_soft_drop(ctx)) {
      state->gravity_counter = 0U;
      break;
    }
    moved = true;
    state->gravity_counter -= state->gravity_threshold;
    if (state->game_over) {
      break;
    }
  }
  return moved;
}

typedef enum {
  TETRIS_INPUT_NONE = 0,
  TETRIS_INPUT_MOVE_LEFT,
  TETRIS_INPUT_MOVE_RIGHT,
  TETRIS_INPUT_ROTATE,
  TETRIS_INPUT_SOFT_DROP,
  TETRIS_INPUT_HARD_DROP,
} tetris_input_action_t;

static bool session_game_tetris_update_timer(session_ctx_t *ctx, bool accelerate) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return false;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->game_over) {
    return false;
  }

  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now) != 0) {
    now.tv_sec = time(NULL);
    now.tv_nsec = 0L;
  }

  if (!state->gravity_timer_initialized) {
    state->gravity_timer_last = now;
    state->gravity_timer_initialized = true;
  } else {
    struct timespec last = state->gravity_timer_last;
    state->gravity_timer_last = now;

    time_t sec_delta = now.tv_sec - last.tv_sec;
    long nsec_delta = now.tv_nsec - last.tv_nsec;
    if (nsec_delta < 0L) {
      --sec_delta;
      nsec_delta += 1000000000L;
    }

    if (sec_delta > 0 || nsec_delta > 0L) {
      uint64_t elapsed_ns = (uint64_t)sec_delta * 1000000000ULL + (uint64_t)nsec_delta;
      state->gravity_timer_accumulator_ns += elapsed_ns;
    }
  }

  unsigned ticks = 0U;
  while (state->gravity_timer_accumulator_ns >= SSH_CHATTER_TETRIS_GRAVITY_INTERVAL_NS) {
    state->gravity_timer_accumulator_ns -= SSH_CHATTER_TETRIS_GRAVITY_INTERVAL_NS;
    ticks += state->gravity_rate;
  }

  if (accelerate) {
    ticks += state->gravity_rate + state->gravity_threshold;
  }

  if (ticks == 0U) {
    return false;
  }

  return session_game_tetris_apply_gravity(ctx, ticks);
}

static bool session_game_tetris_process_timeout(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return false;
  }

  bool redraw = session_game_tetris_update_timer(ctx, false);
  if (ctx->game.tetris.game_over) {
    session_game_suspend(ctx, "Game over!");
    return true;
  }

  if (redraw) {
    session_game_tetris_render(ctx);
  }
  return redraw;
}

static bool session_game_tetris_process_action(session_ctx_t *ctx, int action_value) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return false;
  }

  tetris_input_action_t action = (tetris_input_action_t)action_value;
  if (action == TETRIS_INPUT_NONE) {
    return false;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->game_over) {
    session_game_suspend(ctx, "Game over!");
    return true;
  }

  bool redraw = session_game_tetris_update_timer(ctx, false);
  if (state->game_over) {
    session_game_suspend(ctx, "Game over!");
    return true;
  }

  bool accelerate = false;
  bool manual_drop = false;

  switch (action) {
    case TETRIS_INPUT_MOVE_LEFT:
      if (session_game_tetris_move(ctx, 0, -1)) {
        redraw = true;
      }
      break;
    case TETRIS_INPUT_MOVE_RIGHT:
      if (session_game_tetris_move(ctx, 0, 1)) {
        redraw = true;
      }
      break;
    case TETRIS_INPUT_ROTATE:
      if (session_game_tetris_rotate(ctx)) {
        redraw = true;
      }
      break;
    case TETRIS_INPUT_SOFT_DROP:
      accelerate = true;
      break;
    case TETRIS_INPUT_HARD_DROP:
      while (session_game_tetris_soft_drop(ctx)) {
        redraw = true;
      }
      manual_drop = true;
      break;
    case TETRIS_INPUT_NONE:
    default:
      break;
  }

  if (state->game_over) {
    session_game_suspend(ctx, "Game over!");
    return true;
  }

  if (accelerate) {
    if (session_game_tetris_update_timer(ctx, true)) {
      redraw = true;
    }
  } else if (!manual_drop) {
    if (session_game_tetris_update_timer(ctx, false)) {
      redraw = true;
    }
  }

  if (state->game_over) {
    session_game_suspend(ctx, "Game over!");
    return true;
  }

  if (redraw) {
    session_game_tetris_render(ctx);
  }

  return true;
}

static bool session_game_tetris_process_raw_input(session_ctx_t *ctx, char ch) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return false;
  }

  tetris_game_state_t *state = &ctx->game.tetris;

  if (ch == 0x01 || ch == 0x03 || ch == 0x1a || ch == 0x13) {
    return false;
  }

  if (state->input_escape_active) {
    if (state->input_escape_length < sizeof(state->input_escape_buffer)) {
      state->input_escape_buffer[state->input_escape_length++] = ch;
    }

    if (state->input_escape_length == 2U && state->input_escape_buffer[1] == '[') {
      return true;
    }

    if (state->input_escape_length >= 3U && state->input_escape_buffer[1] == '[') {
      char final = state->input_escape_buffer[state->input_escape_length - 1U];
      tetris_input_action_t action = TETRIS_INPUT_NONE;
      if (final == 'A') {
        action = TETRIS_INPUT_ROTATE;
      } else if (final == 'B') {
        action = TETRIS_INPUT_SOFT_DROP;
      } else if (final == 'C') {
        action = TETRIS_INPUT_MOVE_RIGHT;
      } else if (final == 'D') {
        action = TETRIS_INPUT_MOVE_LEFT;
      }
      state->input_escape_active = false;
      state->input_escape_length = 0U;
      if (action != TETRIS_INPUT_NONE) {
        session_game_tetris_process_action(ctx, action);
      }
      return true;
    }

    state->input_escape_active = false;
    state->input_escape_length = 0U;
    return true;
  }

  if (ch == 0x1b) {
    state->input_escape_active = true;
    state->input_escape_length = 0U;
    state->input_escape_buffer[state->input_escape_length++] = ch;
    return true;
  }

  if (ch == '\r' || ch == '\n') {
    return true;
  }

  if (ch == 0x12) {
    session_game_tetris_process_action(ctx, TETRIS_INPUT_ROTATE);
    return true;
  }

  unsigned char lowered = (unsigned char)ch;
  if (lowered >= 'A' && lowered <= 'Z') {
    lowered = (unsigned char)tolower(lowered);
  }

  switch (lowered) {
    case 'a':
      session_game_tetris_process_action(ctx, TETRIS_INPUT_MOVE_LEFT);
      return true;
    case 'd':
      session_game_tetris_process_action(ctx, TETRIS_INPUT_MOVE_RIGHT);
      return true;
    case 'w':
      session_game_tetris_process_action(ctx, TETRIS_INPUT_ROTATE);
      return true;
    case 's':
      session_game_tetris_process_action(ctx, TETRIS_INPUT_SOFT_DROP);
      return true;
    case ' ':
      session_game_tetris_process_action(ctx, TETRIS_INPUT_HARD_DROP);
      return true;
    default:
      break;
  }

  if ((unsigned char)ch < 0x20U) {
    return false;
  }

  return true;
}

static bool session_game_tetris_rotate(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS) {
    return false;
  }
  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->current_piece < 0) {
    return false;
  }
  int new_rotation = (state->rotation + 1) & 3;
  if (!session_game_tetris_position_valid(state, state->current_piece, new_rotation, state->row, state->column)) {
    return false;
  }
  state->rotation = new_rotation;
  return true;
}

static void session_game_tetris_clear_lines(session_ctx_t *ctx, unsigned *cleared) {
  if (ctx == NULL) {
    if (cleared != NULL) {
      *cleared = 0U;
    }
    return;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  unsigned removed = 0U;
  for (int row = 0; row < SSH_CHATTER_TETRIS_HEIGHT; ++row) {
    bool full = true;
    for (int col = 0; col < SSH_CHATTER_TETRIS_WIDTH; ++col) {
      if (state->board[row][col] == 0) {
        full = false;
        break;
      }
    }
    if (!full) {
      continue;
    }
    ++removed;
    for (int move_row = row; move_row > 0; --move_row) {
      for (int move_col = 0; move_col < SSH_CHATTER_TETRIS_WIDTH; ++move_col) {
        state->board[move_row][move_col] = state->board[move_row - 1][move_col];
      }
    }
    for (int move_col = 0; move_col < SSH_CHATTER_TETRIS_WIDTH; ++move_col) {
      state->board[0][move_col] = 0;
    }
  }
  if (cleared != NULL) {
    *cleared = removed;
  }
}

static void session_game_tetris_handle_round_progress(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS) {
    return;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  while (state->round < SSH_CHATTER_TETRIS_MAX_ROUNDS && state->lines_cleared >= state->next_round_line_goal) {
    state->round += 1U;
    state->next_round_line_goal += SSH_CHATTER_TETRIS_LINES_PER_ROUND;
    session_game_tetris_apply_round_settings(state);

    char announcement[SSH_CHATTER_MESSAGE_LIMIT];
    if (state->round >= SSH_CHATTER_TETRIS_MAX_ROUNDS) {
      snprintf(announcement, sizeof(announcement), "Round %u reached! Gravity is at maximum speed.", state->round);
    } else {
      snprintf(announcement, sizeof(announcement), "Round %u reached! Blocks will fall faster.", state->round);
    }
    bool previous_translation_suppress = ctx->translation_suppress_output;
    ctx->translation_suppress_output = true;
    session_send_system_line(ctx, announcement);
    ctx->translation_suppress_output = previous_translation_suppress;
  }
}

static void session_game_tetris_lock_piece(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS) {
    return;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->current_piece < 0) {
    return;
  }

  for (int r = 0; r < SSH_CHATTER_TETROMINO_SIZE; ++r) {
    for (int c = 0; c < SSH_CHATTER_TETROMINO_SIZE; ++c) {
      if (!session_game_tetris_cell_occupied(state->current_piece, state->rotation, r, c)) {
        continue;
      }
      int board_row = state->row + r;
      int board_col = state->column + c;
      if (board_row < 0 || board_row >= SSH_CHATTER_TETRIS_HEIGHT || board_col < 0 || board_col >= SSH_CHATTER_TETRIS_WIDTH) {
        continue;
      }
      state->board[board_row][board_col] = state->current_piece + 1;
    }
  }

  unsigned cleared = 0U;
  session_game_tetris_clear_lines(ctx, &cleared);
  if (cleared > 0U) {
    state->lines_cleared += cleared;
    state->score += cleared * 100U;
    session_game_tetris_handle_round_progress(ctx);
  }

  if (!session_game_tetris_spawn_piece(ctx)) {
    state->game_over = true;
  }
}

static void session_game_tetris_render(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS) {
    return;
  }

  bool previous_translation_suppress = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;

  tetris_game_state_t *state = &ctx->game.tetris;
  session_render_separator(ctx, "Tetris");

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  char next_char = TETROMINO_DISPLAY_CHARS[state->next_piece % 7];
  if (state->round < SSH_CHATTER_TETRIS_MAX_ROUNDS) {
    unsigned lines_remaining = 0U;
    if (state->next_round_line_goal > state->lines_cleared) {
      lines_remaining = state->next_round_line_goal - state->lines_cleared;
    }
    snprintf(header, sizeof(header), "Score: %u   Lines: %u   Round: %u/%u (next in %u)   Next: %c", state->score,
             state->lines_cleared, state->round, SSH_CHATTER_TETRIS_MAX_ROUNDS, lines_remaining, next_char);
  } else {
    snprintf(header, sizeof(header), "Score: %u   Lines: %u   Round: %u/%u (max speed)   Next: %c", state->score,
             state->lines_cleared, state->round, SSH_CHATTER_TETRIS_MAX_ROUNDS, next_char);
  }
  session_send_system_line(ctx, header);
  session_send_system_line(ctx, "Controls: left, right, down, Ctrl+R or up: rotate, drop. Blank line = down.");

  char border[SSH_CHATTER_TETRIS_WIDTH + 3];
  border[0] = '+';
  for (int col = 0; col < SSH_CHATTER_TETRIS_WIDTH; ++col) {
    border[col + 1] = '-';
  }
  border[SSH_CHATTER_TETRIS_WIDTH + 1] = '+';
  border[SSH_CHATTER_TETRIS_WIDTH + 2] = '\0';
  session_send_system_line(ctx, border);

  for (int row = 0; row < SSH_CHATTER_TETRIS_HEIGHT; ++row) {
    char line_buffer[SSH_CHATTER_TETRIS_WIDTH + 3];
    line_buffer[0] = '|';
    for (int col = 0; col < SSH_CHATTER_TETRIS_WIDTH; ++col) {
      char cell = ' ';
      if (state->board[row][col] != 0) {
        int index = state->board[row][col] - 1;
        if (index < 0 || index >= 7) {
          index = 0;
        }
        cell = TETROMINO_DISPLAY_CHARS[index];
      } else if (!state->game_over && state->current_piece >= 0) {
        int local_row = row - state->row;
        int local_col = col - state->column;
        if (local_row >= 0 && local_row < SSH_CHATTER_TETROMINO_SIZE && local_col >= 0 &&
            local_col < SSH_CHATTER_TETROMINO_SIZE &&
            session_game_tetris_cell_occupied(state->current_piece, state->rotation, local_row, local_col)) {
          cell = TETROMINO_DISPLAY_CHARS[state->current_piece];
        }
      }
      line_buffer[col + 1] = cell;
    }
    line_buffer[SSH_CHATTER_TETRIS_WIDTH + 1] = '|';
    line_buffer[SSH_CHATTER_TETRIS_WIDTH + 2] = '\0';
    session_send_system_line(ctx, line_buffer);
  }

  session_send_system_line(ctx, border);

  ctx->translation_suppress_output = previous_translation_suppress;
}

static void session_game_tetris_handle_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_TETRIS || !ctx->game.active) {
    return;
  }

  tetris_game_state_t *state = &ctx->game.tetris;
  if (state->game_over) {
    session_game_suspend(ctx, "Game over!");
    return;
  }

  bool previous_translation_suppress = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;

  char command[32];
  if (line == NULL) {
    command[0] = '\0';
  } else {
    size_t copy_len = strnlen(line, sizeof(command) - 1U);
    memcpy(command, line, copy_len);
    command[copy_len] = '\0';
  }
  trim_whitespace_inplace(command);
  for (size_t idx = 0U; command[idx] != '\0'; ++idx) {
    command[idx] = (char)tolower((unsigned char)command[idx]);
  }

  if (command[0] == '\0') {
    session_game_tetris_process_timeout(ctx);
    goto cleanup;
  }

  if (strcmp(command, "help") == 0) {
    session_send_system_line(ctx,
                             "Tetris controls: WASD or arrow keys move (W/Up rotate, S/Down soft drop, A/Left, D/Right),"
                             " space for a hard drop, and Ctrl+R also rotates. Ctrl+Z or /suspend! exits.");
    goto cleanup;
  }

  if (strcmp(command, "drop") == 0) {
    session_game_tetris_process_action(ctx, TETRIS_INPUT_HARD_DROP);
    goto cleanup;
  }

  session_send_system_line(ctx, "Use WASD or the arrow keys for control. Type help for a summary.");

cleanup:
  ctx->translation_suppress_output = previous_translation_suppress;
}

static void session_game_start_tetris(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_game_tetris_reset(&ctx->game.tetris);
  session_game_seed_rng(ctx);
  session_game_tetris_fill_bag(ctx);
  ctx->game.tetris.next_piece = session_game_tetris_take_piece(ctx);
  ctx->game.type = SESSION_GAME_TETRIS;
  ctx->game.active = true;
  ctx->game.tetris.game_over = false;
  bool previous_translation_suppress = ctx->translation_suppress_output;
  if (!session_game_tetris_spawn_piece(ctx)) {
    ctx->translation_suppress_output = true;
    session_send_system_line(ctx, "Unable to start Tetris right now.");
    ctx->translation_suppress_output = previous_translation_suppress;
    ctx->game.active = false;
    ctx->game.type = SESSION_GAME_NONE;
    return;
  }

  ctx->translation_suppress_output = true;

  session_send_system_line(ctx,
                           "Tetris started. Pieces fall on their own — use WASD or the arrow keys (W/Up rotate, S/Down soft"
                           " drop, A/Left, D/Right), space for a hard drop, and Ctrl+R to rotate. Ctrl+Z or /suspend! exits.");
  char round_message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(round_message, sizeof(round_message), "Round 1/%u: Clear %u lines to reach the next round.",
           SSH_CHATTER_TETRIS_MAX_ROUNDS, SSH_CHATTER_TETRIS_LINES_PER_ROUND);
  session_send_system_line(ctx, round_message);
  session_game_tetris_render(ctx);

  ctx->translation_suppress_output = previous_translation_suppress;
}

static void session_game_start_liargame(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  ctx->game.type = SESSION_GAME_LIARGAME;
  ctx->game.active = true;
  ctx->game.liar.round_number = 0U;
  ctx->game.liar.score = 0U;
  ctx->game.liar.awaiting_guess = false;
  session_send_system_line(ctx, "Liar Game started. Guess which statement is the lie by typing 1, 2, or 3.");
  session_game_liar_present_round(ctx);
}

static void session_game_liar_present_round(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_LIARGAME || !ctx->game.active) {
    return;
  }

  size_t prompt_count = sizeof(LIAR_PROMPTS) / sizeof(LIAR_PROMPTS[0]);
  if (prompt_count == 0U) {
    session_game_suspend(ctx, "No prompts available for the liar game.");
    return;
  }

  unsigned index = (unsigned)session_game_random_range(ctx, (int)prompt_count);
  ctx->game.liar.current_prompt_index = index;
  ctx->game.liar.liar_index = LIAR_PROMPTS[index].liar_index % 3U;
  ctx->game.liar.round_number += 1U;
  ctx->game.liar.awaiting_guess = true;

  session_render_separator(ctx, "Liar Game");
  char header[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(header, sizeof(header), "Round %u — which statement is the lie?", ctx->game.liar.round_number);
  session_send_system_line(ctx, header);

  const liar_prompt_t *prompt = &LIAR_PROMPTS[index];
  for (int i = 0; i < 3; ++i) {
    char line_buffer[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line_buffer, sizeof(line_buffer), "%d. %s", i + 1, prompt->statements[i]);
    session_send_system_line(ctx, line_buffer);
  }
  session_send_system_line(ctx, "Enter 1, 2, or 3 to choose. Type 'help' for options.");
}

static void session_game_liar_handle_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_LIARGAME || !ctx->game.active) {
    return;
  }

  liar_game_state_t *state = &ctx->game.liar;
  char command[32];
  if (line == NULL) {
    command[0] = '\0';
  } else {
    size_t copy_len = strnlen(line, sizeof(command) - 1U);
    memcpy(command, line, copy_len);
    command[copy_len] = '\0';
  }
  trim_whitespace_inplace(command);
  for (size_t idx = 0U; command[idx] != '\0'; ++idx) {
    command[idx] = (char)tolower((unsigned char)command[idx]);
  }

  if (strcmp(command, "help") == 0) {
    session_send_system_line(ctx, "Type 1, 2, or 3 to guess the lie. /suspend! exits the game.");
    return;
  }

  if (command[0] == '\0') {
    session_send_system_line(ctx, "Pick a statement number between 1 and 3.");
    return;
  }

  if (!state->awaiting_guess) {
    session_game_liar_present_round(ctx);
    return;
  }

  char *endptr = NULL;
  long value = strtol(command, &endptr, 10);
  if (endptr == command || value < 1L || value > 3L) {
    session_send_system_line(ctx, "Please enter 1, 2, or 3 to choose the lie.");
    return;
  }

  unsigned guess = (unsigned)(value - 1L);
  const liar_prompt_t *prompt = &LIAR_PROMPTS[state->current_prompt_index];
  if (guess == state->liar_index) {
    ++state->score;
    session_send_system_line(ctx, "Correct! That statement was the lie.");
  } else {
    char reveal[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(reveal, sizeof(reveal), "Nope! The lie was #%u: %s", state->liar_index + 1U,
             prompt->statements[state->liar_index]);
    session_send_system_line(ctx, reveal);
  }

  state->awaiting_guess = false;
  session_game_liar_present_round(ctx);
}

static void session_game_alpha_add_gravity_source(alpha_centauri_game_state_t *state, int x, int y, double mu,
                                                  int influence_radius, char symbol, const char *name) {
  if (state == NULL || state->gravity_source_count >= ALPHA_MAX_GRAVITY_SOURCES) {
    return;
  }

  if (x < 0) {
    x = 0;
  } else if (x >= ALPHA_NAV_WIDTH) {
    x = ALPHA_NAV_WIDTH - 1;
  }

  if (y < 0) {
    y = 0;
  } else if (y >= ALPHA_NAV_HEIGHT) {
    y = ALPHA_NAV_HEIGHT - 1;
  }

  alpha_gravity_source_t *source = &state->gravity_sources[state->gravity_source_count++];
  source->x = x;
  source->y = y;
  source->mu = mu >= 0.0 ? mu : 0.0;
  source->influence_radius = influence_radius > 0 ? influence_radius : 0;
  source->symbol = symbol;
  if (name != NULL) {
    snprintf(source->name, sizeof(source->name), "%s", name);
  } else {
    source->name[0] = '\0';
  }
}

static void session_game_alpha_configure_gravity(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;

  for (unsigned idx = 0U; idx < ALPHA_MAX_GRAVITY_SOURCES; ++idx) {
    state->gravity_sources[idx] = (alpha_gravity_source_t){0};
  }
  state->gravity_source_count = 0U;

  double stage_multiplier = 1.0 + (double)state->stage * 0.45;
  if (state->stage >= 4U) {
    stage_multiplier += (double)state->waypoint_index * 0.35;
    if (state->awaiting_flag) {
      stage_multiplier += 0.75;
    }
  }
  const char *hole_name = state->stage >= 3 ? "Proxima Abyss" : "Core Singularity";
  unsigned special_sources = 0U;
  if (state->stage == 4U) {
    if (!state->eva_ready || state->final_waypoint.symbol == '\0') {
      session_game_alpha_plan_waypoints(ctx);
    }
    if (!state->eva_ready) {
      special_sources += state->waypoint_count;
    }
    if (state->final_waypoint.symbol != '\0') {
      ++special_sources;
    }
  }
  double hole_mu = ALPHA_BLACK_HOLE_MU * session_game_alpha_random_double(ctx, stage_multiplier,
                                                                          stage_multiplier + 1.0);
  session_game_alpha_place_random_source(ctx, state, ALPHA_NAV_MARGIN, hole_mu, ALPHA_NAV_MARGIN * 3, 'B', hole_name);

  int star_count = 2 + (int)state->stage;
  if (state->stage >= 2U) {
    star_count += 1;
  }
  int planet_count = 1 + (int)((state->stage + 1U) / 2U);
  int debris_count = 1 + (int)state->stage * 2;
  if (state->stage >= 3U) {
    debris_count += 1;
  }
  if (state->stage >= 4U) {
    planet_count = 0;
    debris_count += (int)state->waypoint_index;
    if (state->awaiting_flag) {
      debris_count += 2;
    }
  }

  int available_slots = (int)ALPHA_MAX_GRAVITY_SOURCES - 1 - (int)special_sources;
  if (available_slots < 0) {
    available_slots = 0;
  }
  if (star_count > available_slots) {
    star_count = available_slots;
  }
  available_slots -= star_count;
  if (available_slots < 0) {
    available_slots = 0;
  }
  if (planet_count > available_slots) {
    planet_count = available_slots;
  }
  available_slots -= planet_count;
  if (available_slots < 0) {
    available_slots = 0;
  }
  if (debris_count > available_slots) {
    debris_count = available_slots;
  }

  for (int idx = 0; idx < star_count; ++idx) {
    const char *name = kAlphaStarCatalog[session_game_random_range(ctx, (int)ALPHA_STAR_CATALOG_COUNT)];
    double mu = ALPHA_STAR_MU * session_game_alpha_random_double(ctx, stage_multiplier * 0.7, stage_multiplier * 1.4);
    session_game_alpha_place_random_source(ctx, state, ALPHA_NAV_MARGIN / 2, mu, ALPHA_NAV_MARGIN * 2, 'S', name);
  }

  for (int idx = 0; idx < planet_count; ++idx) {
    const char *name = kAlphaPlanetCatalog[session_game_random_range(ctx, (int)ALPHA_PLANET_CATALOG_COUNT)];
    double mu = ALPHA_PLANET_MU * session_game_alpha_random_double(ctx, stage_multiplier * 0.8, stage_multiplier * 1.6);
    session_game_alpha_place_random_source(ctx, state, ALPHA_NAV_MARGIN / 2, mu, ALPHA_NAV_MARGIN * 2, 'P', name);
  }

  for (int idx = 0; idx < debris_count; ++idx) {
    const char *name = kAlphaDebrisCatalog[session_game_random_range(ctx, (int)ALPHA_DEBRIS_CATALOG_COUNT)];
    double mu = ALPHA_DEBRIS_MU * session_game_alpha_random_double(ctx, 0.7, 2.1) * stage_multiplier;
    session_game_alpha_place_random_source(ctx, state, ALPHA_NAV_MARGIN / 3, mu, ALPHA_NAV_MARGIN, 'D', name);
  }

  if (state->stage == 4U) {
    if (!state->eva_ready) {
      for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
        const alpha_waypoint_t *waypoint = &state->waypoints[idx];
        session_game_alpha_add_gravity_source(state, waypoint->x, waypoint->y, ALPHA_PLANET_MU,
                                              ALPHA_NAV_MARGIN * 2, waypoint->symbol, waypoint->name);
      }
    }
    if (state->final_waypoint.symbol != '\0') {
      session_game_alpha_add_gravity_source(state, state->final_waypoint.x, state->final_waypoint.y, ALPHA_PLANET_MU,
                                            ALPHA_NAV_MARGIN * 2, state->final_waypoint.symbol, state->final_waypoint.name);
    }
  }
}

static void session_game_alpha_apply_gravity(alpha_centauri_game_state_t *state) {
  if (state == NULL || state->gravity_source_count == 0U) {
    return;
  }

  double fx = state->nav_fx;
  double fy = state->nav_fy;
  double ax = 0.0;
  double ay = 0.0;

  for (unsigned idx = 0U; idx < state->gravity_source_count; ++idx) {
    const alpha_gravity_source_t *source = &state->gravity_sources[idx];
    if (source->mu <= 0.0) {
      continue;
    }

    double dx = (double)source->x - fx;
    double dy = (double)source->y - fy;
    double distance_sq = (dx * dx) + (dy * dy);
    double distance = sqrt(distance_sq);
    if (distance < ALPHA_GRAVITY_MIN_DISTANCE) {
      distance = ALPHA_GRAVITY_MIN_DISTANCE;
    }

    double radius = source->influence_radius > 0 ? (double)source->influence_radius : (double)ALPHA_NAV_MARGIN;
    double attenuation = 1.0;
    if (radius > 0.0) {
      double normalized = distance / radius;
      if (normalized > 1.0) {
        attenuation = 1.0 / (normalized * normalized);
      }
    }

    double force = (source->mu * attenuation) / (distance * distance);
    if (force <= 0.0) {
      continue;
    }

    ax += force * (dx / distance);
    ay += force * (dy / distance);
  }

  double accel_magnitude = hypot(ax, ay);
  if (accel_magnitude > ALPHA_GRAVITY_MAX_ACCEL && accel_magnitude > 0.0) {
    double accel_scale = ALPHA_GRAVITY_MAX_ACCEL / accel_magnitude;
    ax *= accel_scale;
    ay *= accel_scale;
  }

  state->nav_vx = (state->nav_vx + ax) * ALPHA_GRAVITY_DAMPING;
  state->nav_vy = (state->nav_vy + ay) * ALPHA_GRAVITY_DAMPING;

  double speed = hypot(state->nav_vx, state->nav_vy);
  if (speed > ALPHA_NAV_MAX_SPEED && speed > 0.0) {
    double speed_scale = ALPHA_NAV_MAX_SPEED / speed;
    state->nav_vx *= speed_scale;
    state->nav_vy *= speed_scale;
  }

  state->nav_fx += state->nav_vx;
  state->nav_fy += state->nav_vy;

  double max_x = (double)(ALPHA_NAV_WIDTH - 1);
  double max_y = (double)(ALPHA_NAV_HEIGHT - 1);

  if (state->nav_fx < 0.0) {
    state->nav_fx = 0.0;
    state->nav_vx = 0.0;
  } else if (state->nav_fx > max_x) {
    state->nav_fx = max_x;
    state->nav_vx = 0.0;
  }

  if (state->nav_fy < 0.0) {
    state->nav_fy = 0.0;
    state->nav_vy = 0.0;
  } else if (state->nav_fy > max_y) {
    state->nav_fy = max_y;
    state->nav_vy = 0.0;
  }

  long rounded_x = lround(state->nav_fx);
  long rounded_y = lround(state->nav_fy);
  if (rounded_x < 0) {
    rounded_x = 0;
  } else if (rounded_x > (long)(ALPHA_NAV_WIDTH - 1)) {
    rounded_x = (long)(ALPHA_NAV_WIDTH - 1);
  }
  if (rounded_y < 0) {
    rounded_y = 0;
  } else if (rounded_y > (long)(ALPHA_NAV_HEIGHT - 1)) {
    rounded_y = (long)(ALPHA_NAV_HEIGHT - 1);
  }

  state->nav_x = (int)rounded_x;
  state->nav_y = (int)rounded_y;
}

static void session_game_alpha_prepare_navigation(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  int safe_margin = ALPHA_NAV_MARGIN;

  unsigned stage_level = state->stage;
  if (stage_level > 0U) {
    int shrink = (int)stage_level;
    if (stage_level >= 2U) {
      shrink += 1;
    }
    if (stage_level >= 3U) {
      shrink += 1;
    }
    if (stage_level >= 4U) {
      shrink += (int)state->waypoint_index;
      if (state->awaiting_flag) {
        shrink += 2;
      }
    }
    safe_margin -= shrink;
    if (safe_margin < 2) {
      safe_margin = 2;
    }
  }

  state->nav_stable_ticks = 0U;
  state->nav_required_ticks = 1U;
  state->nav_vx = 0.0;
  state->nav_vy = 0.0;

  switch (state->stage) {
    case 0:
      state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_y = ALPHA_NAV_HEIGHT - 1 - session_game_random_range(ctx, safe_margin + 4);
      if (state->nav_y < safe_margin) {
        state->nav_y = safe_margin;
      }
      state->nav_target_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_target_y = session_game_random_range(ctx, safe_margin + 4);
      state->nav_required_ticks = 1U;
      break;
    case 1:
      state->nav_x = session_game_random_range(ctx, (ALPHA_NAV_WIDTH / 2)) + safe_margin;
      if (state->nav_x >= ALPHA_NAV_WIDTH) {
        state->nav_x = ALPHA_NAV_WIDTH - 1;
      }
      state->nav_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      state->nav_target_x = ALPHA_NAV_WIDTH - 1 - session_game_random_range(ctx, safe_margin + 5);
      state->nav_target_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      state->nav_required_ticks = 1U;
      break;
    case 2:
      state->nav_x = ALPHA_NAV_WIDTH - 1 - session_game_random_range(ctx, safe_margin + 5);
      state->nav_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      state->nav_target_x = session_game_random_range(ctx, safe_margin + 5);
      state->nav_target_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      state->nav_required_ticks = 1U;
      break;
    case 3:
      state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_y = session_game_random_range(ctx, safe_margin + 5);
      state->nav_target_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_target_y = ALPHA_NAV_HEIGHT - 1 - session_game_random_range(ctx, safe_margin + 5);
      state->nav_required_ticks = 1U;
      break;
    case 4:
      if (!state->eva_ready) {
        session_game_alpha_plan_waypoints(ctx);
        if (state->waypoint_count == 0U) {
          state->nav_target_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
          state->nav_target_y = session_game_random_range(ctx, safe_margin + 5);
        } else {
          if (state->waypoint_index >= state->waypoint_count) {
            state->waypoint_index = state->waypoint_count - 1U;
          }
          const alpha_waypoint_t *waypoint = &state->waypoints[state->waypoint_index];
          state->nav_target_x = waypoint->x;
          state->nav_target_y = waypoint->y;
        }
        state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
        state->nav_y = session_game_random_range(ctx, safe_margin + 5);
        state->nav_required_ticks = 1U;
      } else if (state->awaiting_flag) {
        if (state->final_waypoint.symbol == '\0') {
          session_game_alpha_plan_waypoints(ctx);
        }
        state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
        state->nav_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
        state->nav_target_x = state->final_waypoint.x;
        state->nav_target_y = state->final_waypoint.y;
        state->nav_required_ticks = 1U;
      } else {
        state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
        state->nav_y = ALPHA_NAV_HEIGHT - 1 - session_game_random_range(ctx, safe_margin + 3);
        state->nav_target_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
        state->nav_target_y = session_game_random_range(ctx, safe_margin + 3);
        state->nav_required_ticks = 1U;
      }
      break;
    default:
      state->nav_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      state->nav_target_x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, safe_margin);
      state->nav_target_y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, safe_margin);
      break;
  }

  if (state->nav_target_x < 0) {
    state->nav_target_x = 0;
  } else if (state->nav_target_x >= ALPHA_NAV_WIDTH) {
    state->nav_target_x = ALPHA_NAV_WIDTH - 1;
  }
  if (state->nav_target_y < 0) {
    state->nav_target_y = 0;
  } else if (state->nav_target_y >= ALPHA_NAV_HEIGHT) {
    state->nav_target_y = ALPHA_NAV_HEIGHT - 1;
  }

  if (state->nav_x < 0) {
    state->nav_x = 0;
  } else if (state->nav_x >= ALPHA_NAV_WIDTH) {
    state->nav_x = ALPHA_NAV_WIDTH - 1;
  }
  if (state->nav_y < 0) {
    state->nav_y = 0;
  } else if (state->nav_y >= ALPHA_NAV_HEIGHT) {
    state->nav_y = ALPHA_NAV_HEIGHT - 1;
  }

  if (state->nav_x == state->nav_target_x && state->nav_y == state->nav_target_y) {
    if (state->stage == 4U) {
      state->nav_x = (state->nav_target_x + ALPHA_NAV_MARGIN) % ALPHA_NAV_WIDTH;
      state->nav_y = (state->nav_target_y + ALPHA_NAV_MARGIN) % ALPHA_NAV_HEIGHT;
      state->nav_fx = (double)state->nav_x;
      state->nav_fy = (double)state->nav_y;
    } else {
      state->nav_target_x = (state->nav_target_x + (ALPHA_NAV_WIDTH / 2)) % ALPHA_NAV_WIDTH;
      state->nav_target_y = (state->nav_target_y + (ALPHA_NAV_HEIGHT / 2)) % ALPHA_NAV_HEIGHT;
    }
  }

  state->nav_fx = (double)state->nav_x;
  state->nav_fy = (double)state->nav_y;

  session_game_alpha_configure_gravity(ctx);
}

static void session_game_alpha_reroll_navigation(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  session_send_system_line(ctx, "Mission control: Recomputing the navigation solution...");
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_reset(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  *state = (alpha_centauri_game_state_t){0};
  state->stage = 0U;
  state->velocity_fraction_c = 0.0;
  state->distance_travelled_ly = 0.0;
  state->distance_remaining_ly = ALPHA_TOTAL_DISTANCE_LY;
  state->fuel_percent = 100.0;
  state->oxygen_days = 730.0;
  state->mission_time_years = 0.0;
  state->radiation_msv = 0.0;
  state->active = false;
  state->eva_ready = false;
  state->awaiting_flag = false;
  session_game_alpha_prepare_navigation(ctx);
}

static void session_game_alpha_sync_from_save(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  session_game_alpha_reset(ctx);

  if (!session_user_data_load(ctx)) {
    return;
  }

  const alpha_centauri_save_t *save = &ctx->user_data.alpha;
  if (!save->active) {
    return;
  }

  state->active = true;
  state->stage = save->stage <= 4U ? save->stage : 0U;
  state->eva_ready = save->eva_ready != 0U;
  state->awaiting_flag = save->awaiting_flag != 0U;
  state->velocity_fraction_c = save->velocity_fraction_c;
  state->distance_travelled_ly = save->distance_travelled_ly;
  state->distance_remaining_ly = save->distance_remaining_ly;
  if (state->distance_remaining_ly < 0.0) {
    state->distance_remaining_ly = 0.0;
  }
  state->fuel_percent = save->fuel_percent;
  state->oxygen_days = save->oxygen_days;
  state->mission_time_years = save->mission_time_years;
  state->radiation_msv = save->radiation_msv;
  session_game_alpha_prepare_navigation(ctx);
}

static void session_game_alpha_sync_to_save(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (!session_user_data_load(ctx)) {
    return;
  }

  alpha_centauri_save_t *save = &ctx->user_data.alpha;
  const alpha_centauri_game_state_t *state = &ctx->game.alpha;
  save->active = state->active ? 1U : 0U;
  save->stage = (uint8_t)(state->stage <= 4U ? state->stage : 0U);
  save->eva_ready = state->eva_ready ? 1U : 0U;
  save->awaiting_flag = state->awaiting_flag ? 1U : 0U;
  save->velocity_fraction_c = state->velocity_fraction_c;
  save->distance_travelled_ly = state->distance_travelled_ly;
  save->distance_remaining_ly = state->distance_remaining_ly;
  save->fuel_percent = state->fuel_percent;
  save->oxygen_days = state->oxygen_days;
  save->mission_time_years = state->mission_time_years;
  save->radiation_msv = state->radiation_msv;
  session_user_data_commit(ctx);
}

static void session_game_alpha_report_state(session_ctx_t *ctx, const char *label) {
  if (ctx == NULL) {
    return;
  }

  const alpha_centauri_game_state_t *state = &ctx->game.alpha;
  bool previous_translation = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;

  if (label != NULL && label[0] != '\0') {
    session_send_system_line(ctx, label);
  }

  double velocity_kms = state->velocity_fraction_c * ALPHA_SPEED_OF_LIGHT_MPS / 1000.0;
  double distance_au = state->distance_remaining_ly * ALPHA_LY_TO_AU;

  char line[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(line, sizeof(line),
           "Velocity: %.2f%% c (%.0f km/s) | Fuel %.1f%% | Radiation %.1f mSv",
           state->velocity_fraction_c * 100.0, velocity_kms, state->fuel_percent, state->radiation_msv);
  session_send_system_line(ctx, line);

  snprintf(line, sizeof(line),
           "Distance remaining: %.2f ly (%.0f AU) | Oxygen %.0f days | Mission clock %.2f years",
           state->distance_remaining_ly, distance_au, state->oxygen_days, state->mission_time_years);
  session_send_system_line(ctx, line);

  ctx->translation_suppress_output = previous_translation;
}

static const char *session_game_alpha_phase_label(const alpha_centauri_game_state_t *state) {
  if (state == NULL) {
    return "Guidance";
  }

  switch (state->stage) {
    case 0:
      return "Launch corridor beacon";
    case 1:
      return "Barycenter alignment";
    case 2:
      return "Turnover marker";
    case 3:
      return "Retro burn beacon";
    case 4:
      if (!state->eva_ready) {
        return "Deorbit corridor";
      }
      if (state->awaiting_flag) {
        return "Landing beacon";
      }
      return "Orbit standby";
    default:
      break;
  }
  return "Guidance";
}

static void session_game_alpha_render_navigation(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  const alpha_centauri_game_state_t *state = &ctx->game.alpha;
  const char *phase_label = session_game_alpha_phase_label(state);

  char header[SSH_CHATTER_MESSAGE_LIMIT];
  bool contact = (state->nav_x == state->nav_target_x && state->nav_y == state->nav_target_y);
  const char *status = contact ? "beacon contact achieved" : "tracking beacon";
  snprintf(header, sizeof(header), "Guidance: %s (%s — reach '+' to advance automatically)", phase_label, status);
  session_send_system_line(ctx, header);

  char border[ALPHA_NAV_WIDTH + 3];
  border[0] = '+';
  for (int idx = 0; idx < ALPHA_NAV_WIDTH; ++idx) {
    border[idx + 1] = '-';
  }
  border[ALPHA_NAV_WIDTH + 1] = '+';
  border[ALPHA_NAV_WIDTH + 2] = '\0';
  session_send_system_line(ctx, border);

  for (int y = 0; y < ALPHA_NAV_HEIGHT; ++y) {
    char row[ALPHA_NAV_WIDTH + 1];
    for (int x = 0; x < ALPHA_NAV_WIDTH; ++x) {
      row[x] = '.';
    }

    for (unsigned idx = 0U; idx < state->gravity_source_count; ++idx) {
      const alpha_gravity_source_t *source = &state->gravity_sources[idx];
      if (source->x >= 0 && source->x < ALPHA_NAV_WIDTH && source->y == y) {
        char symbol = source->symbol != '\0' ? source->symbol : 'G';
        row[source->x] = symbol;
      }
    }

    if (state->nav_target_x >= 0 && state->nav_target_x < ALPHA_NAV_WIDTH && state->nav_target_y >= 0 &&
        state->nav_target_y < ALPHA_NAV_HEIGHT && y == state->nav_target_y) {
      row[state->nav_target_x] = '+';
    }

    if (state->nav_x >= 0 && state->nav_x < ALPHA_NAV_WIDTH && state->nav_y >= 0 && state->nav_y < ALPHA_NAV_HEIGHT &&
        y == state->nav_y) {
      if (state->nav_target_x == state->nav_x && state->nav_target_y == state->nav_y) {
        row[state->nav_x] = '*';
      } else {
        row[state->nav_x] = '@';
      }
    }

    char line[ALPHA_NAV_WIDTH + 4];
    line[0] = '|';
    for (int x = 0; x < ALPHA_NAV_WIDTH; ++x) {
      line[x + 1] = row[x];
    }
    line[ALPHA_NAV_WIDTH + 1] = '|';
    line[ALPHA_NAV_WIDTH + 2] = '\0';
    session_send_system_line(ctx, line);
  }

  session_send_system_line(ctx, border);

  if (state->gravity_source_count > 0U) {
    char gravity_line[SSH_CHATTER_MESSAGE_LIMIT];
    int written = snprintf(gravity_line, sizeof(gravity_line), "Gravity wells: ");
    size_t offset = 0U;
    if (written >= 0) {
      offset = (size_t)written;
      if (offset >= sizeof(gravity_line)) {
        offset = sizeof(gravity_line) - 1U;
      }
    } else {
      gravity_line[0] = '\0';
    }

    for (unsigned idx = 0U; idx < state->gravity_source_count && offset < sizeof(gravity_line) - 1U; ++idx) {
      const alpha_gravity_source_t *source = &state->gravity_sources[idx];
      const char *name = source->name[0] != '\0' ? source->name : "Gravity Source";
      char symbol = source->symbol != '\0' ? source->symbol : 'G';
      written = snprintf(gravity_line + offset, sizeof(gravity_line) - offset, "%s%c=%s(μ=%.2e)",
                         idx == 0U ? "" : ", ", symbol, name, source->mu);
      if (written < 0) {
        break;
      }
      if ((size_t)written >= sizeof(gravity_line) - offset) {
        offset = sizeof(gravity_line) - 1U;
        break;
      }
      offset += (size_t)written;
    }

    gravity_line[sizeof(gravity_line) - 1U] = '\0';
    session_send_system_line(ctx, gravity_line);
  }
}

static void session_game_alpha_refresh_navigation(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  bool previous_translation = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;
  session_game_alpha_render_navigation(ctx);
  session_game_alpha_report_state(ctx, "Current status:");
  ctx->translation_suppress_output = previous_translation;
}

static void session_game_alpha_plan_waypoints(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  if (state->stage != 4U) {
    state->waypoint_count = 0U;
    state->waypoint_index = 0U;
    state->final_waypoint = (alpha_waypoint_t){0};
    return;
  }

  size_t name_count = sizeof(kAlphaWaystationNames) / sizeof(kAlphaWaystationNames[0]);

  if (!state->eva_ready && state->waypoint_count == 0U) {
    unsigned desired = ALPHA_MIN_WAYPOINTS;
    if (desired > ALPHA_MAX_WAYPOINTS) {
      desired = ALPHA_MAX_WAYPOINTS;
    }
    state->waypoint_count = desired;
    state->waypoint_index = 0U;

    for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
      int x = 0;
      int y = 0;
      bool placed = false;
      for (unsigned attempt = 0U; attempt < 96U && !placed; ++attempt) {
        x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, ALPHA_NAV_MARGIN);
        y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, ALPHA_NAV_MARGIN);
        bool conflict = false;
        for (unsigned prior = 0U; prior < idx; ++prior) {
          const alpha_waypoint_t *existing = &state->waypoints[prior];
          if (existing->x == x && existing->y == y) {
            conflict = true;
            break;
          }
        }
        if (!conflict) {
          placed = true;
        }
      }
      if (!placed) {
        x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, ALPHA_NAV_MARGIN);
        y = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_HEIGHT, ALPHA_NAV_MARGIN);
      }

      alpha_waypoint_t *waypoint = &state->waypoints[idx];
      waypoint->x = x;
      waypoint->y = y;
      waypoint->symbol = (char)('1' + (idx % 9));
      waypoint->visited = false;
      const char *name = name_count > 0 ? kAlphaWaystationNames[idx % name_count] : "Waystation";
      snprintf(waypoint->name, sizeof(waypoint->name), "%s", name);
    }
  } else if (!state->eva_ready) {
    for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
      alpha_waypoint_t *waypoint = &state->waypoints[idx];
      if (waypoint->symbol == '\0') {
        waypoint->symbol = (char)('1' + (idx % 9));
      }
    }
  }

  if (state->final_waypoint.symbol == '\0') {
    int x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, ALPHA_NAV_MARGIN);
    int y = ALPHA_NAV_HEIGHT - 1 - session_game_random_range(ctx, ALPHA_NAV_MARGIN + 4);
    for (unsigned attempt = 0U; attempt < 96U; ++attempt) {
      bool conflict = false;
      for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
        const alpha_waypoint_t *waypoint = &state->waypoints[idx];
        if (waypoint->x == x && waypoint->y == y) {
          conflict = true;
          break;
        }
      }
      if (!conflict) {
        break;
      }
      x = session_game_alpha_random_with_margin(ctx, ALPHA_NAV_WIDTH, ALPHA_NAV_MARGIN);
      y = ALPHA_NAV_HEIGHT - 1 - session_game_random_range(ctx, ALPHA_NAV_MARGIN + 4);
    }

    state->final_waypoint.x = x;
    state->final_waypoint.y = y;
    state->final_waypoint.symbol = 'P';
    state->final_waypoint.visited = false;
    snprintf(state->final_waypoint.name, sizeof(state->final_waypoint.name), "%s", "Proxima Landing");
  }
}

static void session_game_alpha_present_waypoints(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  if (state->stage != 4U) {
    return;
  }

  if (!state->eva_ready) {
    if (state->waypoint_count == 0U) {
      session_send_system_line(ctx, "Waystation manifest pending — reroll if the corridor looks blocked.");
      return;
    }

    session_send_system_line(ctx, "Waystation manifest:");
    for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
      const alpha_waypoint_t *waypoint = &state->waypoints[idx];
      char line[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(line, sizeof(line), "  [%c] %c — %s%s", waypoint->visited ? 'x' : ' ', waypoint->symbol, waypoint->name,
               idx == state->waypoint_index ? " ← current objective" : "");
      session_send_system_line(ctx, line);
    }

    char landing[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(landing, sizeof(landing),
             "Final descent: P — %s unlocks after the last waystation. Touch down to finish or press Alt+L if you"
             " prefer a manual confirmation.",
             state->final_waypoint.name[0] != '\0' ? state->final_waypoint.name : "Proxima Landing");
    session_send_system_line(ctx, landing);
    return;
  }

  if (state->awaiting_flag) {
    char landing[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(landing, sizeof(landing),
             "Final target: P — %s. Touch down to plant automatically, or press Alt+L/type 'plant flag' to finish.",
             state->final_waypoint.name[0] != '\0' ? state->final_waypoint.name : "Proxima Landing");
    session_send_system_line(ctx, landing);
  }
}

static void session_game_alpha_complete_waypoint(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  if (state->stage != 4U || state->eva_ready) {
    return;
  }

  if (state->waypoint_index >= state->waypoint_count) {
    session_game_alpha_execute_eva(ctx);
    return;
  }

  alpha_waypoint_t *current = &state->waypoints[state->waypoint_index];
  current->visited = true;
  ++state->waypoint_index;
  state->nav_stable_ticks = 0U;

  if (state->waypoint_index >= state->waypoint_count) {
    session_send_system_line(ctx, "Waystations secured. Setting the descent beacon...");
    state->waypoint_index = state->waypoint_count;
    session_game_alpha_execute_eva(ctx);
    return;
  }

  const alpha_waypoint_t *next = &state->waypoints[state->waypoint_index];
  state->nav_target_x = next->x;
  state->nav_target_y = next->y;
  state->nav_required_ticks = 1U;
  state->nav_fx = (double)state->nav_x;
  state->nav_fy = (double)state->nav_y;
  state->nav_vx = 0.0;
  state->nav_vy = 0.0;

  session_game_alpha_configure_gravity(ctx);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "Next stop %u/%u — marker %c (%s).", state->waypoint_index + 1U,
           state->waypoint_count, next->symbol, next->name);
  session_send_system_line(ctx, message);
  session_game_alpha_refresh_navigation(ctx);
}

static void session_game_alpha_present_stage(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  bool previous_translation = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;

  session_render_separator(ctx, "Alpha Centauri Expedition");

  char stage_line[SSH_CHATTER_MESSAGE_LIMIT];
  switch (state->stage) {
    case 0:
      snprintf(stage_line, sizeof(stage_line),
               "Stage 0 — Launch stack ready. Ride the ascent beacon; contact ignites the antimatter booster automatically.");
      session_send_system_line(ctx, stage_line);
      break;
    case 1:
      snprintf(stage_line, sizeof(stage_line),
               "Stage 1 — Mid-course trim. Touch the barycenter beacon to bank the correction burn; manual lock is optional.");
      session_send_system_line(ctx, stage_line);
      break;
    case 2:
      snprintf(stage_line, sizeof(stage_line),
               "Stage 2 — Turnover. Settle on the retrograde marker to flip into braking attitude automatically.");
      session_send_system_line(ctx, stage_line);
      break;
    case 3:
      snprintf(stage_line, sizeof(stage_line),
               "Stage 3 — Braking burn. Drop onto the braking beacon and the burn locks the moment you make contact.");
      session_send_system_line(ctx, stage_line);
      break;
    case 4:
      if (!state->eva_ready) {
        unsigned remaining = 0U;
        if (state->waypoint_count > state->waypoint_index) {
          remaining = state->waypoint_count - state->waypoint_index;
        }
        snprintf(stage_line, sizeof(stage_line),
                 "Stage 4 — High orbit over Proxima b. Visit the numbered waystations; each beacon contact auto-logs"
                 " the stop. %u stop(s) remain before descent.",
                 remaining);
        session_send_system_line(ctx, stage_line);
      } else if (state->awaiting_flag) {
        snprintf(stage_line, sizeof(stage_line),
                 "Stage 4 — Surface EVA. Touch marker %c (%s) to plant \"Immigrants' Flag\" automatically, or press"
                 " Alt+L/type 'plant flag' for manual confirmation.",
                 state->final_waypoint.symbol != '\0' ? state->final_waypoint.symbol : 'P',
                 state->final_waypoint.name[0] != '\0' ? state->final_waypoint.name : "Proxima Landing");
        session_send_system_line(ctx, stage_line);
      } else {
        session_send_system_line(ctx,
                                 "Stage 4 — Mission reset. Realign with the beacons for another run or exit with /suspend!.");
      }
      session_game_alpha_present_waypoints(ctx);
      break;
    default:
      session_send_system_line(ctx, "Awaiting next burn sequence.");
      break;
  }

  if (state->stage == 4U) {
    session_send_system_line(ctx,
                             "Route markers: 1–9 mark required waystations; P marks the Proxima landing zone.");
    session_send_system_line(ctx,
                             "Gravitational pulls: B=black hole, S=star, D=debris — each mass tugs with its own μ.");
  } else {
    session_send_system_line(ctx,
                             "Gravitational pulls: B=black hole, S=star, P=planet, D=debris — each mass tugs with its own μ.");
  }
  session_game_alpha_render_navigation(ctx);
  if (state->stage == 4U) {
    session_send_system_line(ctx,
                             "Legend: @ craft, + beacon, * beacon contact, digits=waystations, P final landing, B black"
                             " hole, S star, D debris.");
  } else {
    session_send_system_line(ctx,
                             "Legend: @ craft, + beacon, * beacon contact, B black hole, S star, P planet, D debris.");
  }
  session_send_system_line(ctx, "Navigation grid spans 60×60 sectors; each maneuver reshuffles the gravity field.");
  session_send_system_line(ctx, "Use arrow keys to nudge the craft; touching the beacon advances immediately.");
  session_send_system_line(ctx,
                           "Alt+L records a manual confirmation; press Ctrl+S anytime to save the mission log.");
  session_send_system_line(ctx, "Each stage intensifies the gravity field, so later maneuvers demand tighter control.");
  session_send_system_line(ctx, "Stuck? Type 'reset' to reroll the field with a fresh gravimetric solution.");
  session_game_alpha_report_state(ctx, "Current status:");
  ctx->translation_suppress_output = previous_translation;
}

static void session_game_alpha_log_completion(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->velocity_fraction_c = 0.0;
  state->distance_travelled_ly = ALPHA_TOTAL_DISTANCE_LY;
  state->distance_remaining_ly = 0.0;
  if (state->fuel_percent > 5.0) {
    state->fuel_percent = 5.0;
  }
  if (state->oxygen_days > 20.0) {
    state->oxygen_days -= 20.0;
  } else {
    state->oxygen_days = 0.0;
  }
  state->mission_time_years += 0.05;
  state->radiation_msv += 5.0;
  state->eva_ready = true;
  state->awaiting_flag = false;

  double total_years = state->mission_time_years;
  double total_radiation = state->radiation_msv;

  time_t now = time(NULL);
  uint64_t landing_timestamp = 0U;
  if (now != (time_t)-1) {
    landing_timestamp = (uint64_t)now;
  }
  bool recorded = false;
  uint32_t updated_flag_count = 0U;

  if (session_user_data_load(ctx)) {
    ctx->user_data.flag_count += 1U;
    uint64_t timestamp = landing_timestamp;
    if (ctx->user_data.flag_history_count < USER_DATA_FLAG_HISTORY_LIMIT) {
      ctx->user_data.flag_history[ctx->user_data.flag_history_count++] = timestamp;
    } else {
      for (size_t idx = 1U; idx < USER_DATA_FLAG_HISTORY_LIMIT; ++idx) {
        ctx->user_data.flag_history[idx - 1U] = ctx->user_data.flag_history[idx];
      }
      ctx->user_data.flag_history[USER_DATA_FLAG_HISTORY_LIMIT - 1U] = timestamp;
    }
    recorded = true;
    updated_flag_count = ctx->user_data.flag_count;
  }

  bool previous_translation = ctx->translation_suppress_output;
  ctx->translation_suppress_output = true;

  char success[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(success, sizeof(success),
           "Mission complete! \"Immigrants' Flag\" is registered for %s. Flight time %.2f years, exposure %.1f mSv.",
           ctx->user.name, total_years, total_radiation);
  session_send_system_line(ctx, success);

  char notice[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(notice, sizeof(notice), "* [alpha-centauri] Immigrants' Flag planted by %s.", ctx->user.name);
  host_history_record_system(ctx->owner, notice);
  chat_room_broadcast(&ctx->owner->room, notice, NULL);

  ctx->translation_suppress_output = previous_translation;

  if (recorded) {
    host_alpha_landers_record(ctx->owner, ctx->user.name, updated_flag_count, landing_timestamp);
  }

  session_game_alpha_reset(ctx);
  state->active = true;
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_execute_ignite(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || ctx->game.alpha.stage != 0U) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->stage = 1U;
  state->active = true;
  state->velocity_fraction_c = 0.04;
  state->distance_travelled_ly = 0.05;
  state->distance_remaining_ly = ALPHA_TOTAL_DISTANCE_LY - state->distance_travelled_ly;
  state->fuel_percent = 82.0;
  if (state->oxygen_days > 10.0) {
    state->oxygen_days -= 10.0;
  }
  state->mission_time_years += 0.02;
  state->radiation_msv += 12.0;
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_execute_trim(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || ctx->game.alpha.stage != 1U) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->stage = 2U;
  state->velocity_fraction_c = 0.18;
  state->distance_travelled_ly = 1.90;
  state->distance_remaining_ly = ALPHA_TOTAL_DISTANCE_LY - state->distance_travelled_ly;
  state->fuel_percent = 58.0;
  if (state->oxygen_days > 110.0) {
    state->oxygen_days -= 110.0;
  } else {
    state->oxygen_days = 0.0;
  }
  state->mission_time_years += 0.55;
  state->radiation_msv += 28.0;
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_execute_flip(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || ctx->game.alpha.stage != 2U) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->stage = 3U;
  state->distance_travelled_ly = 3.60;
  state->distance_remaining_ly = ALPHA_TOTAL_DISTANCE_LY - state->distance_travelled_ly;
  state->fuel_percent = 45.0;
  if (state->oxygen_days > 220.0) {
    state->oxygen_days -= 220.0;
  } else {
    state->oxygen_days = 0.0;
  }
  state->mission_time_years += 1.80;
  state->radiation_msv += 18.0;
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_execute_retro(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || ctx->game.alpha.stage != 3U) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->stage = 4U;
  state->velocity_fraction_c = 0.01;
  state->distance_travelled_ly = 4.22;
  state->distance_remaining_ly = ALPHA_TOTAL_DISTANCE_LY - state->distance_travelled_ly;
  state->fuel_percent = 18.0;
  if (state->oxygen_days > 150.0) {
    state->oxygen_days -= 150.0;
  } else {
    state->oxygen_days = 0.0;
  }
  state->mission_time_years += 1.20;
  state->radiation_msv += 12.0;
  state->eva_ready = false;
  state->awaiting_flag = false;
  state->waypoint_index = 0U;
  state->waypoint_count = 0U;
  state->final_waypoint = (alpha_waypoint_t){0};
  session_game_alpha_plan_waypoints(ctx);
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_game_alpha_execute_eva(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || ctx->game.alpha.stage != 4U ||
      ctx->game.alpha.eva_ready) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  state->eva_ready = true;
  state->awaiting_flag = true;
  state->waypoint_index = state->waypoint_count;
  if (state->oxygen_days > 30.0) {
    state->oxygen_days -= 30.0;
  } else {
    state->oxygen_days = 0.0;
  }
  state->mission_time_years += 0.05;
  state->radiation_msv += 6.0;
  session_game_alpha_prepare_navigation(ctx);
  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static bool session_game_alpha_attempt_completion(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return false;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  if (state->nav_x != state->nav_target_x || state->nav_y != state->nav_target_y) {
    return false;
  }

  if (state->stage == 0U) {
    session_game_alpha_execute_ignite(ctx);
    return true;
  }
  if (state->stage == 1U) {
    session_game_alpha_execute_trim(ctx);
    return true;
  }
  if (state->stage == 2U) {
    session_game_alpha_execute_flip(ctx);
    return true;
  }
  if (state->stage == 3U) {
    session_game_alpha_execute_retro(ctx);
    return true;
  }
  if (state->stage == 4U) {
    if (!state->eva_ready) {
      session_game_alpha_complete_waypoint(ctx);
      return true;
    }
    if (state->awaiting_flag) {
      state->final_waypoint.visited = true;
      session_game_alpha_log_completion(ctx);
      return true;
    }
  }

  return false;
}

static void session_game_alpha_manual_lock(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  if (state->nav_x != state->nav_target_x || state->nav_y != state->nav_target_y) {
    session_send_system_line(ctx, "Lock failed: align with the beacon before pressing Alt+L.");
    session_game_alpha_refresh_navigation(ctx);
    return;
  }

  if (!session_game_alpha_attempt_completion(ctx)) {
    session_send_system_line(ctx, "Beacon contact logged; mission control is standing by.");
    session_game_alpha_refresh_navigation(ctx);
  }
}

static void session_game_alpha_manual_save(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA) {
    return;
  }

  session_game_alpha_sync_to_save(ctx);
  session_send_system_line(ctx, "Mission log saved. Touch the beacon to advance or press Alt+L to confirm manually.");
}

static bool session_game_alpha_handle_arrow(session_ctx_t *ctx, int dx, int dy) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return false;
  }

  if (dx == 0 && dy == 0) {
    return false;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;

  state->nav_vx += (double)dx * ALPHA_THRUST_DELTA;
  state->nav_vy += (double)dy * ALPHA_THRUST_DELTA;
  state->nav_fx += (double)dx * ALPHA_THRUST_POSITION_STEP;
  state->nav_fy += (double)dy * ALPHA_THRUST_POSITION_STEP;

  double max_x = (double)(ALPHA_NAV_WIDTH - 1);
  double max_y = (double)(ALPHA_NAV_HEIGHT - 1);
  if (state->nav_fx < 0.0) {
    state->nav_fx = 0.0;
    state->nav_vx = 0.0;
  } else if (state->nav_fx > max_x) {
    state->nav_fx = max_x;
    state->nav_vx = 0.0;
  }
  if (state->nav_fy < 0.0) {
    state->nav_fy = 0.0;
    state->nav_vy = 0.0;
  } else if (state->nav_fy > max_y) {
    state->nav_fy = max_y;
    state->nav_vy = 0.0;
  }

  state->nav_x = (int)lround(state->nav_fx);
  state->nav_y = (int)lround(state->nav_fy);
  if (state->nav_x < 0) {
    state->nav_x = 0;
  } else if (state->nav_x >= ALPHA_NAV_WIDTH) {
    state->nav_x = ALPHA_NAV_WIDTH - 1;
  }
  if (state->nav_y < 0) {
    state->nav_y = 0;
  } else if (state->nav_y >= ALPHA_NAV_HEIGHT) {
    state->nav_y = ALPHA_NAV_HEIGHT - 1;
  }

  session_game_alpha_apply_gravity(state);

  if (state->nav_x == state->nav_target_x && state->nav_y == state->nav_target_y) {
    state->nav_stable_ticks = 1U;
  } else {
    state->nav_stable_ticks = 0U;
  }

  bool completed = session_game_alpha_attempt_completion(ctx);
  if (!completed) {
    session_game_alpha_refresh_navigation(ctx);
  }

  return true;
}

static void session_game_alpha_handle_line(session_ctx_t *ctx, const char *line) {
  if (ctx == NULL || ctx->game.type != SESSION_GAME_ALPHA || !ctx->game.active) {
    return;
  }

  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  char command[SSH_CHATTER_MAX_INPUT_LEN];
  if (line == NULL) {
    command[0] = '\0';
  } else {
    snprintf(command, sizeof(command), "%s", line);
  }
  trim_whitespace_inplace(command);

  if (command[0] == '\0') {
    session_game_alpha_refresh_navigation(ctx);
    return;
  }

  if (strcasecmp(command, "lock") == 0 || strcasecmp(command, "align lock") == 0) {
    session_game_alpha_manual_lock(ctx);
    return;
  }

  if (strcasecmp(command, "save") == 0 || strcasecmp(command, "log") == 0) {
    session_game_alpha_manual_save(ctx);
    return;
  }

  if (strcasecmp(command, "reset") == 0 || strcasecmp(command, "reroll") == 0 ||
      strcasecmp(command, "rescan") == 0) {
    session_game_alpha_reroll_navigation(ctx);
    return;
  }

  if (state->stage == 0U) {
    if (strcasecmp(command, "ignite") == 0 || strcasecmp(command, "launch") == 0) {
      session_game_alpha_execute_ignite(ctx);
    } else {
      session_send_system_line(ctx, "Line up with the ascent beacon using arrow keys or type 'ignite'.");
      session_game_alpha_refresh_navigation(ctx);
    }
    return;
  }

  if (state->stage == 1U) {
    if (strcasecmp(command, "trim") == 0 || strcasecmp(command, "align") == 0) {
      session_game_alpha_execute_trim(ctx);
    } else {
      session_send_system_line(ctx, "Touch the barycenter beacon with arrow keys or type 'trim'.");
      session_game_alpha_refresh_navigation(ctx);
    }
    return;
  }

  if (state->stage == 2U) {
    if (strcasecmp(command, "flip") == 0 || strcasecmp(command, "turnover") == 0) {
      session_game_alpha_execute_flip(ctx);
    } else {
      session_send_system_line(ctx, "Rotate into retrograde by touching the marker with arrow keys or type 'flip'.");
      session_game_alpha_refresh_navigation(ctx);
    }
    return;
  }

  if (state->stage == 3U) {
    if (strcasecmp(command, "retro") == 0 || strcasecmp(command, "brake") == 0) {
      session_game_alpha_execute_retro(ctx);
    } else {
      session_send_system_line(ctx, "Drop onto the braking beacon with arrow keys or type 'retro'.");
      session_game_alpha_refresh_navigation(ctx);
    }
    return;
  }

  if (state->stage == 4U) {
    if (!state->eva_ready) {
      if (state->waypoint_index < state->waypoint_count) {
        const alpha_waypoint_t *target = &state->waypoints[state->waypoint_index];
        char message[SSH_CHATTER_MESSAGE_LIMIT];
        snprintf(message, sizeof(message),
                 "Route checkpoint %u/%u — touch marker %c (%s) to proceed automatically. Alt+L remains available for"
                 " manual control.",
                 state->waypoint_index + 1U, state->waypoint_count, target->symbol, target->name);
        session_send_system_line(ctx, message);
        session_game_alpha_refresh_navigation(ctx);
      } else {
        session_send_system_line(ctx,
                                 "Waystations cleared. Touch the descent beacon or press Alt+L to trigger EVA.");
        session_game_alpha_refresh_navigation(ctx);
      }
    } else if (state->awaiting_flag) {
      if (strcasecmp(command, "plant") == 0 || strcasecmp(command, "plant flag") == 0 ||
          strcasecmp(command, "flag") == 0) {
        session_game_alpha_log_completion(ctx);
      } else {
        char message[SSH_CHATTER_MESSAGE_LIMIT];
        snprintf(message, sizeof(message),
                 "Touch marker %c (%s) to finish automatically, or press Alt+L/type 'plant flag' to plant manually.",
                 state->final_waypoint.symbol != '\0' ? state->final_waypoint.symbol : 'P',
                 state->final_waypoint.name[0] != '\0' ? state->final_waypoint.name : "Proxima Landing");
        session_send_system_line(ctx, message);
        session_game_alpha_refresh_navigation(ctx);
      }
    } else {
      session_send_system_line(ctx, "Launch again with 'ignite' or exit with /suspend!.");
      session_game_alpha_refresh_navigation(ctx);
    }
    return;
  }

  session_send_system_line(ctx, "Hold position for the next maneuver.");
  session_game_alpha_refresh_navigation(ctx);
}

static void session_game_start_alpha(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (!session_user_data_load(ctx)) {
    session_send_system_line(ctx, "Profile storage unavailable; cannot start the mission.");
    return;
  }

  session_game_alpha_sync_from_save(ctx);
  alpha_centauri_game_state_t *state = &ctx->game.alpha;
  ctx->game.type = SESSION_GAME_ALPHA;
  ctx->game.active = true;
  state->active = true;

  if (state->stage == 0U) {
    session_send_system_line(ctx,
                             "Mission control: Alpha Centauri expedition primed. Complete each maneuver to reach Proxima b.");
  } else {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Mission control: Resuming expedition at stage %u.", state->stage);
    session_send_system_line(ctx, message);
  }

  session_game_alpha_sync_to_save(ctx);
  session_game_alpha_present_stage(ctx);
}

static void session_handle_game(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->game.active) {
    session_send_system_line(ctx, "Finish the current game with /suspend! first.");
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /game <tetris|liargame|alpha>");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);
  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /game <tetris|liargame|alpha>");
    return;
  }

  for (size_t idx = 0U; working[idx] != '\0'; ++idx) {
    working[idx] = (char)tolower((unsigned char)working[idx]);
  }

  if (strcmp(working, "tetris") == 0) {
    session_game_start_tetris(ctx);
  } else if (strcmp(working, "liargame") == 0) {
    session_game_start_liargame(ctx);
  } else if (strcmp(working, "alpha") == 0 || strcmp(working, "alphacentauri") == 0) {
    session_game_start_alpha(ctx);
  } else {
    session_send_system_line(ctx, "Unknown game. Available options: tetris, liargame, alpha.");
  }
}

static void session_game_suspend(session_ctx_t *ctx, const char *reason) {
  if (ctx == NULL) {
    return;
  }

  if (!ctx->game.active) {
    if (reason != NULL && reason[0] != '\0') {
      session_send_system_line(ctx, reason);
    } else {
      session_send_system_line(ctx, "There is no active game to suspend.");
    }
    return;
  }

  if (reason != NULL && reason[0] != '\0') {
    session_send_system_line(ctx, reason);
  }

  if (ctx->game.type == SESSION_GAME_TETRIS) {
    char summary[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(summary, sizeof(summary), "Tetris final score: %u (lines cleared: %u).", ctx->game.tetris.score,
             ctx->game.tetris.lines_cleared);
    session_send_system_line(ctx, summary);
    session_game_tetris_reset(&ctx->game.tetris);
  } else if (ctx->game.type == SESSION_GAME_LIARGAME) {
    char summary[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(summary, sizeof(summary), "Liar Game rounds played: %u, score: %u.", ctx->game.liar.round_number,
             ctx->game.liar.score);
    session_send_system_line(ctx, summary);
    ctx->game.liar.awaiting_guess = false;
    ctx->game.liar.round_number = 0U;
    ctx->game.liar.score = 0U;
  } else if (ctx->game.type == SESSION_GAME_ALPHA) {
    char summary[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(summary, sizeof(summary), "Alpha Centauri mission paused at stage %u with %.2f ly remaining.",
             ctx->game.alpha.stage, ctx->game.alpha.distance_remaining_ly);
    session_send_system_line(ctx, summary);
    session_game_alpha_reset(ctx);
    session_game_alpha_sync_to_save(ctx);
  }

  ctx->game.active = false;
  ctx->game.type = SESSION_GAME_NONE;
}

static int session_channel_read_poll(session_ctx_t *ctx, char *buffer, size_t length, int timeout_ms) {
  if (ctx == NULL || buffer == NULL || length == 0U || !session_transport_active(ctx)) {
    return SSH_ERROR;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    int result = session_transport_read(ctx, buffer, length, timeout_ms);
    if (result == SSH_AGAIN) {
      return SESSION_CHANNEL_TIMEOUT;
    }
    return result;
  }

  int fd = ssh_get_fd(ctx->session);
  if (fd < 0) {
    return session_transport_read(ctx, buffer, length, -1);
  }

  struct pollfd pfd;
  pfd.fd = fd;
  pfd.events = POLLIN;
  pfd.revents = 0;

  for (;;) {
    int poll_result = poll(&pfd, 1, timeout_ms);
    if (poll_result < 0) {
      if (errno == EINTR) {
        continue;
      }
      return SSH_ERROR;
    }
    if (poll_result == 0) {
      return SESSION_CHANNEL_TIMEOUT;
    }
    break;
  }

  if ((pfd.revents & POLLIN) == 0) {
    if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
      return 0;
    }
    return SESSION_CHANNEL_TIMEOUT;
  }

  return session_transport_read(ctx, buffer, length, -1);
}

static bool session_parse_color_arguments(char *working, char **tokens, size_t max_tokens, size_t *token_count) {
  if (working == NULL || tokens == NULL || token_count == NULL) {
    return false;
  }

  *token_count = 0U;
  bool extra_tokens = false;
  char *cursor = working;
  while (cursor != NULL) {
    char *next = strchr(cursor, ';');
    if (next != NULL) {
      *next = '\0';
    }

    trim_whitespace_inplace(cursor);
    if (cursor[0] == '\0') {
      return false;
    }

    if (*token_count < max_tokens) {
      tokens[*token_count] = cursor;
      ++(*token_count);
    } else if (cursor[0] != '\0') {
      extra_tokens = true;
    }

    if (next == NULL) {
      break;
    }

    cursor = next + 1;
    if (cursor[0] == '\0') {
      extra_tokens = true;
      break;
    }
  }

  return !extra_tokens;
}

static void session_handle_color(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /color (text;highlight[;bold])");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /color (text;highlight[;bold])");
    return;
  }

  bool had_parentheses = false;
  if (working[0] == '(') {
    had_parentheses = true;
    memmove(working, working + 1, strlen(working));
    trim_whitespace_inplace(working);
  }

  if (had_parentheses) {
    size_t len = strlen(working);
    if (len == 0U || working[len - 1U] != ')') {
      session_send_system_line(ctx, "Usage: /color (text;highlight[;bold])");
      return;
    }
    working[len - 1U] = '\0';
    trim_whitespace_inplace(working);
  }

  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /color (text;highlight[;bold])");
    return;
  }

  char *tokens[3] = {0};
  size_t token_count = 0U;
  if (!session_parse_color_arguments(working, tokens, 3U, &token_count) || token_count < 2U) {
    session_send_system_line(ctx, "Usage: /color (text;highlight[;bold])");
    return;
  }

  const char *text_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), tokens[0]);
  if (text_code == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Unknown text color '%s'.", tokens[0]);
    session_send_system_line(ctx, message);
    return;
  }

  const char *highlight_code = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                                sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]),
                                                tokens[1]);
  if (highlight_code == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Unknown highlight color '%s'.", tokens[1]);
    session_send_system_line(ctx, message);
    return;
  }

  bool is_bold = false;
  if (token_count == 3U) {
    if (!parse_bool_token(tokens[2], &is_bold)) {
      session_send_system_line(ctx, "The third value must describe bold (ex: bold, true, normal).");
      return;
    }
  }

  ctx->user_color_code = text_code;
  ctx->user_highlight_code = highlight_code;
  ctx->user_is_bold = is_bold;
  snprintf(ctx->user_color_name, sizeof(ctx->user_color_name), "%s", tokens[0]);
  snprintf(ctx->user_highlight_name, sizeof(ctx->user_highlight_name), "%s", tokens[1]);

  char info[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(info, sizeof(info), "Handle colors updated: text=%s highlight=%s bold=%s", tokens[0], tokens[1],
           is_bold ? "on" : "off");
  session_send_system_line(ctx, info);

  const char *bold_code = is_bold ? ANSI_BOLD : "";
  char preview[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(preview, sizeof(preview), "%s%s%s[%s] preview%s", highlight_code, bold_code, text_code, ctx->user.name,
           ANSI_RESET);
  session_send_line(ctx, preview);

  if (ctx->owner != NULL) {
    host_store_user_theme(ctx->owner, ctx);
  }
}

static bool session_try_reload_motd_from_candidate_path(host_t *host, const char *candidate,
                                                        char *resolved_path, size_t resolved_len,
                                                        bool *path_exists_out, int *error_out) {
  if (resolved_path != NULL && resolved_len > 0U) {
    resolved_path[0] = '\0';
  }
  if (path_exists_out != NULL) {
    *path_exists_out = false;
  }
  if (error_out != NULL) {
    *error_out = 0;
  }
  if (host == NULL || candidate == NULL) {
    return false;
  }

  if (candidate[0] == '\0') {
    return false;
  }

  char trimmed[PATH_MAX];
  int copied = snprintf(trimmed, sizeof(trimmed), "%s", candidate);
  if (copied <= 0 || (size_t)copied >= sizeof(trimmed)) {
    return false;
  }

  trim_whitespace_inplace(trimmed);

  if (trimmed[0] == '\0') {
    return false;
  }

  if (strchr(trimmed, '\n') != NULL || strchr(trimmed, '\r') != NULL) {
    return false;
  }

  const size_t kMaxPaths = 2U;
  const char *paths_to_try[2] = {NULL, NULL};
  size_t path_count = 0U;

  char expanded[PATH_MAX];
  expanded[0] = '\0';
  if (trimmed[0] == '~' && (trimmed[1] == '\0' || trimmed[1] == '/')) {
    const char *home = getenv("HOME");
    if (home != NULL && home[0] != '\0') {
      int expanded_written = snprintf(expanded, sizeof(expanded), "%s%s", home, trimmed + 1);
      if (expanded_written > 0 && (size_t)expanded_written < sizeof(expanded)) {
        paths_to_try[path_count++] = expanded;
      }
    }
  }

  if (path_count < kMaxPaths) {
    paths_to_try[path_count++] = trimmed;
  }

  for (size_t idx = 0U; idx < path_count; ++idx) {
    const char *path = paths_to_try[idx];
    if (path == NULL || path[0] == '\0') {
      continue;
    }

    if (host_try_load_motd_from_path(host, path)) {
      if (path_exists_out != NULL) {
        *path_exists_out = true;
      }
      if (resolved_path != NULL && resolved_len > 0U) {
        snprintf(resolved_path, resolved_len, "%s", path);
      }
      return true;
    }

    if (error_out != NULL && *error_out == 0) {
      const int load_error = errno;
      if (load_error != 0) {
        *error_out = load_error;
      }
    }

    struct stat info;
    if (stat(path, &info) == 0 && S_ISREG(info.st_mode)) {
      if (path_exists_out != NULL) {
        *path_exists_out = true;
      }
      if (resolved_path != NULL && resolved_len > 0U) {
        snprintf(resolved_path, resolved_len, "%s", path);
      }
    }
  }

  return false;
}

static void session_handle_motd(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_refresh_motd(ctx->owner);

  char motd[sizeof(ctx->owner->motd)];
  motd[0] = '\0';
  bool has_file = false;
  char configured_path[PATH_MAX];
  configured_path[0] = '\0';

  pthread_mutex_lock(&ctx->owner->lock);
  snprintf(motd, sizeof(motd), "%s", ctx->owner->motd);
  has_file = ctx->owner->motd_has_file;
  snprintf(configured_path, sizeof(configured_path), "%s", ctx->owner->motd_path);
  pthread_mutex_unlock(&ctx->owner->lock);

  bool config_path_exists = false;
  int config_error = 0;
  char resolved_path[PATH_MAX];
  resolved_path[0] = '\0';

  bool fallback_path_exists = false;
  int fallback_error = 0;
  char fallback_path[PATH_MAX];
  fallback_path[0] = '\0';

  if (!has_file) {
    if (configured_path[0] != '\0' &&
        session_try_reload_motd_from_candidate_path(ctx->owner, configured_path, resolved_path,
                                                    sizeof(resolved_path), &config_path_exists, &config_error)) {
      pthread_mutex_lock(&ctx->owner->lock);
      snprintf(motd, sizeof(motd), "%s", ctx->owner->motd);
      has_file = ctx->owner->motd_has_file;
      pthread_mutex_unlock(&ctx->owner->lock);
    } else if (resolved_path[0] == '\0' && configured_path[0] != '\0') {
      snprintf(resolved_path, sizeof(resolved_path), "%s", configured_path);
    }

    if (!has_file && motd[0] != '\0') {
      if (session_try_reload_motd_from_candidate_path(ctx->owner, motd, fallback_path, sizeof(fallback_path),
                                                      &fallback_path_exists, &fallback_error)) {
        pthread_mutex_lock(&ctx->owner->lock);
        snprintf(motd, sizeof(motd), "%s", ctx->owner->motd);
        has_file = ctx->owner->motd_has_file;
        pthread_mutex_unlock(&ctx->owner->lock);
      } else if (fallback_path[0] == '\0') {
        snprintf(fallback_path, sizeof(fallback_path), "%s", motd);
      }
    }
  }

  if (!has_file && configured_path[0] != '\0') {
    const char *failing_path = resolved_path[0] != '\0' ? resolved_path : configured_path;
    const bool any_path_exists = config_path_exists || fallback_path_exists;
    const int failing_error = config_error != 0 ? config_error : fallback_error;
    char warning[SSH_CHATTER_MESSAGE_LIMIT];
    if (failing_error != 0) {
      snprintf(warning, sizeof(warning), "Failed to load message of the day from %s: %s.", failing_path,
               strerror(failing_error));
    } else if (any_path_exists) {
      snprintf(warning, sizeof(warning), "Failed to load message of the day from %s.", failing_path);
    } else {
      snprintf(warning, sizeof(warning), "Message of the day file %s was not found.", failing_path);
    }
    session_send_system_line(ctx, warning);
    return;
  }

  if (!has_file && configured_path[0] == '\0' && fallback_path_exists) {
    const char *failing_path = fallback_path[0] != '\0' ? fallback_path : motd;
    char warning[SSH_CHATTER_MESSAGE_LIMIT];
    if (fallback_error != 0) {
      snprintf(warning, sizeof(warning), "Failed to load message of the day from %s: %s.", failing_path,
               strerror(fallback_error));
    } else {
      snprintf(warning, sizeof(warning), "Failed to load message of the day from %s.", failing_path);
    }
    session_send_system_line(ctx, warning);
    return;
  }

  if (motd[0] == '\0') {
    session_send_system_line(ctx, "No message of the day is configured.");
    return;
  }

  session_send_raw_text_bulk(ctx, motd);
}

static void session_handle_system_color(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage =
      "Usage: /systemcolor (fg;background[;highlight][;bold]) or /systemcolor reset - third value may be highlight or "
      "bold.";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/systemcolor", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  bool had_parentheses = false;
  if (working[0] == '(') {
    had_parentheses = true;
    memmove(working, working + 1, strlen(working));
    trim_whitespace_inplace(working);
  }

  if (had_parentheses) {
    size_t len = strlen(working);
    if (len == 0U || working[len - 1U] != ')') {
      session_send_system_line(ctx, usage);
      return;
    }
    working[len - 1U] = '\0';
    trim_whitespace_inplace(working);
  }

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  if (strcasecmp(working, "reset") == 0) {
    session_apply_system_theme_defaults(ctx);
    session_send_system_line(ctx, "System colors reset to defaults.");
    session_render_separator(ctx, "Chatroom");
    session_render_prompt(ctx, true);
    if (ctx->owner != NULL) {
      host_store_system_theme(ctx->owner, ctx);
    }
    return;
  }

  char *tokens[4] = {0};
  size_t token_count = 0U;
  if (!session_parse_color_arguments(working, tokens, 4U, &token_count) || token_count < 2U) {
    session_send_system_line(ctx, usage);
    return;
  }

  const char *fg_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), tokens[0]);
  if (fg_code == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Unknown foreground color '%s'.", tokens[0]);
    session_send_system_line(ctx, message);
    return;
  }

  const char *bg_code = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                          sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), tokens[1]);
  if (bg_code == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Unknown background color '%s'.", tokens[1]);
    session_send_system_line(ctx, message);
    return;
  }

  const char *highlight_code = ctx->system_highlight_code;
  bool highlight_updated = false;
  bool is_bold = ctx->system_is_bold;
  if (token_count >= 3U) {
    bool bool_value = false;
    if (parse_bool_token(tokens[2], &bool_value)) {
      if (token_count > 3U) {
        session_send_system_line(ctx, usage);
        return;
      }
      is_bold = bool_value;
    } else {
      highlight_code = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                         sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), tokens[2]);
      if (highlight_code == NULL) {
        char message[SSH_CHATTER_MESSAGE_LIMIT];
        snprintf(message, sizeof(message), "Unknown highlight color '%s'.", tokens[2]);
        session_send_system_line(ctx, message);
        return;
      }
      highlight_updated = true;

      if (token_count == 4U) {
        if (!parse_bool_token(tokens[3], &bool_value)) {
          session_send_system_line(ctx, "The last value must describe bold (ex: bold, true, normal).");
          return;
        }
        is_bold = bool_value;
      }
    }
  }

  ctx->system_fg_code = fg_code;
  ctx->system_bg_code = bg_code;
  ctx->system_highlight_code = highlight_code;
  ctx->system_is_bold = is_bold;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", tokens[0]);
  snprintf(ctx->system_bg_name, sizeof(ctx->system_bg_name), "%s", tokens[1]);
  if (highlight_updated) {
    snprintf(ctx->system_highlight_name, sizeof(ctx->system_highlight_name), "%s", tokens[2]);
  }

  session_force_dark_mode_foreground(ctx);
  session_apply_background_fill(ctx);

  session_send_system_line(ctx, "System colors updated.");
  session_render_separator(ctx, "Chatroom");
  session_render_prompt(ctx, true);
  if (ctx->owner != NULL) {
    host_store_system_theme(ctx->owner, ctx);
  }
}

static void session_handle_set_trans_lang(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  char working[SSH_CHATTER_LANG_NAME_LEN];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /set-trans-lang <language|off>");
    return;
  }

  if (session_argument_is_disable(working)) {
    ctx->output_translation_enabled = false;
    ctx->output_translation_language[0] = '\0';
    session_translation_clear_queue(ctx);
    session_send_system_line(ctx, "Terminal translation disabled.");
    if (ctx->owner != NULL) {
      host_store_translation_preferences(ctx->owner, ctx);
    }
    return;
  }

  if (session_language_equals(ctx->output_translation_language, working)) {
    snprintf(ctx->output_translation_language, sizeof(ctx->output_translation_language), "%s", working);
    ctx->output_translation_enabled = true;
    session_translation_clear_queue(ctx);

    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Terminal output will continue to be translated to %s.",
             ctx->output_translation_language);
    session_send_system_line(ctx, message);
    if (!ctx->translation_enabled) {
      session_send_system_line(ctx, "Translation is currently disabled; enable it with /translate on.");
    }
    if (ctx->owner != NULL) {
      host_store_translation_preferences(ctx->owner, ctx);
    }
    return;
  }

  char preview[SSH_CHATTER_MESSAGE_LIMIT];
  char detected[SSH_CHATTER_LANG_NAME_LEN];
  if (!translator_translate("Terminal messages will be translated for you.", working, preview, sizeof(preview), detected,
                            sizeof(detected))) {
    const char *error = translator_last_error();
    if (error != NULL && *error != '\0') {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Translation service error: %s", error);
      session_send_system_line(ctx, message);
    } else {
      session_send_system_line(ctx, "Failed to reach the translation service. Please try again later.");
    }
    return;
  }

  snprintf(ctx->output_translation_language, sizeof(ctx->output_translation_language), "%s", working);
  ctx->output_translation_enabled = true;
  session_translation_clear_queue(ctx);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  int preview_limit = (int)(sizeof(message) / 2);
  if (preview_limit <= 0) {
    preview_limit = (int)sizeof(message) - 1;
  }
  int detected_limit = (int)sizeof(detected) - 1;
  if (detected_limit <= 0) {
    detected_limit = (int)sizeof(detected);
  }
  if (detected[0] != '\0') {
    snprintf(message, sizeof(message), "Terminal output will be translated to %s. Sample: %.*s (detected: %.*s).",
             ctx->output_translation_language, preview_limit, preview, detected_limit, detected);
  } else {
    snprintf(message, sizeof(message), "Terminal output will be translated to %s. Sample: %.*s.",
             ctx->output_translation_language, preview_limit, preview);
  }
  session_send_system_line(ctx, message);
  if (!ctx->translation_enabled) {
    session_send_system_line(ctx, "Translation is currently disabled; enable it with /translate on.");
  }
  if (ctx->owner != NULL) {
    host_store_translation_preferences(ctx->owner, ctx);
  }
}

static void session_handle_set_target_lang(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  char working[SSH_CHATTER_LANG_NAME_LEN];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /set-target-lang <language|off>");
    return;
  }

  if (session_argument_is_disable(working)) {
    ctx->input_translation_enabled = false;
    ctx->input_translation_language[0] = '\0';
    ctx->last_detected_input_language[0] = '\0';
    session_send_system_line(ctx, "Outgoing message translation disabled.");
    if (ctx->owner != NULL) {
      host_store_translation_preferences(ctx->owner, ctx);
    }
    return;
  }

  if (session_language_equals(ctx->input_translation_language, working)) {
    snprintf(ctx->input_translation_language, sizeof(ctx->input_translation_language), "%s", working);
    ctx->input_translation_enabled = true;
    ctx->last_detected_input_language[0] = '\0';

    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Outgoing messages will continue to be translated to %s.",
             ctx->input_translation_language);
    session_send_system_line(ctx, message);
    if (!ctx->translation_enabled) {
      session_send_system_line(ctx, "Translation is currently disabled; enable it with /translate on.");
    }
    if (ctx->owner != NULL) {
      host_store_translation_preferences(ctx->owner, ctx);
    }
    return;
  }

  char preview[SSH_CHATTER_MESSAGE_LIMIT];
  char detected[SSH_CHATTER_LANG_NAME_LEN];
  if (!translator_translate("Your messages will be translated before broadcasting.", working, preview, sizeof(preview),
                            detected, sizeof(detected))) {
    const char *error = translator_last_error();
    if (error != NULL && *error != '\0') {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "Translation service error: %s", error);
      session_send_system_line(ctx, message);
    } else {
      session_send_system_line(ctx, "Failed to reach the translation service. Please try again later.");
    }
    return;
  }

  snprintf(ctx->input_translation_language, sizeof(ctx->input_translation_language), "%s", working);
  ctx->input_translation_enabled = true;
  ctx->last_detected_input_language[0] = '\0';

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  int preview_limit = (int)(sizeof(message) / 2);
  if (preview_limit <= 0) {
    preview_limit = (int)sizeof(message) - 1;
  }
  int detected_limit = (int)sizeof(detected) - 1;
  if (detected_limit <= 0) {
    detected_limit = (int)sizeof(detected);
  }
  if (detected[0] != '\0') {
    snprintf(message, sizeof(message), "Outgoing messages will be translated to %s. Sample: %.*s (detected: %.*s).",
             ctx->input_translation_language, preview_limit, preview, detected_limit, detected);
  } else {
    snprintf(message, sizeof(message), "Outgoing messages will be translated to %s. Sample: %.*s.",
             ctx->input_translation_language, preview_limit, preview);
  }
  session_send_system_line(ctx, message);
  if (!ctx->translation_enabled) {
    session_send_system_line(ctx, "Translation is currently disabled; enable it with /translate on.");
  }
  if (ctx->owner != NULL) {
    host_store_translation_preferences(ctx->owner, ctx);
  }
}

static void session_handle_chat_spacing(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);
  const char *usage_format = (locale->chat_spacing_usage != NULL && locale->chat_spacing_usage[0] != '\0')
                                 ? locale->chat_spacing_usage
                                 : "Usage: %schat-spacing <0-5>";

  char working[16];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  trim_whitespace_inplace(working);

  char usage_message[SSH_CHATTER_MESSAGE_LIMIT];
  const char *usage_args[] = {prefix};

  if (working[0] == '\0') {
    session_format_template(usage_format, usage_args, sizeof(usage_args) / sizeof(usage_args[0]), usage_message,
                            sizeof(usage_message));
    session_send_system_line(ctx, usage_message);
    return;
  }

  char *endptr = NULL;
  long value = strtol(working, &endptr, 10);
  if (endptr == working || (endptr != NULL && *endptr != '\0') || value < 0L || value > 5L) {
    session_format_template(usage_format, usage_args, sizeof(usage_args) / sizeof(usage_args[0]), usage_message,
                            sizeof(usage_message));
    session_send_system_line(ctx, usage_message);
    return;
  }

  ctx->translation_caption_spacing = (size_t)value;

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  if (value == 0L) {
    const char *format = (locale->chat_spacing_immediate != NULL && locale->chat_spacing_immediate[0] != '\0')
                             ? locale->chat_spacing_immediate
                             : "Translation captions will appear immediately without reserving extra blank lines.";
    session_format_template(format, NULL, 0U, message, sizeof(message));
  } else if (value == 1L) {
    const char *format = (locale->chat_spacing_single != NULL && locale->chat_spacing_single[0] != '\0')
                             ? locale->chat_spacing_single
                             : "Translation captions will reserve 1 blank line before appearing in chat threads.";
    session_format_template(format, NULL, 0U, message, sizeof(message));
  } else {
    const char *format = (locale->chat_spacing_multiple != NULL && locale->chat_spacing_multiple[0] != '\0')
                             ? locale->chat_spacing_multiple
                             : "Translation captions will reserve %s blank lines before appearing in chat threads.";
    char count[16];
    snprintf(count, sizeof(count), "%ld", value);
    const char *args[] = {count};
    session_format_template(format, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
  }
  session_send_system_line(ctx, message);

  if (ctx->owner != NULL) {
    host_store_chat_spacing(ctx->owner, ctx);
  }
}

static void session_handle_set_ui_lang(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);

  char token[SSH_CHATTER_LANG_NAME_LEN];
  const char *cursor = session_consume_token(arguments, token, sizeof(token));

  bool extra_tokens = cursor != NULL && *cursor != '\0';
  if (token[0] == '\0' || extra_tokens) {
    const char *format = (locale->set_ui_lang_usage != NULL && locale->set_ui_lang_usage[0] != '\0')
                             ? locale->set_ui_lang_usage
                             : "Usage: %sset-ui-lang <ko|en|jp|zh|ru>";
    const char *args[] = {prefix};
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(format, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
    session_send_system_line(ctx, message);
    return;
  }

  session_ui_language_t language = session_ui_language_from_code(token);
  if (language == SESSION_UI_LANGUAGE_COUNT) {
    const char *format = (locale->set_ui_lang_invalid != NULL && locale->set_ui_lang_invalid[0] != '\0')
                             ? locale->set_ui_lang_invalid
                             : "Unsupported language. Use one of: ko, en, jp, zh, ru.";
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    session_format_template(format, NULL, 0U, message, sizeof(message));
    session_send_system_line(ctx, message);
    return;
  }

  ctx->ui_language = language;
  const session_ui_locale_t *updated_locale = session_ui_get_locale(ctx);
  const char *language_name = session_ui_language_name(language, ctx->ui_language);
  const char *format = (updated_locale->set_ui_lang_success != NULL &&
                        updated_locale->set_ui_lang_success[0] != '\0')
                           ? updated_locale->set_ui_lang_success
                           : "UI language set to %s. Use %shelp to review commands.";
  const char *updated_prefix = session_command_prefix(ctx);

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  const char *args[] = {language_name != NULL ? language_name : "-", updated_prefix};
  session_format_template(format, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
  session_send_system_line(ctx, message);

  if (ctx->owner != NULL) {
    host_store_ui_language(ctx->owner, ctx);
  }
}

static void session_handle_mode(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *prefix = session_command_prefix(ctx);
  const char *chat_label = (locale->mode_label_chat != NULL && locale->mode_label_chat[0] != '\0')
                               ? locale->mode_label_chat
                               : "chat";
  const char *command_label = (locale->mode_label_command != NULL && locale->mode_label_command[0] != '\0')
                                   ? locale->mode_label_command
                                   : "command";

  char working[32];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  trim_whitespace_inplace(working);

  const char *status_format = (locale->mode_status_format != NULL && locale->mode_status_format[0] != '\0')
                                  ? locale->mode_status_format
                                  : "Current input mode: %s.";
  const char *explain_chat = (locale->mode_explain_chat != NULL && locale->mode_explain_chat[0] != '\0')
                                 ? locale->mode_explain_chat
                                 : "Chat mode: send messages normally. Prefix commands with %s.";
  const char *explain_command = (locale->mode_explain_command != NULL && locale->mode_explain_command[0] != '\0')
                                    ? locale->mode_explain_command
                                    : "Command mode: enter commands without %s, use UpArrow/DownArrow for history and Tab for completion.";
  const char *already_chat = (locale->mode_already_chat != NULL && locale->mode_already_chat[0] != '\0')
                                 ? locale->mode_already_chat
                                 : "Already in chat mode. Commands require the %s prefix.";
  const char *already_command = (locale->mode_already_command != NULL && locale->mode_already_command[0] != '\0')
                                    ? locale->mode_already_command
                                    : "Command mode already active. Enter commands without %s.";
  const char *enabled_chat = (locale->mode_enabled_chat != NULL && locale->mode_enabled_chat[0] != '\0')
                                 ? locale->mode_enabled_chat
                                 : "Chat mode enabled. Commands once again require the %s prefix.";
  const char *enabled_command = (locale->mode_enabled_command != NULL && locale->mode_enabled_command[0] != '\0')
                                    ? locale->mode_enabled_command
                                    : "Command mode enabled. Enter commands without %s; use UpArrow/DownArrow for history and Tab for completion.";
  const char *usage_format = (locale->mode_usage != NULL && locale->mode_usage[0] != '\0')
                                 ? locale->mode_usage
                                 : "Usage: %smode <chat|command|toggle>";

  if (working[0] == '\0') {
    const char *current_label =
        (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) ? command_label : chat_label;
    char status_line[128];
    const char *status_args[] = {current_label};
    session_format_template(status_format, status_args, sizeof(status_args) / sizeof(status_args[0]), status_line,
                            sizeof(status_line));
    session_send_system_line(ctx, status_line);

    const char *explain = (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) ? explain_command : explain_chat;
    char explain_line[SSH_CHATTER_MESSAGE_LIMIT];
    const char *explain_args[] = {prefix};
    session_format_template(explain, explain_args, sizeof(explain_args) / sizeof(explain_args[0]), explain_line,
                            sizeof(explain_line));
    session_send_system_line(ctx, explain_line);
    return;
  }

  const bool matches_chat = (strcasecmp(working, "chat") == 0) ||
                            (chat_label != NULL && chat_label[0] != '\0' && strcmp(working, chat_label) == 0);
  if (matches_chat) {
    if (ctx->input_mode == SESSION_INPUT_MODE_CHAT) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      const char *args[] = {prefix};
      session_format_template(already_chat, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
      session_send_system_line(ctx, message);
      return;
    }
    ctx->input_mode = SESSION_INPUT_MODE_CHAT;
    session_refresh_input_line(ctx);
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    const char *args[] = {prefix};
    session_format_template(enabled_chat, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
    session_send_system_line(ctx, message);
    return;
  }

  const bool matches_command = (strcasecmp(working, "command") == 0) ||
                               (command_label != NULL && command_label[0] != '\0' &&
                                strcmp(working, command_label) == 0);
  if (matches_command) {
    if (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) {
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      const char *args[] = {prefix};
      session_format_template(already_command, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
      session_send_system_line(ctx, message);
      return;
    }
    ctx->input_mode = SESSION_INPUT_MODE_COMMAND;
    session_refresh_input_line(ctx);
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    const char *args[] = {prefix};
    session_format_template(enabled_command, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
    session_send_system_line(ctx, message);
    return;
  }

  if (strcasecmp(working, "toggle") == 0) {
    ctx->input_mode =
        (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) ? SESSION_INPUT_MODE_CHAT : SESSION_INPUT_MODE_COMMAND;
    session_refresh_input_line(ctx);
    const char *format = (ctx->input_mode == SESSION_INPUT_MODE_COMMAND) ? enabled_command : enabled_chat;
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    const char *args[] = {prefix};
    session_format_template(format, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
    session_send_system_line(ctx, message);
    return;
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  const char *args[] = {prefix};
  session_format_template(usage_format, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
  session_send_system_line(ctx, message);
}

static void session_handle_history(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  size_t command_indices[SSH_CHATTER_INPUT_HISTORY_LIMIT];
  size_t command_count = 0U;
  for (size_t idx = 0U; idx < ctx->input_history_count; ++idx) {
    if (ctx->input_history_is_command[idx]) {
      command_indices[command_count++] = idx;
    }
  }

  if (command_count == 0U) {
    session_send_system_line(ctx, "No command history recorded yet.");
    return;
  }

  size_t limit = command_count;
  if (arguments != NULL) {
    char working[32];
    snprintf(working, sizeof(working), "%s", arguments);
    trim_whitespace_inplace(working);
    if (working[0] != '\0') {
      char *end = NULL;
      errno = 0;
      long requested = strtol(working, &end, 10);
      if (errno != 0 || end == working || *end != '\0' || requested <= 0) {
        session_send_system_line(ctx, "Usage: /history [count]");
        return;
      }
      if ((size_t)requested < limit) {
        limit = (size_t)requested;
      }
    }
  }

  session_send_system_line(ctx, "Command history (newest first):");

  for (size_t displayed = 0U; displayed < limit; ++displayed) {
    size_t source_index = command_indices[command_count - 1U - displayed];
    const char *entry = ctx->input_history[source_index];
    if (entry == NULL || entry[0] == '\0') {
      continue;
    }
    char normalized[SSH_CHATTER_MAX_INPUT_LEN];
    normalized[0] = '\0';
    const char *prefix = session_command_prefix(ctx);
    const char *display_prefix = (prefix != NULL && prefix[0] != '\0') ? prefix : "/";
    size_t prefix_len = strlen(display_prefix);
    bool has_prefix = false;
    if (prefix_len > 0U) {
      has_prefix = strncmp(entry, display_prefix, prefix_len) == 0;
    } else {
      has_prefix = entry[0] == '/';
    }

    if (!has_prefix) {
      snprintf(normalized, sizeof(normalized), "%s%s", display_prefix, entry);
    } else {
      snprintf(normalized, sizeof(normalized), "%s", entry);
    }

    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "%2zu. %s", displayed + 1U, normalized);
    session_send_system_line(ctx, line);
  }

  session_refresh_input_line(ctx);
}

typedef struct session_weather_buffer {
  char *data;
  size_t length;
} session_weather_buffer_t;

static size_t session_weather_write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
  session_weather_buffer_t *buffer = (session_weather_buffer_t *)userp;
  const size_t total = size * nmemb;
  if (buffer == NULL || total == 0U) {
    return 0U;
  }

  char *resized = realloc(buffer->data, buffer->length + total + 1U);
  if (resized == NULL) {
    return 0U;
  }

  buffer->data = resized;
  memcpy(buffer->data + buffer->length, contents, total);
  buffer->length += total;
  buffer->data[buffer->length] = '\0';
  return total;
}

static bool session_fetch_weather_summary(const char *region, const char *city, char *summary, size_t summary_len) {
  if (region == NULL || city == NULL || summary == NULL || summary_len == 0U) {
    return false;
  }

  CURL *curl = curl_easy_init();
  if (curl == NULL) {
    return false;
  }

  bool success = false;
  session_weather_buffer_t buffer = {0};
  char query[128];
  snprintf(query, sizeof(query), "%s %s", region, city);

  char *escaped = curl_easy_escape(curl, query, 0);
  if (escaped == NULL) {
    goto cleanup;
  }

  char url[512];
  static const char *kFormat = "%25l:%20%25C,%20%25t";
  int written = snprintf(url, sizeof(url), "https://wttr.in/%s?format=%s", escaped, kFormat);
  curl_free(escaped);
  if (written < 0 || (size_t)written >= sizeof(url)) {
    goto cleanup;
  }

  curl_easy_setopt(curl, CURLOPT_URL, url);
  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
  curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, session_weather_write_callback);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);

  CURLcode result = curl_easy_perform(curl);
  if (result != CURLE_OK) {
    goto cleanup;
  }

  long status = 0;
  curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &status);
  if (status < 200L || status >= 300L || buffer.data == NULL) {
    goto cleanup;
  }

  char *trimmed = buffer.data;
  while (*trimmed != '\0' && isspace((unsigned char)*trimmed)) {
    ++trimmed;
  }
  size_t end = strlen(trimmed);
  while (end > 0U && isspace((unsigned char)trimmed[end - 1U])) {
    trimmed[--end] = '\0';
  }

  if (trimmed[0] == '\0') {
    goto cleanup;
  }

  snprintf(summary, summary_len, "%s", trimmed);
  success = true;

cleanup:
  curl_easy_cleanup(curl);
  return success;
}

static void session_handle_status(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /status <message|clear>";
  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/status", kUsage, usage, sizeof(usage));
  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char working[SSH_CHATTER_STATUS_LEN];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  if (session_argument_is_disable(working) || strcasecmp(working, "clear") == 0) {
    ctx->status_message[0] = '\0';
    session_send_system_line(ctx, "Status cleared.");
    return;
  }

  snprintf(ctx->status_message, sizeof(ctx->status_message), "%s", working);
  session_send_system_line(ctx, "Status updated.");
}

static void session_handle_showstatus(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /showstatus <username>";
  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/showstatus", kUsage, usage, sizeof(usage));
  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char target_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(target_name, sizeof(target_name), "%s", arguments);
  trim_whitespace_inplace(target_name);

  if (target_name[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  session_ctx_t *target = chat_room_find_user(&ctx->owner->room, target_name);
  if (target == NULL) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "User '%s' is not connected.", target_name);
    session_send_system_line(ctx, message);
    return;
  }

  if (target->status_message[0] == '\0') {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "[%s] has not set a status.", target->user.name);
    session_send_system_line(ctx, message);
    return;
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "[%s]'s status: %s", target->user.name, target->status_message);
  session_send_system_line(ctx, message);
}

static void session_handle_weather(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /weather <region> <city>";
  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/weather", kUsage, usage, sizeof(usage));
  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  const char *cursor = arguments;
  while (*cursor != '\0' && !isspace((unsigned char)*cursor)) {
    ++cursor;
  }

  if (*cursor == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  size_t region_len = (size_t)(cursor - arguments);
  char region[64];
  if (region_len >= sizeof(region)) {
    session_send_system_line(ctx, "Region name is too long.");
    return;
  }
  memcpy(region, arguments, region_len);
  region[region_len] = '\0';
  trim_whitespace_inplace(region);

  while (*cursor != '\0' && isspace((unsigned char)*cursor)) {
    ++cursor;
  }

  if (*cursor == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char city[64];
  snprintf(city, sizeof(city), "%s", cursor);
  trim_whitespace_inplace(city);

  if (region[0] == '\0' || city[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  char summary[256];
  if (!session_fetch_weather_summary(region, city, summary, sizeof(summary))) {
    session_send_system_line(ctx, "Failed to fetch weather information. Please try again later.");
    return;
  }

  char message[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(message, sizeof(message), "%s", summary);
  session_send_system_line(ctx, message);
}

static void session_handle_translate(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  char working[16];
  if (arguments == NULL) {
    working[0] = '\0';
  } else {
    snprintf(working, sizeof(working), "%s", arguments);
  }
  trim_whitespace_inplace(working);

  if (working[0] == '\0') {
    session_send_system_line(ctx, "Usage: /translate <on|off>");
    return;
  }

  if (session_argument_is_disable(working)) {
    ctx->translation_enabled = false;
    ctx->translation_quota_notified = false;
    session_translation_clear_queue(ctx);
    session_send_system_line(ctx, "Translation disabled. New messages will be delivered without translation.");
    if (ctx->owner != NULL) {
      host_store_translation_preferences(ctx->owner, ctx);
    }
    return;
  }

  bool enabled = false;
  if (!parse_bool_token(working, &enabled)) {
    if (strcasecmp(working, "enable") == 0 || strcasecmp(working, "enabled") == 0) {
      enabled = true;
    } else {
      session_send_system_line(ctx, "Usage: /translate <on|off>");
      return;
    }
  }

  ctx->translation_enabled = enabled;
  ctx->translation_quota_notified = false;
  if (enabled) {
    session_send_system_line(ctx, "Translation enabled. Configure directions with /set-trans-lang or /set-target-lang.");
  } else {
    session_translation_clear_queue(ctx);
    session_send_system_line(ctx, "Translation disabled. New messages will be delivered without translation.");
  }
  if (ctx->owner != NULL) {
    host_store_translation_preferences(ctx->owner, ctx);
  }
}

static void session_handle_translate_scope(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may manage translation scope.");
    return;
  }

  char token[16];
  token[0] = '\0';
  if (arguments != NULL) {
    const char *cursor = arguments;
    while (*cursor == ' ' || *cursor == '\t') {
      ++cursor;
    }

    size_t length = 0U;
    while (cursor[length] != '\0' && !isspace((unsigned char)cursor[length]) && length + 1U < sizeof(token)) {
      token[length] = cursor[length];
      ++length;
    }
    token[length] = '\0';
  }

  if (token[0] == '\0') {
    const bool limited = translator_should_limit_to_chat_bbs();
    const bool forced = translator_is_ollama_only();
    const bool manual = translator_is_manual_chat_bbs_only();
    const bool skip_scrollback = translator_is_manual_skip_scrollback();

    char status[SSH_CHATTER_MESSAGE_LIMIT];
    if (limited) {
      if (skip_scrollback) {
        snprintf(status, sizeof(status),
                 "Translation scope is currently limited to chat messages and BBS posts. Scrollback translation is disabled.");
      } else {
        snprintf(status, sizeof(status), "Translation scope is currently limited to chat messages and BBS posts.");
      }
    } else {
      snprintf(status, sizeof(status),
               "Translation scope currently includes system output and bulk messages.");
    }
    session_send_system_line(ctx, status);

    if (forced) {
      session_send_system_line(ctx,
                               "Gemini translation is unavailable; Ollama fallback enforces chat/BBS-only scope.");
    } else if (manual) {
      if (skip_scrollback) {
        session_send_system_line(ctx, "Chat/BBS-only scope is enabled manually. Scrollback translation is suppressed.");
      } else {
        session_send_system_line(ctx, "Chat/BBS-only scope is enabled manually.");
      }
    }

    session_send_system_line(ctx, "Usage: /translate-scope <chat|chat-nohistory|all>");
    return;
  }

  if (strcasecmp(token, "chat") == 0 || strcasecmp(token, "limit") == 0 || strcasecmp(token, "on") == 0) {
    if (translator_is_manual_chat_bbs_only() && !translator_is_manual_skip_scrollback()) {
      session_send_system_line(ctx,
                               "Translation scope is already limited to chat messages and BBS posts.");
      return;
    }

    translator_set_manual_chat_bbs_only(true);
    translator_set_manual_skip_scrollback(false);
    session_send_system_line(ctx, "Translation scope limited to chat messages and BBS posts.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice), "* [%s] limited translation scope to chat and BBS posts.", ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
    return;
  }

  if (strcasecmp(token, "chat-nohistory") == 0 || strcasecmp(token, "chat_nohistory") == 0 ||
      strcasecmp(token, "chat-nohist") == 0) {
    if (translator_is_manual_chat_bbs_only() && translator_is_manual_skip_scrollback()) {
      session_send_system_line(ctx,
                               "Translation scope is already limited to chat/BBS posts with scrollback translation disabled.");
      return;
    }

    translator_set_manual_chat_bbs_only(true);
    translator_set_manual_skip_scrollback(true);
    session_send_system_line(ctx,
                             "Translation scope limited to chat messages and BBS posts. Scrollback translation is disabled.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice),
             "* [%s] limited translation scope to chat/BBS posts and disabled scrollback translation.", ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
    return;
  }

  if (strcasecmp(token, "all") == 0 || strcasecmp(token, "full") == 0 || strcasecmp(token, "off") == 0) {
    if (translator_is_ollama_only()) {
      session_send_system_line(ctx,
                               "Full translation scope cannot be restored while Gemini is unavailable."
                               " Ollama-only mode restricts translation to chat and BBS posts.");
      return;
    }

    if (!translator_is_manual_chat_bbs_only()) {
      session_send_system_line(ctx,
                               "Translation scope already includes system output and bulk messages.");
      return;
    }

    translator_set_manual_chat_bbs_only(false);
    translator_set_manual_skip_scrollback(false);
    session_send_system_line(ctx,
                             "Full translation scope restored. System output and bulk messages are eligible for translation.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice), "* [%s] restored full translation scope for translations.", ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
    return;
  }

  session_send_system_line(ctx, "Usage: /translate-scope <chat-nohistory|chat|all>");
}

static void session_handle_gemini(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may manage Gemini translation.");
    return;
  }

  const char *cursor = arguments;
  while (cursor != NULL && (*cursor == ' ' || *cursor == '\t')) {
    ++cursor;
  }

  char token[16];
  token[0] = '\0';
  if (cursor != NULL && *cursor != '\0') {
    size_t length = 0U;
    while (cursor[length] != '\0' && !isspace((unsigned char)cursor[length]) && length + 1U < sizeof(token)) {
      token[length] = cursor[length];
      ++length;
    }
    token[length] = '\0';
  }

  if (token[0] == '\0') {
    bool enabled = translator_is_gemini_enabled();
    bool manual = translator_is_gemini_manually_disabled();
    struct timespec remaining = {0, 0};
    bool cooldown_active = translator_gemini_backoff_remaining(&remaining);

    char status_line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(status_line, sizeof(status_line), "Gemini translation is currently %s.", enabled ? "enabled" : "disabled");
    session_send_system_line(ctx, status_line);

    if (manual) {
      session_send_system_line(ctx, "Gemini usage is manually disabled. Use /gemini on to re-enable it.");
    }

    if (cooldown_active) {
      long long seconds = remaining.tv_sec;
      if (remaining.tv_nsec > 0L) {
        ++seconds;
      }
      long long hours = seconds / 3600LL;
      long long minutes = (seconds % 3600LL) / 60LL;
      long long secs = seconds % 60LL;

      char cooldown_line[SSH_CHATTER_MESSAGE_LIMIT];
      if (hours > 0) {
        snprintf(cooldown_line, sizeof(cooldown_line),
                 "Automatic Gemini cooldown ends in %lldh %lldm %llds.", hours, minutes, secs);
      } else if (minutes > 0) {
        snprintf(cooldown_line, sizeof(cooldown_line),
                 "Automatic Gemini cooldown ends in %lldm %llds.", minutes, secs);
      } else {
        snprintf(cooldown_line, sizeof(cooldown_line),
                 "Automatic Gemini cooldown ends in %lld seconds.", secs > 0 ? secs : 1LL);
      }
      session_send_system_line(ctx, cooldown_line);
    }

    session_send_system_line(ctx, "Usage: /gemini <on|off>");
    session_send_system_line(ctx, "Use /gemini-unfreeze to clear the automatic cooldown manually.");
    return;
  }

  if (strcasecmp(token, "on") == 0) {
    translator_set_gemini_enabled(true);
    session_send_system_line(ctx, "Gemini translation enabled. Ollama fallback remains available.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice), "* [%s] enabled Gemini translation; Ollama fallback remains available.",
             ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
    return;
  }

  if (strcasecmp(token, "off") == 0) {
    translator_set_gemini_enabled(false);
    session_send_system_line(ctx, "Gemini translation disabled. Using Ollama gemma2:2b only.");
    session_send_system_line(ctx, "While Gemini is off, only chat messages and BBS posts will be translated.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice),
             "* [%s] disabled Gemini translation; using Ollama fallback only (chat and BBS posts).", ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
    return;
  }

  session_send_system_line(ctx, "Usage: /gemini <on|off>");
}

static void session_handle_captcha(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may control captcha requirements.");
    return;
  }

  char token[16];
  if (arguments != NULL) {
    snprintf(token, sizeof(token), "%s", arguments);
    trim_whitespace_inplace(token);
  } else {
    token[0] = '\0';
  }

  host_t *host = ctx->owner;
  if (token[0] == '\0') {
    bool enabled = atomic_load(&host->captcha_enabled);
    char status[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(status, sizeof(status), "Captcha is currently %s.", enabled ? "enabled" : "disabled");
    session_send_system_line(ctx, status);
    session_send_system_line(ctx, "Usage: /captcha <on|off>");
    return;
  }

  if (strcasecmp(token, "on") == 0) {
    bool was_enabled = atomic_exchange(&host->captcha_enabled, true);
    if (was_enabled) {
      session_send_system_line(ctx, "Captcha is already enabled.");
    } else {
      session_send_system_line(ctx, "Captcha enabled. New connections must solve the puzzle.");
      char notice[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(notice, sizeof(notice), "* [%s] enabled captcha for new connections.", ctx->user.name);
      host_history_record_system(host, notice);
      chat_room_broadcast(&host->room, notice, NULL);
      pthread_mutex_lock(&host->lock);
      host_state_save_locked(host);
      pthread_mutex_unlock(&host->lock);
    }
    return;
  }

  if (strcasecmp(token, "off") == 0) {
    bool was_enabled = atomic_exchange(&host->captcha_enabled, false);
    if (!was_enabled) {
      session_send_system_line(ctx, "Captcha is already disabled.");
    } else {
      session_send_system_line(ctx, "Captcha disabled. New connections will skip the puzzle.");
      char notice[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(notice, sizeof(notice), "* [%s] disabled captcha for new connections.", ctx->user.name);
      host_history_record_system(host, notice);
      chat_room_broadcast(&host->room, notice, NULL);
      pthread_mutex_lock(&host->lock);
      host_state_save_locked(host);
      pthread_mutex_unlock(&host->lock);
    }
    return;
  }

  session_send_system_line(ctx, "Usage: /captcha <on|off>");
}

static void session_handle_eliza(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may control eliza.");
    return;
  }

  char token[32];
  if (arguments != NULL) {
    snprintf(token, sizeof(token), "%s", arguments);
    trim_whitespace_inplace(token);
  } else {
    token[0] = '\0';
  }

  if (token[0] == '\0') {
    bool enabled = atomic_load(&ctx->owner->eliza_enabled);
    char status[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(status, sizeof(status), "eliza is currently %s.", enabled ? "enabled" : "disabled");
    session_send_system_line(ctx, status);
    session_send_system_line(ctx, "Usage: /eliza <on|off>");
    return;
  }

  if (strcasecmp(token, "on") == 0) {
    if (host_eliza_enable(ctx->owner)) {
      session_send_system_line(ctx, "eliza enabled. She will now mingle with the room and watch for severe issues.");
    } else {
      session_send_system_line(ctx, "eliza is already active.");
    }
    return;
  }

  if (strcasecmp(token, "off") == 0) {
    if (host_eliza_disable(ctx->owner)) {
      session_send_system_line(ctx, "eliza disabled. She will no longer intervene.");
    } else {
      session_send_system_line(ctx, "eliza is already inactive.");
    }
    return;
  }

  session_send_system_line(ctx, "Usage: /eliza <on|off>");
}

static void session_handle_eliza_chat(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  static const char *kUsage = "Usage: /eliza-chat <message>";

  char usage[SSH_CHATTER_MESSAGE_LIMIT];
  session_command_format_usage(ctx, "/eliza-chat", kUsage, usage, sizeof(usage));

  if (arguments == NULL) {
    session_send_system_line(ctx, usage);
    return;
  }

  char prompt[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(prompt, sizeof(prompt), "%s", arguments);
  trim_whitespace_inplace(prompt);

  if (prompt[0] == '\0') {
    session_send_system_line(ctx, usage);
    return;
  }

  host_t *host = ctx->owner;
  if (!atomic_load(&host->eliza_enabled)) {
    (void)host_eliza_enable(host);
  }

  char memory_context[SSH_CHATTER_ELIZA_CONTEXT_BUFFER];
  memory_context[0] = '\0';
  size_t memory_count = host_eliza_memory_collect_context(host, prompt, memory_context, sizeof(memory_context));

  char history_context[SSH_CHATTER_ELIZA_CONTEXT_BUFFER];
  history_context[0] = '\0';
  size_t history_count = host_eliza_history_collect_context(host, history_context, sizeof(history_context));

  char bbs_context[SSH_CHATTER_ELIZA_CONTEXT_BUFFER];
  bbs_context[0] = '\0';
  size_t bbs_count = host_eliza_bbs_collect_context(host, bbs_context, sizeof(bbs_context));

  const bool has_memory_context = memory_count > 0U && memory_context[0] != '\0';
  const bool has_history_context = history_count > 0U && history_context[0] != '\0';
  const bool has_bbs_context = bbs_count > 0U && bbs_context[0] != '\0';

  char formatted_prompt[SSH_CHATTER_ELIZA_PROMPT_BUFFER];
  size_t prompt_offset = 0U;
  int base_written = snprintf(formatted_prompt, sizeof(formatted_prompt),
                              "You are eliza, a calm and safety-focused chat companion in a shared room."
                              " You have operator-level visibility over the chat and shared bulletin board so you can"
                              " respond quickly to dangerous statements. When helpful, remind people of legal and safety"
                              " boundaries and encourage contacting local authorities for imminent danger.");
  if (base_written < 0) {
    formatted_prompt[0] = '\0';
    prompt_offset = 0U;
  } else {
    prompt_offset = (size_t)base_written;
    if (prompt_offset >= sizeof(formatted_prompt)) {
      prompt_offset = sizeof(formatted_prompt) - 1U;
      formatted_prompt[prompt_offset] = '\0';
    }
  }

  if (has_history_context && prompt_offset + 1U < sizeof(formatted_prompt)) {
    int written = snprintf(formatted_prompt + prompt_offset, sizeof(formatted_prompt) - prompt_offset,
                           "\n\nRecent chat history:\n%s", history_context);
    if (written > 0) {
      size_t used = (size_t)written;
      if (used >= sizeof(formatted_prompt) - prompt_offset) {
        prompt_offset = sizeof(formatted_prompt) - 1U;
        formatted_prompt[prompt_offset] = '\0';
      } else {
        prompt_offset += used;
      }
    }
  }

  if (has_bbs_context && prompt_offset + 1U < sizeof(formatted_prompt)) {
    int written = snprintf(formatted_prompt + prompt_offset, sizeof(formatted_prompt) - prompt_offset,
                           "\n\nRecent BBS activity:\n%s", bbs_context);
    if (written > 0) {
      size_t used = (size_t)written;
      if (used >= sizeof(formatted_prompt) - prompt_offset) {
        prompt_offset = sizeof(formatted_prompt) - 1U;
        formatted_prompt[prompt_offset] = '\0';
      } else {
        prompt_offset += used;
      }
    }
  }

  if (has_memory_context && prompt_offset + 1U < sizeof(formatted_prompt)) {
    int written = snprintf(formatted_prompt + prompt_offset, sizeof(formatted_prompt) - prompt_offset,
                           "\n\nMemories:\n%s", memory_context);
    if (written > 0) {
      size_t used = (size_t)written;
      if (used >= sizeof(formatted_prompt) - prompt_offset) {
        prompt_offset = sizeof(formatted_prompt) - 1U;
        formatted_prompt[prompt_offset] = '\0';
      } else {
        prompt_offset += used;
      }
    }
  }

  if (prompt_offset + 1U < sizeof(formatted_prompt)) {
    int written = snprintf(formatted_prompt + prompt_offset, sizeof(formatted_prompt) - prompt_offset,
                           "\n\nUser (%s) says:\n%s\n\nRespond as eliza with empathy and brevity.", ctx->user.name,
                           prompt);
    if (written > 0) {
      size_t used = (size_t)written;
      if (used >= sizeof(formatted_prompt) - prompt_offset) {
        prompt_offset = sizeof(formatted_prompt) - 1U;
        formatted_prompt[prompt_offset] = '\0';
      } else {
        prompt_offset += used;
      }
    }
  }

  session_send_private_message_line(ctx, ctx, "you -> eliza", prompt);

  if (!session_translation_worker_ensure(ctx)) {
    session_send_system_line(ctx, "eliza can't reply right now. Try again in a moment.");
    return;
  }

  translation_job_t *job = session_translation_job_alloc();
  if (job == NULL) {
    session_send_system_line(ctx, "eliza can't reply right now. Try again in a moment.");
    return;
  }

  job->type = TRANSLATION_JOB_ELIZA_CHAT;
  job->placeholder_lines = 0U;
  job->target_language[0] = '\0';
  snprintf(job->data.eliza.prompt, sizeof(job->data.eliza.prompt), "%s", prompt);
  snprintf(job->data.eliza.formatted_prompt, sizeof(job->data.eliza.formatted_prompt), "%s", formatted_prompt);

  pthread_mutex_lock(&ctx->translation_mutex);
  job->next = NULL;
  if (ctx->translation_pending_tail != NULL) {
    ctx->translation_pending_tail->next = job;
  } else {
    ctx->translation_pending_head = job;
  }
  ctx->translation_pending_tail = job;
  pthread_cond_signal(&ctx->translation_cond);
  pthread_mutex_unlock(&ctx->translation_mutex);

  session_send_system_line(ctx, "eliza is thinking...");
}

static void session_handle_gemini_unfreeze(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->user.is_operator && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "Only operators may manage Gemini translation.");
    return;
  }

  struct timespec remaining = {0, 0};
  bool cooldown_active = translator_gemini_backoff_remaining(&remaining);
  translator_clear_gemini_backoff();

  if (cooldown_active) {
    session_send_system_line(ctx, "Automatic Gemini cooldown cleared. Translations may resume immediately.");

    char notice[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(notice, sizeof(notice), "* [%s] cleared the automatic Gemini cooldown.", ctx->user.name);
    host_history_record_system(ctx->owner, notice);
    chat_room_broadcast(&ctx->owner->room, notice, NULL);
  } else {
    session_send_system_line(ctx, "No automatic Gemini cooldown was active.");
  }
}

static void session_handle_palette(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (arguments == NULL) {
    session_send_system_line(ctx, "Usage: /palette <name> (try /palette list)");
    return;
  }

  char working[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(working, sizeof(working), "%s", arguments);
  trim_whitespace_inplace(working);

  if (working[0] == '\0' || strcasecmp(working, "list") == 0) {
    session_send_system_line(ctx, "Available palettes:");
    for (size_t idx = 0U; idx < sizeof(PALETTE_DEFINITIONS) / sizeof(PALETTE_DEFINITIONS[0]); ++idx) {
      const palette_descriptor_t *descriptor = &PALETTE_DEFINITIONS[idx];
      char line[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(line, sizeof(line), "  %s - %s", descriptor->name, descriptor->description);
      session_send_system_line(ctx, line);
    }
    session_send_system_line(ctx, "Apply a palette with /palette <name>.");
    return;
  }

  const palette_descriptor_t *descriptor = palette_find_descriptor(working);
  if (descriptor == NULL) {
    char line[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(line, sizeof(line), "Unknown palette '%.32s'. Use /palette list to see options.", working);
    session_send_system_line(ctx, line);
    return;
  }

  if (!palette_apply_to_session(ctx, descriptor)) {
    session_send_system_line(ctx, "Unable to apply that palette right now.");
    return;
  }

  session_apply_background_fill(ctx);

  char info[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(info, sizeof(info), "Palette '%s' applied - %s", descriptor->name, descriptor->description);
  session_send_system_line(ctx, info);
  session_render_separator(ctx, "Chatroom");
  session_render_prompt(ctx, true);

  if (ctx->owner != NULL) {
    host_store_user_theme(ctx->owner, ctx);
    host_store_system_theme(ctx->owner, ctx);
  }
}

static void session_handle_nick(session_ctx_t *ctx, const char *arguments) {
  if (ctx == NULL) {
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /nick <name>");
    return;
  }

  char new_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(new_name, sizeof(new_name), "%s", arguments);
  trim_whitespace_inplace(new_name);

  if (new_name[0] == '\0') {
    session_send_system_line(ctx, "Usage: /nick <name>");
    return;
  }

  if (ctx->user.is_lan_operator && strcmp(new_name, ctx->user.name) != 0) {
    session_send_system_line(ctx, "LAN operator nicknames are fixed.");
    return;
  }

  for (size_t idx = 0; new_name[idx] != '\0'; ++idx) {
    const unsigned char ch = (unsigned char)new_name[idx];
    if (ch <= 0x1FU || ch == 0x7FU || ch == ' ' || ch == '\t') {
      session_send_system_line(ctx, "Names may not include control characters or whitespace.");
      return;
    }
  }

  if (host_is_username_banned(ctx->owner, new_name)) {
    session_send_system_line(ctx,
                             "That nickname is blocked for bot detection. Choose another.");
    return;
  }

  if (host_username_reserved(ctx->owner, new_name) && !ctx->user.is_lan_operator) {
    session_send_system_line(ctx, "That name is reserved for LAN operators.");
    return;
  }

  session_ctx_t *existing = chat_room_find_user(&ctx->owner->room, new_name);
  if (existing != NULL && existing != ctx) {
    session_send_system_line(ctx, "That name is already taken.");
    return;
  }

  char old_name[SSH_CHATTER_USERNAME_LEN];
  snprintf(old_name, sizeof(old_name), "%s", ctx->user.name);
  snprintf(ctx->user.name, sizeof(ctx->user.name), "%s", new_name);

  char announcement[SSH_CHATTER_MESSAGE_LIMIT];
  snprintf(announcement, sizeof(announcement), "* [%s] is now known as [%s]", old_name, ctx->user.name);
  host_history_record_system(ctx->owner, announcement);
  chat_room_broadcast(&ctx->owner->room, announcement, NULL);
  session_apply_saved_preferences(ctx);
  session_send_system_line(ctx, "Display name updated.");
}

static void session_force_disconnect(session_ctx_t *ctx, const char *reason) {
  if (ctx == NULL) {
    return;
  }

  if (reason != NULL && reason[0] != '\0') {
    session_send_system_line(ctx, reason);
  }

  ctx->should_exit = true;
  ctx->exit_status = EXIT_FAILURE;

  if (ctx->translation_mutex_initialized) {
    pthread_mutex_lock(&ctx->translation_mutex);
    ctx->translation_thread_stop = true;
    pthread_cond_broadcast(&ctx->translation_cond);
    pthread_mutex_unlock(&ctx->translation_mutex);
  }
  session_translation_clear_queue(ctx);

  session_transport_request_close(ctx);
}

static void session_handle_exit(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_force_disconnect(ctx, "Disconnecting... bye!");
  ctx->exit_status = EXIT_SUCCESS;
}

static void session_handle_pardon(session_ctx_t *ctx, const char *arguments) {
  if (!ctx->user.is_operator) {
    session_send_system_line(ctx, "You are not allowed to pardon users.");
    return;
  }

  if (arguments == NULL || *arguments == '\0') {
    session_send_system_line(ctx, "Usage: /pardon <user|ip>");
    return;
  }

  char token[SSH_CHATTER_IP_LEN];
  snprintf(token, sizeof(token), "%s", arguments);
  trim_whitespace_inplace(token);

  if (token[0] == '\0') {
    session_send_system_line(ctx, "Usage: /pardon <user|ip>");
    return;
  }

  if (host_remove_ban_entry(ctx->owner, token)) {
    char message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(message, sizeof(message), "Ban lifted for '%s'.", token);
    session_send_system_line(ctx, message);
  } else {
    session_send_system_line(ctx, "No matching ban found.");
  }
}

static session_ctx_t *chat_room_find_user(chat_room_t *room, const char *username) {
  if (room == NULL || username == NULL) {
    return NULL;
  }

  session_ctx_t *result = NULL;
  pthread_mutex_lock(&room->lock);
  for (size_t idx = 0; idx < room->member_count; ++idx) {
    session_ctx_t *member = room->members[idx];
    if (member == NULL) {
      continue;
    }

    if (strncmp(member->user.name, username, SSH_CHATTER_USERNAME_LEN) == 0) {
      result = member;
      break;
    }
  }
  pthread_mutex_unlock(&room->lock);

  return result;
}

static bool host_username_reserved(host_t *host, const char *username) {
  if (host == NULL || username == NULL) {
    return false;
  }

  return host_is_lan_operator_username(host, username);
}

static join_activity_entry_t *host_find_join_activity_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL) {
    return NULL;
  }

  for (size_t idx = 0; idx < host->join_activity_count; ++idx) {
    join_activity_entry_t *entry = &host->join_activity[idx];
    if (strncmp(entry->ip, ip, SSH_CHATTER_IP_LEN) == 0) {
      return entry;
    }
  }

  return NULL;
}

static join_activity_entry_t *host_ensure_join_activity_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return NULL;
  }

  join_activity_entry_t *entry = host_find_join_activity_locked(host, ip);
  if (entry != NULL) {
    return entry;
  }

  if (host->join_activity_count >= host->join_activity_capacity) {
    size_t new_capacity = host->join_activity_capacity > 0U ? host->join_activity_capacity * 2U : 8U;
    join_activity_entry_t *resized =
        realloc(host->join_activity, new_capacity * sizeof(join_activity_entry_t));
    if (resized == NULL) {
      return NULL;
    }
    host->join_activity = resized;
    host->join_activity_capacity = new_capacity;
  }

  entry = &host->join_activity[host->join_activity_count++];
  memset(entry, 0, sizeof(*entry));
  snprintf(entry->ip, sizeof(entry->ip), "%s", ip);
  return entry;
}

static size_t host_prepare_join_delay(host_t *host, struct timespec *wait_duration) {
  struct timespec wait = {0, 0};
  if (host == NULL) {
    if (wait_duration != NULL) {
      *wait_duration = wait;
    }
    return 1U;
  }

  struct timespec now = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &now);

  pthread_mutex_lock(&host->lock);
  if (!host->join_throttle_initialised) {
    host->next_join_ready_time = now;
    host->join_throttle_initialised = true;
    host->join_progress_length = 0U;
  }

  if (timespec_compare(&now, &host->next_join_ready_time) < 0) {
    wait = timespec_diff(&host->next_join_ready_time, &now);
  }

  struct timespec base = now;
  if (timespec_compare(&host->next_join_ready_time, &now) > 0) {
    base = host->next_join_ready_time;
  }
  host->next_join_ready_time = timespec_add_ms(&base, 100);
  host->join_progress_length = (host->join_progress_length % SSH_CHATTER_JOIN_BAR_MAX) + 1U;
  size_t progress = host->join_progress_length;
  pthread_mutex_unlock(&host->lock);

  if (wait_duration != NULL) {
    *wait_duration = wait;
  }
  return progress;
}

static host_join_attempt_result_t host_register_join_attempt(host_t *host, const char *username, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return HOST_JOIN_ATTEMPT_OK;
  }

  struct timespec now = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &now);

  bool ban_ip = false;
  bool ban_same_name = false;
  bool exempt_ip = false;
  bool kick_ip = false;

  pthread_mutex_lock(&host->lock);
  join_activity_entry_t *entry = host_ensure_join_activity_locked(host, ip);
  if (entry == NULL) {
    pthread_mutex_unlock(&host->lock);
    return HOST_JOIN_ATTEMPT_OK;
  }

  struct timespec diff = timespec_diff(&now, &entry->last_attempt);
  const long long diff_ns = (long long)diff.tv_sec * 1000000000LL + (long long)diff.tv_nsec;
  const bool has_prior_attempt = (entry->last_attempt.tv_sec != 0 || entry->last_attempt.tv_nsec != 0);
  const bool within_window = has_prior_attempt && diff_ns <= SSH_CHATTER_JOIN_RAPID_WINDOW_NS;

  if (within_window) {
    entry->rapid_attempts += 1U;
  } else {
    entry->rapid_attempts = 1U;
  }

  if (username != NULL && username[0] != '\0') {
    if (within_window && strncmp(entry->last_username, username, SSH_CHATTER_USERNAME_LEN) == 0) {
      entry->same_name_attempts += 1U;
    } else {
      entry->same_name_attempts = 1U;
      snprintf(entry->last_username, sizeof(entry->last_username), "%s", username);
    }
  } else {
    entry->same_name_attempts = within_window ? entry->same_name_attempts + 1U : 1U;
  }

  const bool has_join_window = entry->join_window_start.tv_sec != 0 || entry->join_window_start.tv_nsec != 0;
  if (!has_join_window) {
    entry->join_window_start = now;
    entry->join_window_attempts = 1U;
  } else {
    struct timespec window_diff = timespec_diff(&now, &entry->join_window_start);
    const long long window_ns = (long long)window_diff.tv_sec * 1000000000LL + (long long)window_diff.tv_nsec;
    if (window_ns > SSH_CHATTER_JOIN_KICK_WINDOW_NS) {
      entry->join_window_start = now;
      entry->join_window_attempts = 1U;
    } else {
      if (entry->join_window_attempts < SIZE_MAX) {
        entry->join_window_attempts += 1U;
      }
    }
  }

  entry->last_attempt = now;

  if (host_ip_has_grant_locked(host, ip)) {
    exempt_ip = true;
  }

  if (!exempt_ip && within_window && entry->rapid_attempts >= SSH_CHATTER_JOIN_IP_THRESHOLD) {
    ban_ip = true;
  }
  if (within_window && entry->same_name_attempts >= SSH_CHATTER_JOIN_NAME_THRESHOLD) {
    ban_same_name = true;
  }
  if (!exempt_ip && entry->join_window_attempts >= SSH_CHATTER_JOIN_KICK_THRESHOLD) {
    kick_ip = true;
  }
  pthread_mutex_unlock(&host->lock);

  if (!exempt_ip && (ban_ip || ban_same_name)) {
    const char *ban_user = (ban_same_name && username != NULL && username[0] != '\0') ? username : "";
    (void)host_add_ban_entry(host, ban_user, ip);

    if (ban_ip && ban_same_name) {
      printf("[auto-ban] %s (%s) banned for rapid reconnects and repeated username attempts\n", ip,
             ban_user[0] != '\0' ? ban_user : "unknown");
    } else if (ban_ip) {
      printf("[auto-ban] %s banned for rapid reconnects\n", ip);
    } else {
      printf("[auto-ban] %s (%s) banned for repeated username attempts\n", ip,
             ban_user[0] != '\0' ? ban_user : "unknown");
    }
    return HOST_JOIN_ATTEMPT_BAN;
  }

  if (!exempt_ip && kick_ip) {
    printf("[auto-kick] %s exceeded join limit\n", ip);
    return HOST_JOIN_ATTEMPT_KICK;
  }

  return HOST_JOIN_ATTEMPT_OK;
}

static bool host_register_suspicious_activity(host_t *host, const char *username, const char *ip,
                                             size_t *attempts_out) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    if (attempts_out != NULL) {
      *attempts_out = 0U;
    }
    return false;
  }

  struct timespec now = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &now);

  size_t attempts = 0U;
  pthread_mutex_lock(&host->lock);
  join_activity_entry_t *entry = host_ensure_join_activity_locked(host, ip);
  if (entry != NULL) {
    if (entry->last_suspicious.tv_sec != 0 || entry->last_suspicious.tv_nsec != 0) {
      struct timespec diff = timespec_diff(&now, &entry->last_suspicious);
      long long diff_ns = (long long)diff.tv_sec * 1000000000LL + (long long)diff.tv_nsec;
      if (diff_ns > SSH_CHATTER_SUSPICIOUS_EVENT_WINDOW_NS) {
        entry->suspicious_events = 0U;
      }
    }

    if (entry->suspicious_events < SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD) {
      entry->suspicious_events += 1U;
    } else {
      entry->suspicious_events = SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD;
    }
    entry->last_suspicious = now;
    attempts = entry->suspicious_events;
  }
  pthread_mutex_unlock(&host->lock);

  if (attempts_out != NULL) {
    *attempts_out = attempts;
  }

  if (attempts >= SSH_CHATTER_SUSPICIOUS_EVENT_THRESHOLD) {
    const char *ban_user = (username != NULL && username[0] != '\0') ? username : "";
    (void)host_add_ban_entry(host, ban_user, ip);
    return true;
  }

  return false;
}

static bool host_is_ip_banned(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  bool banned = false;
  pthread_mutex_lock(&host->lock);
  if (host_is_protected_ip_unlocked(host, ip)) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }
  for (size_t idx = 0; idx < host->ban_count; ++idx) {
    const char *ban_ip = host->bans[idx].ip;
    if (ban_ip[0] == '\0') {
      continue;
    }

    if (host_is_protected_ip_unlocked(host, ban_ip)) {
      continue;
    }

    if (strchr(ban_ip, '/') != NULL) {
      if (host_cidr_contains_ip(ban_ip, ip)) {
        banned = true;
        break;
      }
      continue;
    }

    if (strncmp(ban_ip, ip, SSH_CHATTER_IP_LEN) == 0) {
      banned = true;
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  return banned;
}

static bool host_is_username_banned(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return false;
  }

  bool banned = false;
  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0; idx < host->ban_count; ++idx) {
    if (strncmp(host->bans[idx].username, username, SSH_CHATTER_USERNAME_LEN) == 0) {
      banned = true;
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  return banned;
}

static bool host_add_ban_entry(host_t *host, const char *username, const char *ip) {
  if (host == NULL) {
    return false;
  }

  bool added = false;
  pthread_mutex_lock(&host->lock);
  if (host->ban_count >= SSH_CHATTER_MAX_BANS) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }

  if (ip != NULL && ip[0] != '\0' && host_is_protected_ip_unlocked(host, ip)) {
    pthread_mutex_unlock(&host->lock);
    return true;
  }
  if (ip != NULL && ip[0] != '\0' && strchr(ip, '/') != NULL) {
    for (size_t idx = 0; idx < host->protected_ip_count && idx < SSH_CHATTER_MAX_PROTECTED_IPS; ++idx) {
      if (host_cidr_contains_ip(ip, host->protected_ips[idx])) {
        pthread_mutex_unlock(&host->lock);
        return true;
      }
    }
  }

  for (size_t idx = 0; idx < host->ban_count; ++idx) {
    const bool username_match = (username != NULL && username[0] != '\0' &&
                                 strncmp(host->bans[idx].username, username, SSH_CHATTER_USERNAME_LEN) == 0);
    const bool ip_match = (ip != NULL && ip[0] != '\0' &&
                           strncmp(host->bans[idx].ip, ip, SSH_CHATTER_IP_LEN) == 0);
    if (username_match || ip_match) {
      pthread_mutex_unlock(&host->lock);
      return true;
    }
  }

  strncpy(host->bans[host->ban_count].username,
          username != NULL ? username : "", SSH_CHATTER_USERNAME_LEN - 1U);
  host->bans[host->ban_count].username[SSH_CHATTER_USERNAME_LEN - 1U] = '\0';
  strncpy(host->bans[host->ban_count].ip, ip != NULL ? ip : "", SSH_CHATTER_IP_LEN - 1U);
  host->bans[host->ban_count].ip[SSH_CHATTER_IP_LEN - 1U] = '\0';
  ++host->ban_count;
  added = true;

  host_ban_state_save_locked(host);

  pthread_mutex_unlock(&host->lock);
  return added;
}

static bool host_remove_ban_entry(host_t *host, const char *token) {
  if (host == NULL || token == NULL || token[0] == '\0') {
    return false;
  }

  bool removed = false;
  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0; idx < host->ban_count; ++idx) {
    if (strncmp(host->bans[idx].username, token, SSH_CHATTER_USERNAME_LEN) == 0 ||
        strncmp(host->bans[idx].ip, token, SSH_CHATTER_IP_LEN) == 0) {
      for (size_t shift = idx; shift + 1U < host->ban_count; ++shift) {
        host->bans[shift] = host->bans[shift + 1U];
      }
      memset(&host->bans[host->ban_count - 1U], 0, sizeof(host->bans[host->ban_count - 1U]));
      --host->ban_count;
      removed = true;
      host_ban_state_save_locked(host);
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  return removed;
}

static bool session_parse_localized_command(session_ctx_t *ctx, const session_command_alias_t *alias, const char *line,
                                            const char **arguments) {
  if (alias == NULL) {
    return false;
  }

  if (session_parse_command(line, alias->canonical, arguments)) {
    return true;
  }

  session_ui_language_t language = session_ui_language_current(ctx);
  const char *preferred = session_command_alias_for_language(alias, language);
  if (preferred != NULL && strcmp(preferred, alias->canonical) != 0) {
    if (session_parse_command(line, preferred, arguments)) {
      return true;
    }
  }

  for (size_t idx = 0; idx < SESSION_UI_LANGUAGE_COUNT; ++idx) {
    const char *localized = alias->localized[idx];
    if (localized == NULL || localized[0] == '\0' || strcmp(localized, alias->canonical) == 0) {
      continue;
    }
    if (session_parse_command(line, localized, arguments)) {
      return true;
    }
  }

  return false;
}

static bool session_parse_command(const char *line, const char *command, const char **arguments) {
  if (line == NULL || command == NULL) {
    return false;
  }
  size_t command_len = strlen(command);

  if (strncmp(line, command, command_len) == 0) {
    const char boundary = line[command_len];
    if (boundary != '\0' && boundary != ' ' && boundary != '\t') {
      return false;
    }

    const char *args = line + command_len;

    while (*args == ' ' || *args == '\t') {
      ++args;
    }

    *arguments = args;
    return true;
  }
  return false;
}

static void session_dispatch_command(session_ctx_t *ctx, const char *line) {
  const char *args = NULL;
  const char *effective_line = line;

  // Handle double slash commands by effectively removing the first slash
  if (line != NULL && line[0] == '/' && line[1] == '/') {
    effective_line = line + 1;
  }

  if (session_parse_command_any(ctx, "/help", effective_line, &args)) {
    session_print_help(ctx);
    return;
  }

  else if (session_parse_command_any(ctx, "/advanced", effective_line, &args)) {
    session_print_help_extra(ctx);
    return;
  }

  else if (session_parse_command_any(ctx, "/history", effective_line, &args)) {
    session_handle_history(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/exit", effective_line, &args)) {
    ctx->ops->handle_exit(ctx);
    return;
  }

  else if (session_parse_command_any(ctx, "/nick", effective_line, &args)) {
    ctx->ops->handle_nick(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/pm", effective_line, &args)) {
    session_handle_pm(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/asciiart", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /asciiart");
    } else {
      session_asciiart_begin(ctx, SESSION_ASCIIART_TARGET_CHAT);
    }
    return;
  }

  else if (session_parse_command_any(ctx, "/motd", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /motd");
    } else {
      session_handle_motd(ctx);
    }
    return;
  }

  else if (session_parse_command_any(ctx, "/status", effective_line, &args)) {
    session_handle_status(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/showstatus", effective_line, &args)) {
    session_handle_showstatus(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/users", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /users");
    } else {
      session_handle_usercount(ctx);
    }
    return;
  }

  else if (session_parse_command_any(ctx, "/search", effective_line, &args)) {
    session_handle_search(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/chat", effective_line, &args)) {
    session_handle_chat_lookup(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/reply", effective_line, &args)) {
    session_handle_reply(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/image", effective_line, &args)) {
    session_handle_image(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/video", effective_line, &args)) {
    session_handle_video(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/audio", effective_line, &args)) {
    session_handle_audio(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/files", effective_line, &args)) {
    session_handle_files(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/mail", effective_line, &args)) {
    session_handle_mail(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/profilepic", effective_line, &args)) {
    session_handle_profile_picture(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/game", effective_line, &args)) {
    session_handle_game(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/banlist", effective_line, &args)) {
    session_handle_ban_list(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/banname", effective_line, &args)) {
    session_handle_ban_name(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/ban", effective_line, &args)) {
    session_handle_ban(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/delete-msg", effective_line, &args)) {
    session_handle_delete_message(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/block", effective_line, &args)) {
    session_handle_block(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/unblock", effective_line, &args)) {
    session_handle_unblock(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/pardon", effective_line, &args)) {
    session_handle_pardon(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/poke", effective_line, &args)) {
    session_handle_poke(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/color", effective_line, &args)) {
    session_handle_color(ctx, args);
    return;
  }

  else if (session_parse_command_any(ctx, "/systemcolor", effective_line, &args)) {
    session_handle_system_color(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/set-trans-lang", effective_line, &args)) {
    session_handle_set_trans_lang(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/set-target-lang", effective_line, &args)) {
    session_handle_set_target_lang(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/set-ui-lang", effective_line, &args)) {
    session_handle_set_ui_lang(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/weather", effective_line, &args)) {
    session_handle_weather(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/translate", effective_line, &args)) {
    session_handle_translate(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/translate-scope", effective_line, &args)) {
    session_handle_translate_scope(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/gemini-unfreeze", effective_line, &args)) {
    session_handle_gemini_unfreeze(ctx);
    return;
  }
  else if (session_parse_command_any(ctx, "/gemini", effective_line, &args)) {
    session_handle_gemini(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/captcha", effective_line, &args)) {
    session_handle_captcha(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/eliza", effective_line, &args)) {
    session_handle_eliza(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/eliza-chat", effective_line, &args)) {
    session_handle_eliza_chat(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/chat-spacing", effective_line, &args)) {
    session_handle_chat_spacing(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/mode", effective_line, &args)) {
    ctx->ops->handle_mode(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/palette", effective_line, &args)) {
    session_handle_palette(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/suspend!", effective_line, &args)) {
    if (ctx->game.active) {
      session_game_suspend(ctx, "Game suspended.");
    } else {
      session_game_suspend(ctx, NULL);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/today", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /today");
    } else {
      session_handle_today(ctx);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/date", effective_line, &args)) {
    session_handle_date(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/os", effective_line, &args)) {
    session_handle_os(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/getos", effective_line, &args)) {
    session_handle_getos(ctx, args);
    return;
  }
  else if (strncmp(effective_line, "/getaddr", 8) == 0) {
    const char *arguments = effective_line + 8;
    while (*arguments == ' ' || *arguments == '\t') {
      ++arguments;
    }
    session_handle_getaddr(ctx, arguments);
    return;
  }
  else if (session_parse_command_any(ctx, "/birthday", effective_line, &args)) {
    session_handle_birthday(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/soulmate", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /soulmate");
    } else {
      session_handle_soulmate(ctx);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/grant", effective_line, &args)) {
    session_handle_grant(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/revoke", effective_line, &args)) {
    session_handle_revoke(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/pair", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /pair");
    } else {
      session_handle_pair(ctx);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/connected", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /connected");
    } else {
      session_handle_connected(ctx);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/alpha-centauri-landers", effective_line, &args)) {
    if (*args != '\0') {
      session_send_system_line(ctx, "Usage: /alpha-centauri-landers");
    } else {
      session_handle_alpha_centauri_landers(ctx);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/poll", effective_line, &args)) {
    session_handle_poll(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/vote-single", effective_line, &args)) {
    if (*args == '\0') {
      session_handle_vote_command(ctx, NULL, false);
    } else {
      session_handle_vote_command(ctx, args, false);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/vote", effective_line, &args)) {
    if (*args == '\0') {
      session_handle_vote_command(ctx, NULL, true);
    } else {
      session_handle_vote_command(ctx, args, true);
    }
    return;
  }
  else if (session_parse_command_any(ctx, "/elect", effective_line, &args)) {
    if (*args == '\0') {
      session_handle_elect_command(ctx, NULL);
    } else {
      session_handle_elect_command(ctx, args);
    }
    return;
  }
  else if (session_parse_command(effective_line, "/rss", &args)) {
    session_handle_rss(ctx, args);
    return;
  }
  else if (session_parse_command_any(ctx, "/bbs", effective_line, &args)) {
    session_handle_bbs(ctx, (args != NULL && args[0] != '\0') ? args : NULL);
    return;
  }

  else if (session_parse_command(effective_line, "/kick", &args)) {
    session_handle_kick(ctx, args);
    return;
  }

  else if (effective_line[0] == '/') {
    if (isdigit((unsigned char)effective_line[1])) {
      char *endptr = NULL;
      unsigned long vote_index = strtoul(effective_line + 1, &endptr, 10);
      const unsigned long max_vote = sizeof(ctx->owner->poll.options) / sizeof(ctx->owner->poll.options[0]);
      if (vote_index >= 1UL && vote_index <= max_vote) {
        while (endptr != NULL && (*endptr == ' ' || *endptr == '\t')) {
          ++endptr;
        }
        if (endptr == NULL || *endptr == '\0') {
          session_handle_vote(ctx, (size_t)(vote_index - 1UL));
          return;
        } else {
          while (*endptr == ' ' || *endptr == '\t') {
            ++endptr;
          }
          if (*endptr != '\0') {
            char label[SSH_CHATTER_POLL_LABEL_LEN];
            size_t label_len = 0U;
            while (*endptr != '\0' && !isspace((unsigned char)*endptr)) {
              if (label_len + 1U >= sizeof(label)) {
                label_len = 0U;
                break;
              }
              label[label_len++] = *endptr++;
            }
            label[label_len] = '\0';
            if (label_len > 0U) {
              session_handle_named_vote(ctx, (size_t)(vote_index - 1UL), label);
              return;
            }
          }
        }
      }
    }
    for (size_t idx = 0U; idx < SSH_CHATTER_REACTION_KIND_COUNT; ++idx) {
      const reaction_descriptor_t *descriptor = &REACTION_DEFINITIONS[idx];
      char canonical[32];
      int written = snprintf(canonical, sizeof(canonical), "/%s", descriptor->command);
      if (written < 0 || (size_t)written >= sizeof(canonical)) {
        continue;
      }

      const char *arguments = NULL;
      if (!session_parse_command_any(ctx, canonical, effective_line, &arguments)) {
        continue;
      }

      session_handle_reaction(ctx, idx, arguments);
      return;
    }
  }

  const session_ui_locale_t *locale = session_ui_get_locale(ctx);
  const char *format = (locale->unknown_command != NULL && locale->unknown_command[0] != '\0')
                           ? locale->unknown_command
                           : "Unknown command. Type %shelp for help.";
  const char *prefix = session_command_prefix(ctx);
  const char *prefix_args[] = {prefix};
  char message[SSH_CHATTER_MESSAGE_LIMIT];
  session_format_template(format, prefix_args, sizeof(prefix_args) / sizeof(prefix_args[0]), message, sizeof(message));
  session_send_system_line(ctx, message);
}

static void trim_whitespace_inplace(char *text) {
  if (text == NULL) {
    return;
  }

  char *start = text;
  while (*start != '\0' && isspace((unsigned char)*start)) {
    ++start;
  }

  char *end = text + strlen(text);
  while (end > start && isspace((unsigned char)*(end - 1))) {
    --end;
  }

  const size_t length = (size_t)(end - start);
  if (start != text && length > 0U) {
    memmove(text, start, length);
  }
  text[length] = '\0';
}

static const char *session_consume_token(const char *input, char *token, size_t length) {
  if (token == NULL || length == 0U) {
    return input;
  }

  token[0] = '\0';
  if (input == NULL) {
    return NULL;
  }

  while (*input == ' ' || *input == '\t') {
    ++input;
  }

  size_t out_idx = 0U;
  while (*input != '\0' && !isspace((unsigned char)*input)) {
    if (out_idx + 1U < length) {
      token[out_idx++] = *input;
    }
    ++input;
  }
  token[out_idx] = '\0';

  while (*input == ' ' || *input == '\t') {
    ++input;
  }

  return input;
}

static bool session_user_data_available(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return false;
  }

  if (!ctx->owner->user_data_ready) {
    return false;
  }

  if (ctx->user.name[0] == '\0') {
    return false;
  }

  return true;
}

static void session_user_data_touch(session_ctx_t *ctx) {
  if (ctx == NULL || !ctx->user_data_loaded) {
    return;
  }

  time_t now = time(NULL);
  if (now == (time_t)-1) {
    now = 0;
  }
  ctx->user_data.last_updated = (uint64_t)now;
}

static void host_user_data_build_match_key(const char *username, char *key, size_t length) {
  if (key == NULL || length == 0U) {
    return;
  }

  key[0] = '\0';
  if (username == NULL || username[0] == '\0') {
    return;
  }

  char sanitized[SSH_CHATTER_USERNAME_LEN * 2U];
  const bool sanitized_ok = user_data_sanitize_username(username, sanitized, sizeof(sanitized));
  const char *source = sanitized_ok ? sanitized : username;

  size_t out_idx = 0U;
  for (size_t idx = 0U; source[idx] != '\0'; ++idx) {
    unsigned char ch = (unsigned char)source[idx];
    if (isalnum(ch)) {
      if (out_idx + 1U < length) {
        key[out_idx++] = (char)tolower(ch);
      }
    }
  }

  key[out_idx] = '\0';
}

static bool host_user_data_find_profile_picture(host_t *host, const char *alias, user_data_record_t *record) {
  if (host == NULL || alias == NULL || alias[0] == '\0' || record == NULL) {
    return false;
  }

  user_data_record_t direct_record;
  const bool direct_loaded = host_user_data_load_existing(host, alias, NULL, &direct_record, false);
  if (direct_loaded && direct_record.profile_picture[0] != '\0') {
    *record = direct_record;
    return true;
  }

  char alias_key[SSH_CHATTER_USERNAME_LEN * 2U];
  host_user_data_build_match_key(alias, alias_key, sizeof(alias_key));
  if (alias_key[0] == '\0') {
    return false;
  }

  char alias_path_key[SSH_CHATTER_USERNAME_LEN * 2U];
  alias_path_key[0] = '\0';
  if (!user_data_sanitize_username(alias, alias_path_key, sizeof(alias_path_key))) {
    alias_path_key[0] = '\0';
  }

  if (host->user_data_root[0] == '\0') {
    return false;
  }

  DIR *dir = opendir(host->user_data_root);
  if (dir == NULL) {
    return false;
  }

  bool matched = false;
  struct dirent *entry = NULL;
  while (!matched && (entry = readdir(dir)) != NULL) {
    const char *name = entry->d_name;
    if (name == NULL || name[0] == '\0') {
      continue;
    }

    if (name[0] == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0'))) {
      continue;
    }

    size_t name_len = strlen(name);
    if (name_len <= 4U || strcmp(name + name_len - 4U, ".dat") != 0) {
      continue;
    }

    size_t base_len = name_len - 4U;
    char candidate_name[SSH_CHATTER_USERNAME_LEN * 2U];
    if (base_len >= sizeof(candidate_name)) {
      continue;
    }
    memcpy(candidate_name, name, base_len);
    candidate_name[base_len] = '\0';

    if (alias_path_key[0] != '\0' && strcmp(candidate_name, alias_path_key) == 0) {
      continue;
    }

    user_data_record_t candidate_record;
    if (!host_user_data_load_existing(host, candidate_name, NULL, &candidate_record, false)) {
      continue;
    }

    if (candidate_record.profile_picture[0] == '\0') {
      continue;
    }

    char candidate_key[SSH_CHATTER_USERNAME_LEN * 2U];
    host_user_data_build_match_key(candidate_record.username, candidate_key, sizeof(candidate_key));
    if (candidate_key[0] == '\0') {
      continue;
    }

    if (strcmp(candidate_key, alias_key) == 0) {
      *record = candidate_record;
      matched = true;
    }
  }

  closedir(dir);
  return matched;
}

static bool host_user_data_load_existing(host_t *host, const char *username, const char *ip,
                                        user_data_record_t *record, bool create_if_missing) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return false;
  }

  if (!host->user_data_ready) {
    return false;
  }

  bool success = false;
  if (host->user_data_lock_initialized) {
    pthread_mutex_lock(&host->user_data_lock);
  }

  if (create_if_missing) {
    success = user_data_ensure_exists(host->user_data_root, username, ip, record);
  } else {
    success = user_data_load(host->user_data_root, username, ip, record);
  }

  if (host->user_data_lock_initialized) {
    pthread_mutex_unlock(&host->user_data_lock);
  }

  return success;
}

static bool host_lookup_last_ip(host_t *host, const char *username, char *ip, size_t length) {
  if (ip != NULL && length > 0U) {
    ip[0] = '\0';
  }

  if (host == NULL || username == NULL || username[0] == '\0' || ip == NULL || length == 0U) {
    return false;
  }

  if (host_lookup_member_ip(host, username, ip, length)) {
    return true;
  }

  user_data_record_t record;
  if (!host_user_data_load_existing(host, username, NULL, &record, false)) {
    return false;
  }

  if (record.last_ip[0] == '\0') {
    return false;
  }

  snprintf(ip, length, "%s", record.last_ip);
  return true;
}

static bool session_user_data_load(session_ctx_t *ctx) {
  if (!session_user_data_available(ctx)) {
    return false;
  }

  if (ctx->user_data_loaded) {
    return true;
  }

  user_data_record_t record;
  if (!host_user_data_load_existing(ctx->owner, ctx->user.name, ctx->client_ip, &record, true)) {
    return false;
  }

  ctx->user_data = record;
  ctx->user_data_loaded = true;
  return true;
}

static bool session_user_data_commit(session_ctx_t *ctx) {
  if (!session_user_data_available(ctx) || !ctx->user_data_loaded) {
    return false;
  }

  session_user_data_touch(ctx);

  host_t *host = ctx->owner;
  bool success = false;
  if (host->user_data_lock_initialized) {
    pthread_mutex_lock(&host->user_data_lock);
  }
  snprintf(ctx->user_data.last_ip, sizeof(ctx->user_data.last_ip), "%s", ctx->client_ip);
  success = user_data_save(host->user_data_root, &ctx->user_data, ctx->client_ip);
  if (host->user_data_lock_initialized) {
    pthread_mutex_unlock(&host->user_data_lock);
  }

  if (!success) {
    humanized_log_error("mailbox", "failed to persist user data", errno != 0 ? errno : EIO);
  }

  return success;
}

static bool host_user_data_send_mail(host_t *host, const char *recipient, const char *recipient_ip,
                                    const char *sender, const char *message, char *error, size_t error_length) {
  if (error != NULL && error_length > 0U) {
    error[0] = '\0';
  }

  if (host == NULL || recipient == NULL || recipient[0] == '\0' || message == NULL || message[0] == '\0') {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "%s", "Invalid mailbox parameters.");
    }
    return false;
  }

  if (!host->user_data_ready) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "%s", "Mailbox storage unavailable.");
    }
    return false;
  }

  char resolved_ip[SSH_CHATTER_IP_LEN];
  resolved_ip[0] = '\0';
  if (recipient_ip != NULL && recipient_ip[0] != '\0') {
    snprintf(resolved_ip, sizeof(resolved_ip), "%s", recipient_ip);
  }

  const bool target_is_lan_ops = host_is_lan_operator_username(host, recipient);
  if (target_is_lan_ops) {
    session_ctx_t *target_session = chat_room_find_user(&host->room, recipient);
    if (target_session == NULL || !target_session->user.is_lan_operator) {
      if (error != NULL && error_length > 0U) {
        snprintf(error, error_length, "%s", "LAN operator mailbox is unavailable.");
      }
      return false;
    }
    snprintf(resolved_ip, sizeof(resolved_ip), "%s", target_session->client_ip);
  }

  if (resolved_ip[0] == '\0') {
    session_ctx_t *target_session = chat_room_find_user(&host->room, recipient);
    if (target_session != NULL) {
      snprintf(resolved_ip, sizeof(resolved_ip), "%s", target_session->client_ip);
    }
  }

  if (resolved_ip[0] == '\0') {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "%s", "Provide the recipient's IP (name@ip) when they are offline.");
    }
    return false;
  }

  user_data_record_t record;
  if (!host_user_data_load_existing(host, recipient, resolved_ip, &record, true)) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "Unable to open mailbox for %s.", recipient);
    }
    return false;
  }

  if (record.mailbox_count >= USER_DATA_MAILBOX_LIMIT) {
    for (size_t idx = 1U; idx < USER_DATA_MAILBOX_LIMIT; ++idx) {
      record.mailbox[idx - 1U] = record.mailbox[idx];
    }
    record.mailbox_count = USER_DATA_MAILBOX_LIMIT - 1U;
  }

  user_data_mail_entry_t *entry = &record.mailbox[record.mailbox_count++];
  time_t now = time(NULL);
  if (now == (time_t)-1) {
    now = 0;
  }
  entry->timestamp = (uint64_t)now;
  if (sender != NULL && sender[0] != '\0') {
    snprintf(entry->sender, sizeof(entry->sender), "%s", sender);
  } else {
    snprintf(entry->sender, sizeof(entry->sender), "%s", "system");
  }
  snprintf(entry->message, sizeof(entry->message), "%s", message);
  record.last_updated = (uint64_t)now;
  snprintf(record.last_ip, sizeof(record.last_ip), "%s", resolved_ip);

  bool success;
  if (host->user_data_lock_initialized) {
    pthread_mutex_lock(&host->user_data_lock);
  }
  success = user_data_save(host->user_data_root, &record, resolved_ip);
  if (host->user_data_lock_initialized) {
    pthread_mutex_unlock(&host->user_data_lock);
  }

  if (!success) {
    if (error != NULL && error_length > 0U) {
      snprintf(error, error_length, "%s", "Failed to write mailbox file.");
    }
    humanized_log_error("mailbox", "failed to persist mailbox entry", errno != 0 ? errno : EIO);
    return false;
  }

  return true;
}

static void rss_trim_whitespace(char *text) {
  trim_whitespace_inplace(text);
}

static void rss_strip_html(char *text) {
  if (text == NULL) {
    return;
  }

  size_t read = 0U;
  size_t write = 0U;
  bool in_tag = false;
  while (text[read] != '\0') {
    char ch = text[read++];
    if (ch == '<') {
      in_tag = true;
      continue;
    }
    if (in_tag) {
      if (ch == '>') {
        in_tag = false;
      }
      continue;
    }
    text[write++] = ch;
  }
  text[write] = '\0';
}

static void rss_decode_entities(char *text) {
  if (text == NULL) {
    return;
  }

  char *src = text;
  char *dst = text;
  while (*src != '\0') {
    if (*src == '&') {
      if (strncmp(src, "&amp;", 5) == 0) {
        *dst++ = '&';
        src += 5;
        continue;
      }
      if (strncmp(src, "&lt;", 4) == 0) {
        *dst++ = '<';
        src += 4;
        continue;
      }
      if (strncmp(src, "&gt;", 4) == 0) {
        *dst++ = '>';
        src += 4;
        continue;
      }
      if (strncmp(src, "&quot;", 6) == 0) {
        *dst++ = '\"';
        src += 6;
        continue;
      }
      if (strncmp(src, "&#39;", 5) == 0) {
        *dst++ = '\'';
        src += 5;
        continue;
      }
    }
    *dst++ = *src++;
  }
  *dst = '\0';
}

static bool rss_tag_is_valid(const char *tag) {
  if (tag == NULL || tag[0] == '\0') {
    return false;
  }

  for (const char *cursor = tag; *cursor != '\0'; ++cursor) {
    const char ch = *cursor;
    if (!(isalnum((unsigned char)ch) || ch == '-' || ch == '_' || ch == '.')) {
      return false;
    }
  }
  return true;
}

// Reset a poll structure to a neutral inactive state.
static void poll_state_reset(poll_state_t *poll) {
  if (poll == NULL) {
    return;
  }

  poll->active = false;
  poll->option_count = 0U;
  poll->question[0] = '\0';
  poll->allow_multiple = false;
  for (size_t idx = 0U; idx < sizeof(poll->options) / sizeof(poll->options[0]); ++idx) {
    poll->options[idx].text[0] = '\0';
    poll->options[idx].votes = 0U;
  }
}

// Reset a named poll entry including its label and voter tracking list.
static void named_poll_reset(named_poll_state_t *poll) {
  if (poll == NULL) {
    return;
  }

  poll_state_reset(&poll->poll);
  poll->label[0] = '\0';
  poll->owner[0] = '\0';
  poll->voter_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_VOTERS; ++idx) {
    poll->voters[idx].username[0] = '\0';
    poll->voters[idx].choice = -1;
    poll->voters[idx].choices_mask = 0U;
  }
}

// Look up a named poll by its label while the host lock is already held.
static named_poll_state_t *host_find_named_poll_locked(host_t *host, const char *label) {
  if (host == NULL || label == NULL || label[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    named_poll_state_t *entry = &host->named_polls[idx];
    if (entry->label[0] == '\0') {
      continue;
    }
    if (strcasecmp(entry->label, label) == 0) {
      return entry;
    }
  }

  return NULL;
}

// Either fetch an existing named poll or initialise a new slot for the provided label.
static named_poll_state_t *host_ensure_named_poll_locked(host_t *host, const char *label) {
  if (host == NULL || label == NULL || label[0] == '\0') {
    return NULL;
  }

  named_poll_state_t *existing = host_find_named_poll_locked(host, label);
  if (existing != NULL) {
    return existing;
  }

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    named_poll_state_t *entry = &host->named_polls[idx];
    if (entry->label[0] != '\0') {
      continue;
    }
    named_poll_reset(entry);
    snprintf(entry->label, sizeof(entry->label), "%s", label);
    return entry;
  }

  return NULL;
}

// Recompute how many named polls are active so list summaries remain accurate.
static void host_recount_named_polls_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  size_t count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    if (host->named_polls[idx].label[0] != '\0' && host->named_polls[idx].poll.active) {
      ++count;
    }
  }
  host->named_poll_count = count;
}

// Ensure poll labels remain short and shell-friendly.
static bool poll_label_is_valid(const char *label) {
  if (label == NULL || label[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; label[idx] != '\0'; ++idx) {
    char ch = label[idx];
    if (!(isalnum((unsigned char)ch) || ch == '_' || ch == '-')) {
      return false;
    }
  }
  return true;
}

static void session_normalize_newlines(char *text) {
  if (text == NULL) {
    return;
  }

  size_t read_idx = 0U;
  size_t write_idx = 0U;
  while (text[read_idx] != '\0') {
    char ch = text[read_idx++];
    if (ch == '\r') {
      if (text[read_idx] == '\n') {
        ++read_idx;
      }
      text[write_idx++] = '\n';
    } else {
      text[write_idx++] = ch;
    }
  }

  text[write_idx] = '\0';
}

static bool timezone_sanitize_identifier(const char *input, char *output, size_t length) {
  if (input == NULL || output == NULL || length == 0U) {
    return false;
  }

  size_t out_idx = 0U;
  bool last_was_slash = true;

  for (size_t idx = 0U; input[idx] != '\0'; ++idx) {
    unsigned char ch = (unsigned char)input[idx];
    if (isspace(ch)) {
      return false;
    }

    if (ch == '/') {
      if (last_was_slash) {
        return false;
      }
      if (out_idx + 1U >= length) {
        return false;
      }
      output[out_idx++] = '/';
      last_was_slash = true;
      continue;
    }

    if (!(isalnum(ch) || ch == '_' || ch == '-' || ch == '+' || ch == '.')) {
      return false;
    }

    if (out_idx + 1U >= length) {
      return false;
    }
    output[out_idx++] = (char)ch;
    last_was_slash = false;
  }

  if (out_idx == 0U || last_was_slash) {
    return false;
  }

  output[out_idx] = '\0';

  if (output[0] == '/' || strstr(output, "..") != NULL) {
    return false;
  }

  return true;
}

static bool timezone_resolve_identifier(const char *input, char *resolved, size_t length) {
  if (input == NULL || input[0] == '\0' || resolved == NULL || length == 0U) {
    return false;
  }

  static const char kTimezoneDir[] = "/usr/share/zoneinfo";

  char full_path[PATH_MAX];
  int full_written = snprintf(full_path, sizeof(full_path), "%s/%s", kTimezoneDir, input);
  if (full_written >= 0 && (size_t)full_written < sizeof(full_path) && access(full_path, R_OK) == 0) {
    int copy_written = snprintf(resolved, length, "%s", input);
    return copy_written >= 0 && (size_t)copy_written < length;
  }

  char working[PATH_MAX];
  int working_written = snprintf(working, sizeof(working), "%s", input);
  if (working_written < 0 || (size_t)working_written >= sizeof(working)) {
    return false;
  }

  char accumulated[PATH_MAX];
  accumulated[0] = '\0';
  size_t accumulated_len = 0U;
  char current_dir[PATH_MAX];
  int dir_written = snprintf(current_dir, sizeof(current_dir), "%s", kTimezoneDir);
  if (dir_written < 0 || (size_t)dir_written >= sizeof(current_dir)) {
    return false;
  }

  char *saveptr = NULL;
  char *segment = strtok_r(working, "/", &saveptr);
  if (segment == NULL) {
    return false;
  }

  while (segment != NULL) {
    DIR *dir = opendir(current_dir);
    if (dir == NULL) {
      return false;
    }

    bool found = false;
    char matched[NAME_MAX + 1];
    matched[0] = '\0';
    struct dirent *entry = NULL;
    while ((entry = readdir(dir)) != NULL) {
      if (entry->d_name[0] == '.') {
        if (entry->d_name[1] == '\0') {
          continue;
        }
        if (entry->d_name[1] == '.' && entry->d_name[2] == '\0') {
          continue;
        }
      }

      if (strcasecmp(entry->d_name, segment) == 0) {
        found = true;
        snprintf(matched, sizeof(matched), "%s", entry->d_name);
        break;
      }
    }
    closedir(dir);

    if (!found) {
      return false;
    }

    if (accumulated_len > 0U) {
      if (accumulated_len + 1U >= sizeof(accumulated)) {
        return false;
      }
      accumulated[accumulated_len++] = '/';
    }

    size_t match_len = strlen(matched);
    if (accumulated_len + match_len >= sizeof(accumulated)) {
      return false;
    }
    memcpy(accumulated + accumulated_len, matched, match_len);
    accumulated_len += match_len;
    accumulated[accumulated_len] = '\0';

    dir_written = snprintf(current_dir, sizeof(current_dir), "%s/%s", kTimezoneDir, accumulated);
    if (dir_written < 0 || (size_t)dir_written >= sizeof(current_dir)) {
      return false;
    }

    segment = strtok_r(NULL, "/", &saveptr);
  }

  if (accumulated_len == 0U) {
    return false;
  }

  full_written = snprintf(full_path, sizeof(full_path), "%s/%s", kTimezoneDir, accumulated);
  if (full_written < 0 || (size_t)full_written >= sizeof(full_path)) {
    return false;
  }

  if (access(full_path, R_OK) != 0) {
    return false;
  }

  int copy_written = snprintf(resolved, length, "%s", accumulated);
  return copy_written >= 0 && (size_t)copy_written < length;
}

static const os_descriptor_t *session_lookup_os_descriptor(const char *name) {
  if (name == NULL || name[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0U; idx < sizeof(OS_CATALOG) / sizeof(OS_CATALOG[0]); ++idx) {
    if (strcasecmp(OS_CATALOG[idx].name, name) == 0) {
      return &OS_CATALOG[idx];
    }
  }

  return NULL;
}

static const char *lookup_color_code(const color_entry_t *entries, size_t entry_count, const char *name) {
  if (entries == NULL || name == NULL) {
    return NULL;
  }

  for (size_t idx = 0; idx < entry_count; ++idx) {
    if (strcasecmp(entries[idx].name, name) == 0) {
      return entries[idx].code;
    }
  }

  return NULL;
}

static const palette_descriptor_t *palette_find_descriptor(const char *name) {
  if (name == NULL || name[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0U; idx < sizeof(PALETTE_DEFINITIONS) / sizeof(PALETTE_DEFINITIONS[0]); ++idx) {
    if (strcasecmp(PALETTE_DEFINITIONS[idx].name, name) == 0) {
      return &PALETTE_DEFINITIONS[idx];
    }
  }

  return NULL;
}

static bool palette_apply_to_session(session_ctx_t *ctx, const palette_descriptor_t *descriptor) {
  if (ctx == NULL || descriptor == NULL) {
    return false;
  }

  const char *user_color_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), descriptor->user_color_name);
  const char *user_highlight_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->user_highlight_name);
  const char *system_fg_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), descriptor->system_fg_name);
  const char *system_bg_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->system_bg_name);
  const char *system_highlight_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->system_highlight_name);

  if (user_color_code == NULL || user_highlight_code == NULL || system_fg_code == NULL || system_bg_code == NULL ||
      system_highlight_code == NULL) {
    return false;
  }

  ctx->user_color_code = user_color_code;
  ctx->user_highlight_code = user_highlight_code;
  ctx->user_is_bold = descriptor->user_is_bold;
  snprintf(ctx->user_color_name, sizeof(ctx->user_color_name), "%s", descriptor->user_color_name);
  snprintf(ctx->user_highlight_name, sizeof(ctx->user_highlight_name), "%s", descriptor->user_highlight_name);

  ctx->system_fg_code = system_fg_code;
  ctx->system_bg_code = system_bg_code;
  ctx->system_highlight_code = system_highlight_code;
  ctx->system_is_bold = descriptor->system_is_bold;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", descriptor->system_fg_name);
  snprintf(ctx->system_bg_name, sizeof(ctx->system_bg_name), "%s", descriptor->system_bg_name);
  snprintf(ctx->system_highlight_name, sizeof(ctx->system_highlight_name), "%s", descriptor->system_highlight_name);

  session_force_dark_mode_foreground(ctx);

  return true;
}

static void host_apply_palette_descriptor(host_t *host, const palette_descriptor_t *descriptor) {
  if (host == NULL || descriptor == NULL) {
    return;
  }

  const char *user_color_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), descriptor->user_color_name);
  const char *user_highlight_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->user_highlight_name);
  const char *system_fg_code =
      lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), descriptor->system_fg_name);
  const char *system_bg_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->system_bg_name);
  const char *system_highlight_code = lookup_color_code(
      HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), descriptor->system_highlight_name);

  if (user_color_code == NULL) {
    user_color_code = ANSI_GREEN;
  }
  if (user_highlight_code == NULL) {
    user_highlight_code = ANSI_BG_DEFAULT;
  }
  if (system_fg_code == NULL) {
    system_fg_code = ANSI_WHITE;
  }
  if (system_bg_code == NULL) {
    system_bg_code = ANSI_BG_BLUE;
  }
  if (system_highlight_code == NULL) {
    system_highlight_code = ANSI_BG_YELLOW;
  }

  host->user_theme.userColor = user_color_code;
  host->user_theme.highlight = user_highlight_code;
  host->user_theme.isBold = descriptor->user_is_bold;
  host->system_theme.foregroundColor = system_fg_code;
  host->system_theme.backgroundColor = system_bg_code;
  host->system_theme.highlightColor = system_highlight_code;
  host->system_theme.isBold = descriptor->system_is_bold;

  snprintf(host->default_user_color_name, sizeof(host->default_user_color_name), "%s", descriptor->user_color_name);
  snprintf(host->default_user_highlight_name, sizeof(host->default_user_highlight_name), "%s",
           descriptor->user_highlight_name);
  snprintf(host->default_system_fg_name, sizeof(host->default_system_fg_name), "%s", descriptor->system_fg_name);
  snprintf(host->default_system_bg_name, sizeof(host->default_system_bg_name), "%s", descriptor->system_bg_name);
  snprintf(host->default_system_highlight_name, sizeof(host->default_system_highlight_name), "%s",
           descriptor->system_highlight_name);
}

static bool parse_bool_token(const char *token, bool *value) {
  if (token == NULL || value == NULL) {
    return false;
  }

  if (strcasecmp(token, "true") == 0 || strcasecmp(token, "yes") == 0 || strcasecmp(token, "on") == 0 ||
      strcasecmp(token, "bold") == 0 || strcmp(token, "켜기") == 0 || strcmp(token, "オン") == 0 ||
      strcmp(token, "开") == 0 || strcmp(token, "вкл") == 0) {
    *value = true;
    return true;
  }

  if (strcasecmp(token, "false") == 0 || strcasecmp(token, "no") == 0 || strcasecmp(token, "off") == 0 ||
      strcasecmp(token, "normal") == 0 || strcmp(token, "끄기") == 0 || strcmp(token, "オフ") == 0 ||
      strcmp(token, "关") == 0 || strcmp(token, "выкл") == 0) {
    *value = false;
    return true;
  }

  return false;
}

static bool session_transport_active(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    return ctx->telnet_fd >= 0 && !ctx->telnet_eof;
  }

  return ctx->channel != NULL;
}

static bool session_transport_is_open(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return false;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    return ctx->telnet_fd >= 0 && !ctx->telnet_eof;
  }

  return ctx->channel != NULL && ssh_channel_is_open(ctx->channel);
}

static bool session_transport_is_eof(const session_ctx_t *ctx) {
  if (ctx == NULL) {
    return true;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    return ctx->telnet_eof || ctx->telnet_fd < 0;
  }

  return ctx->channel == NULL || ssh_channel_is_eof(ctx->channel);
}

static void session_transport_request_close(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    if (ctx->telnet_fd >= 0) {
      shutdown(ctx->telnet_fd, SHUT_RDWR);
    }
    ctx->telnet_eof = true;
    return;
  }

  if (ctx->channel != NULL) {
    ssh_channel_send_eof(ctx->channel);
    ssh_channel_close(ctx->channel);
  }
}

static void session_close_channel(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    if (ctx->telnet_fd >= 0) {
      shutdown(ctx->telnet_fd, SHUT_RDWR);
      close(ctx->telnet_fd);
      ctx->telnet_fd = -1;
    }
    ctx->telnet_eof = true;
    return;
  }

  if (ctx->channel == NULL) {
    return;
  }

  ssh_channel_send_eof(ctx->channel);
  ssh_channel_close(ctx->channel);
  ssh_channel_free(ctx->channel);
  ctx->channel = NULL;
}

static void session_reset_for_retry(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  session_close_channel(ctx);
  ctx->should_exit = false;
  ctx->username_conflict = false;
  ctx->has_joined_room = false;
  ctx->prelogin_banner_rendered = false;
  ctx->input_length = 0U;
  ctx->input_buffer[0] = '\0';
  ctx->input_escape_active = false;
  ctx->input_escape_length = 0U;
  ctx->input_escape_buffer[0] = '\0';
  ctx->bbs_post_pending = false;
  ctx->pending_bbs_title[0] = '\0';
  ctx->pending_bbs_body[0] = '\0';
  ctx->pending_bbs_body_length = 0U;
  ctx->pending_bbs_tag_count = 0U;
  memset(ctx->pending_bbs_tags, 0, sizeof(ctx->pending_bbs_tags));
  ctx->bbs_view_active = false;
  ctx->bbs_view_post_id = 0U;
  ctx->bbs_view_scroll_offset = 0U;
  ctx->bbs_view_total_lines = 0U;
  ctx->bbs_view_notice_pending = false;
  ctx->bbs_view_notice[0] = '\0';
  ctx->bbs_rendering_editor = false;
  ctx->bbs_breaking_count = 0U;
  memset(ctx->bbs_breaking_messages, 0, sizeof(ctx->bbs_breaking_messages));
  ctx->telnet_terminal_type_requested = false;
  ctx->terminal_type[0] = '\0';
  ctx->prefer_cp437_output = false;
  session_asciiart_reset(ctx);
  ctx->asciiart_has_cooldown = false;
  ctx->last_asciiart_post.tv_sec = 0;
  ctx->last_asciiart_post.tv_nsec = 0;
  session_game_tetris_reset(&ctx->game.tetris);
  ctx->game.liar.awaiting_guess = false;
  ctx->game.liar.round_number = 0U;
  ctx->game.liar.score = 0U;
  ctx->game.active = false;
  ctx->game.type = SESSION_GAME_NONE;
  ctx->game.rng_seeded = false;
  ctx->game.rng_state = 0U;
  ctx->game.alpha = (alpha_centauri_game_state_t){0};
  ctx->input_history_count = 0U;
  memset(ctx->input_history_is_command, 0, sizeof(ctx->input_history_is_command));
  ctx->input_history_position = -1;
  ctx->history_scroll_position = 0U;
  ctx->has_last_message_time = false;
  ctx->last_message_time.tv_sec = 0;
  ctx->last_message_time.tv_nsec = 0;
  ctx->user_data_loaded = false;
  memset(&ctx->user_data, 0, sizeof(ctx->user_data));
  session_refresh_output_encoding(ctx);
}

static int host_telnet_open_socket(host_t *host) {
  if (host == NULL || host->telnet.port[0] == '\0') {
    return -1;
  }

  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  const char *bind_addr = host->telnet.bind_address[0] != '\0' ? host->telnet.bind_address : NULL;
  struct addrinfo *result = NULL;
  int rc = getaddrinfo(bind_addr, host->telnet.port, &hints, &result);
  if (rc != 0) {
    printf("[telnet] failed to resolve %s:%s (%s)\n", bind_addr != NULL ? bind_addr : "*", host->telnet.port,
           gai_strerror(rc));
    return -1;
  }

  int fd = -1;
  for (struct addrinfo *ai = result; ai != NULL; ai = ai->ai_next) {
    int candidate = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (candidate < 0) {
      continue;
    }

    int enable = 1;
    setsockopt(candidate, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));

    if (bind(candidate, ai->ai_addr, ai->ai_addrlen) != 0) {
      close(candidate);
      continue;
    }

    if (listen(candidate, 16) != 0) {
      close(candidate);
      continue;
    }

    fd = candidate;
    break;
  }

  freeaddrinfo(result);
  return fd;
}

static void *host_telnet_thread(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  atomic_store(&host->telnet.running, true);

  while (!atomic_load(&host->telnet.stop)) {
    if (host->telnet.fd < 0) {
      int fd = host_telnet_open_socket(host);
      if (fd < 0) {
        struct timespec backoff = {.tv_sec = 1, .tv_nsec = 0};
        nanosleep(&backoff, NULL);
        continue;
      }

      host->telnet.fd = fd;
      const char *display_addr = host->telnet.bind_address[0] != '\0' ? host->telnet.bind_address : "*";
      printf("[telnet] listening on %s:%s\n", display_addr, host->telnet.port);
    }

    struct sockaddr_storage addr;
    socklen_t addr_len = sizeof(addr);
    int client_fd = accept(host->telnet.fd, (struct sockaddr *)&addr, &addr_len);
    if (client_fd < 0) {
      if (errno == EINTR) {
        continue;
      }
      if (atomic_load(&host->telnet.stop)) {
        break;
      }
      humanized_log_error("telnet", "accept failed", errno);
      struct timespec backoff = {.tv_sec = 1, .tv_nsec = 0};
      nanosleep(&backoff, NULL);
      continue;
    }

    if (atomic_load(&host->telnet.stop)) {
      close(client_fd);
      break;
    }

    int flag = 1;
    setsockopt(client_fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));

    char peer_address[NI_MAXHOST];
    host_format_sockaddr((struct sockaddr *)&addr, addr_len, peer_address, sizeof(peer_address));
    if (peer_address[0] == '\0') {
      snprintf(peer_address, sizeof(peer_address), "%s", "unknown");
    }

    printf("[telnet] accepted client from %s\n", peer_address);

    session_ctx_t *ctx = GC_CALLOC(1U, sizeof(session_ctx_t));
    if (ctx == NULL) {
      humanized_log_error("telnet", "failed to allocate session context", ENOMEM);
      close(client_fd);
      continue;
    }
        ctx->ops = &telnet_session_ops;
        ctx->transport_kind = SESSION_TRANSPORT_TELNET;
    ctx->telnet_fd = client_fd;
    ctx->telnet_negotiated = false;
    ctx->telnet_eof = false;
    ctx->telnet_pending_valid = false;
    ctx->owner = host;
    ctx->auth = (auth_profile_t){0};
    snprintf(ctx->client_ip, sizeof(ctx->client_ip), "%.*s", (int)sizeof(ctx->client_ip) - 1, peer_address);
    ctx->input_mode = SESSION_INPUT_MODE_CHAT;

    session_ui_language_t geo_language = session_client_geo_language(ctx);
    if (geo_language != SESSION_UI_LANGUAGE_COUNT) {
        ctx->ui_language = geo_language;
    } else {
        ctx->ui_language = SESSION_UI_LANGUAGE_KO;
    }

    pthread_mutex_lock(&host->lock);
    ++host->connection_count;
    snprintf(ctx->user.name, sizeof(ctx->user.name), "Guest%zu", host->connection_count);
    ctx->user.is_operator = false;
    ctx->user.is_lan_operator = false;
    pthread_mutex_unlock(&host->lock);

    pthread_t thread_id;
    if (pthread_create(&thread_id, NULL, session_thread, ctx) != 0) {
      humanized_log_error("telnet", "failed to spawn session thread", errno);
      session_cleanup(ctx);
      continue;
    }

    pthread_detach(thread_id);
  }

  int listener_fd = host->telnet.fd;
  host->telnet.fd = -1;
  if (listener_fd >= 0) {
    close(listener_fd);
  }

  atomic_store(&host->telnet.running, false);
  return NULL;
}

static bool host_telnet_listener_start(host_t *host, const char *bind_addr, const char *port) {
  if (host == NULL || port == NULL || port[0] == '\0') {
    return false;
  }

  if (host->telnet.thread_initialized) {
    const bool same_port = strncmp(host->telnet.port, port, sizeof(host->telnet.port)) == 0;
    bool same_bind = false;
    if (bind_addr == NULL || bind_addr[0] == '\0') {
      same_bind = host->telnet.bind_address[0] == '\0';
    } else {
      same_bind = strncmp(host->telnet.bind_address, bind_addr, sizeof(host->telnet.bind_address)) == 0;
    }

    if (same_port && same_bind && atomic_load(&host->telnet.running)) {
      const char *display_addr = host->telnet.bind_address[0] != '\0' ? host->telnet.bind_address : "*";
      printf("[telnet] listener already active on %s:%s\n", display_addr, host->telnet.port);
      return true;
    }

    host_telnet_listener_stop(host);
  }

  if (bind_addr != NULL && bind_addr[0] != '\0') {
    snprintf(host->telnet.bind_address, sizeof(host->telnet.bind_address), "%s", bind_addr);
  } else {
    host->telnet.bind_address[0] = '\0';
  }
  snprintf(host->telnet.port, sizeof(host->telnet.port), "%s", port);
  host->telnet.enabled = true;
  host->telnet.fd = -1;
  host->telnet.restart_attempts = 0U;
  host->telnet.last_error_time.tv_sec = 0;
  host->telnet.last_error_time.tv_nsec = 0L;
  atomic_store(&host->telnet.stop, false);

  if (pthread_create(&host->telnet.thread, NULL, host_telnet_thread, host) != 0) {
    humanized_log_error("telnet", "failed to start telnet listener", errno);
    host->telnet.enabled = false;
    return false;
  }

  host->telnet.thread_initialized = true;
  return true;
}

static void host_telnet_listener_stop(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (!host->telnet.thread_initialized) {
    host->telnet.enabled = false;
    host->telnet.fd = -1;
    host->telnet.bind_address[0] = '\0';
    host->telnet.port[0] = '\0';
    atomic_store(&host->telnet.running, false);
    atomic_store(&host->telnet.stop, false);
    return;
  }

  const char *display_addr = host->telnet.bind_address[0] != '\0' ? host->telnet.bind_address : "*";
  printf("[telnet] stopping listener on %s:%s\n", display_addr, host->telnet.port);

  atomic_store(&host->telnet.stop, true);
  if (host->telnet.fd >= 0) {
    shutdown(host->telnet.fd, SHUT_RDWR);
  }

  int join_result = pthread_join(host->telnet.thread, NULL);
  if (join_result != 0) {
    humanized_log_error("telnet", "failed to join telnet listener", join_result);
  }

  host->telnet.thread_initialized = false;
  host->telnet.enabled = false;
  atomic_store(&host->telnet.running, false);
  atomic_store(&host->telnet.stop, false);

  if (host->telnet.fd >= 0) {
    close(host->telnet.fd);
    host->telnet.fd = -1;
  }

  host->telnet.bind_address[0] = '\0';
  host->telnet.port[0] = '\0';
}

static bool session_attempt_handshake_restart(session_ctx_t *ctx, unsigned int *attempts) {
  if (ctx == NULL || attempts == NULL) {
    return false;
  }

  if (!session_transport_active(ctx)) {
    return false;
  }

  if (*attempts >= SSH_CHATTER_HANDSHAKE_RETRY_LIMIT) {
    return false;
  }

  ++(*attempts);
  printf("[session] retrying handshake (attempt %u/%u)\n", *attempts, SSH_CHATTER_HANDSHAKE_RETRY_LIMIT);
  session_reset_for_retry(ctx);
  session_apply_theme_defaults(ctx);
  struct timespec backoff = {
      .tv_sec = 0,
      .tv_nsec = 200000000L,
  };
  nanosleep(&backoff, NULL);
  return true;
}

static void session_cleanup(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  if (ctx->user_data_loaded) {
    (void)session_user_data_commit(ctx);
  }

  session_translation_worker_shutdown(ctx);
  if (ctx->transport_kind == SESSION_TRANSPORT_SSH && ctx->channel != NULL) {
    ssh_channel_request_send_exit_status(ctx->channel, ctx->exit_status);
  }
  session_close_channel(ctx);

  if (ctx->session != NULL) {
    ssh_disconnect(ctx->session);
    ssh_free(ctx->session);
    ctx->session = NULL;
  }

}

static void *session_thread(void *arg) {
  session_ctx_t *ctx = (session_ctx_t *)arg;
  if (ctx == NULL) {
    return NULL;
  }

  ctx->exit_status = EXIT_FAILURE;
  session_apply_theme_defaults(ctx);

  bool authenticated = false;
  unsigned int handshake_retries = 0U;
  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    session_telnet_initialize(ctx);
    session_telnet_capture_startup_metadata(ctx);
    session_render_prelogin_banner(ctx);
    authenticated = true;
  }

  while (ctx->transport_kind == SESSION_TRANSPORT_SSH) {
    if (!authenticated) {
      if (session_authenticate(ctx) != 0) {
        humanized_log_error("session", "authentication failed", EACCES);
        session_cleanup(ctx);
        return NULL;
      }
      authenticated = true;
    }

    if (session_accept_channel(ctx) != 0) {
      humanized_log_error("session", "failed to open channel", EIO);
      if (session_attempt_handshake_restart(ctx, &handshake_retries)) {
        continue;
      }
      session_cleanup(ctx);
      return NULL;
    }

    if (session_prepare_shell(ctx) != 0) {
      humanized_log_error("session", "shell negotiation failed", EPROTO);
      if (session_attempt_handshake_restart(ctx, &handshake_retries)) {
        continue;
      }
      session_cleanup(ctx);
      return NULL;
    }

    break;
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_SSH) {
    session_render_prelogin_banner(ctx);
  }

  if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
    if (!session_telnet_prompt_initial_nickname(ctx)) {
      session_cleanup(ctx);
      return NULL;
    }
  }

  session_assign_lan_privileges(ctx);
  session_apply_granted_privileges(ctx);
  session_apply_saved_preferences(ctx);

  bool captcha_enabled = false;
  if (ctx->owner != NULL) {
    captcha_enabled = atomic_load(&ctx->owner->captcha_enabled);
  }
  const bool captcha_exempt = session_is_captcha_exempt(ctx);
  if (captcha_enabled && !captcha_exempt && !session_run_captcha(ctx)) {
    session_cleanup(ctx);
    return NULL;
  }

  if (host_is_ip_banned(ctx->owner, ctx->client_ip)) {
    session_send_system_line(ctx, "You are banned from this server.");
    session_cleanup(ctx);
    return NULL;
  }

  const bool banned_username = host_is_username_banned(ctx->owner, ctx->user.name);
  const bool reserved_username =
      host_username_reserved(ctx->owner, ctx->user.name) && !ctx->user.is_lan_operator;
  session_ctx_t *existing = chat_room_find_user(&ctx->owner->room, ctx->user.name);

  if (banned_username || reserved_username || existing != NULL) {
    ctx->username_conflict = true;
    session_render_banner(ctx);

    if (banned_username) {
      printf("[reject] banned nickname attempted: %s\n", ctx->user.name);
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      snprintf(message, sizeof(message), "The nickname '%s' is blocked for bot detection.", ctx->user.name);
      session_send_system_line(ctx, message);
      session_send_system_line(ctx,
                               "Reconnect with a different nickname before logging in again.");
      session_send_system_line(ctx, "Type /exit to quit.");
    } else {
      if (reserved_username) {
        printf("[reject] reserved username requested: %s\n", ctx->user.name);
        char message[SSH_CHATTER_MESSAGE_LIMIT];
        snprintf(message, sizeof(message), "The username '%s' is reserved.", ctx->user.name);
        session_send_system_line(ctx, message);
      } else {
        printf("[reject] username in use: %s\n", ctx->user.name);
        char message[SSH_CHATTER_MESSAGE_LIMIT];
        snprintf(message, sizeof(message), "The username '%s' is already in use.", ctx->user.name);
        session_send_system_line(ctx, message);
      }
      session_send_system_line(ctx,
                               "Reconnect with a different username by running: ssh newname@<server> (or ssh -l newname <server>).");
      session_send_system_line(ctx, "Type /exit to quit.");
    }
  } else {
    host_join_attempt_result_t join_result =
        host_register_join_attempt(ctx->owner, ctx->user.name, ctx->client_ip);
    if (join_result == HOST_JOIN_ATTEMPT_BAN) {
      session_send_system_line(ctx, "Rapid reconnect detected. You have been banned.");
      session_cleanup(ctx);
      return NULL;
    }
    if (join_result == HOST_JOIN_ATTEMPT_KICK) {
      session_send_system_line(ctx, "Rapid reconnect detected. You have been kicked.");
      session_cleanup(ctx);
      return NULL;
    }

    (void)host_try_load_motd_from_path(ctx->owner, "/etc/ssh-chatter/motd");
    session_send_system_line(ctx, "Wait for a moment...");
    struct timespec wait_time = {0, 0};
    size_t progress = host_prepare_join_delay(ctx->owner, &wait_time);
    if (progress == 0U) {
      progress = 1U;
    }
    if (progress > SSH_CHATTER_JOIN_BAR_MAX) {
      progress = SSH_CHATTER_JOIN_BAR_MAX;
    }
    char loading_line[SSH_CHATTER_MESSAGE_LIMIT];
    size_t written = 0U;
    for (size_t idx = 0; idx < progress && written + 1U < sizeof(loading_line); ++idx) {
      loading_line[written++] = '=';
    }
    if (written + 1U < sizeof(loading_line)) {
      loading_line[written++] = '>';
    }
    loading_line[written] = '\0';
    session_send_system_line(ctx, loading_line);
    if (wait_time.tv_sec != 0 || wait_time.tv_nsec != 0) {
      nanosleep(&wait_time, NULL);
    }
    chat_room_add(&ctx->owner->room, ctx);
    ctx->has_joined_room = true;
    printf("[join] %s\n", ctx->user.name);

    session_render_banner(ctx);
    session_send_history(ctx);
    host_refresh_motd(ctx->owner);
    if (ctx->owner->motd[0] != '\0') {
      session_send_system_line(ctx, ctx->owner->motd);
    }
    const session_ui_locale_t *locale = session_ui_get_locale(ctx);
    const char *prefix = session_command_prefix(ctx);

    if (locale->welcome_help_hint != NULL && locale->welcome_help_hint[0] != '\0') {
      const char *args[] = {prefix};
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      session_format_template(locale->welcome_help_hint, args, sizeof(args) / sizeof(args[0]), message,
                              sizeof(message));
      session_send_system_line(ctx, message);
    }

    if (locale->help_hint_extra != NULL && locale->help_hint_extra[0] != '\0') {
      const char *args[] = {prefix};
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      session_format_template(locale->help_hint_extra, args, sizeof(args) / sizeof(args[0]), message,
                              sizeof(message));
      session_send_system_line(ctx, message);
    }

    if (locale->mode_usage != NULL && locale->mode_usage[0] != '\0') {
      const char *args[] = {prefix};
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      session_format_template(locale->mode_usage, args, sizeof(args) / sizeof(args[0]), message, sizeof(message));
      session_send_system_line(ctx, message);
    }

    if (locale->mode_explain_command != NULL && locale->mode_explain_command[0] != '\0') {
      const char *args[] = {prefix};
      char message[SSH_CHATTER_MESSAGE_LIMIT];
      session_format_template(locale->mode_explain_command, args, sizeof(args) / sizeof(args[0]), message,
                              sizeof(message));
      session_send_system_line(ctx, message);
    }

    char join_message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(join_message, sizeof(join_message), "* [%s] has joined the chat", ctx->user.name);
    host_history_record_system(ctx->owner, join_message);
    chat_room_broadcast(&ctx->owner->room, join_message, NULL);
  }

  session_clear_input(ctx);
  session_render_prompt(ctx, true);

  char buffer[SSH_CHATTER_MAX_INPUT_LEN];
  const int poll_timeout_ms = 100;
  while (!ctx->should_exit) {
    session_translation_flush_ready(ctx);

    int read_result = session_transport_read(ctx, buffer, sizeof(buffer) - 1U, 200);
    if (read_result == SSH_AGAIN) {
      if (ctx->game.active && ctx->game.type == SESSION_GAME_TETRIS) {
        session_game_tetris_process_timeout(ctx);
      }
      continue;
    }
    if (read_result == SSH_ERROR) {
      if (ctx->transport_kind == SESSION_TRANSPORT_TELNET) {
        break;
      }
      read_result = session_channel_read_poll(ctx, buffer, sizeof(buffer) - 1U, poll_timeout_ms);
      if (read_result == SESSION_CHANNEL_TIMEOUT) {
        ctx->channel_error_retries = 0U;
        if (ctx->game.active && ctx->game.type == SESSION_GAME_TETRIS) {
          session_game_tetris_process_timeout(ctx);
        }
        continue;
      }

      if (read_result == SSH_ERROR) {
        const char *error_message = ssh_get_error(ctx->session);
        bool unexpected_bytes_error = false;
        if (error_message != NULL && error_message[0] != '\0') {
          unexpected_bytes_error = strstr(error_message, "unexpected bytes remain after decoding") != NULL;
        }

        if (unexpected_bytes_error) {
          const char *username = ctx->user.name[0] != '\0' ? ctx->user.name : "unknown";
          printf("[session] channel decode error for %s: %s\n", username, error_message);
          break;
        }

        bool remote_disconnect = !session_transport_is_open(ctx) || session_transport_is_eof(ctx);
        if (!remote_disconnect && error_message != NULL && error_message[0] != '\0') {
          static const char *const kNetworkDisconnectTokens[] = {
              "ssh_msg_disconnect",
              "disconnected by",
              "connection reset",
              "connection closed",
              "broken pipe",
              "socket error",
          };
          for (size_t token_idx = 0; token_idx < (sizeof(kNetworkDisconnectTokens) / sizeof(kNetworkDisconnectTokens[0]));
               ++token_idx) {
            if (string_contains_case_insensitive(error_message, kNetworkDisconnectTokens[token_idx])) {
              remote_disconnect = true;
              break;
            }
          }
        }

        if (remote_disconnect) {
          const char *username = ctx->user.name[0] != '\0' ? ctx->user.name : "unknown";
          const char *message = (error_message != NULL && error_message[0] != '\0') ? error_message : "connection closed";
          printf("[session] channel closed for %s: %s\n", username, message);
          break;
        }

        if (ctx->has_joined_room && ctx->channel_error_retries < SSH_CHATTER_CHANNEL_RECOVERY_LIMIT) {
          ctx->channel_error_retries += 1U;
          if (error_message == NULL || error_message[0] == '\0') {
            error_message = "unknown channel error";
          }
          printf("[session] channel read error for %s (attempt %u/%u): %s\n", ctx->user.name,
                 ctx->channel_error_retries, SSH_CHATTER_CHANNEL_RECOVERY_LIMIT, error_message);
          struct timespec retry_delay = {
              .tv_sec = 0,
              .tv_nsec = SSH_CHATTER_CHANNEL_RECOVERY_DELAY_NS,
          };
          nanosleep(&retry_delay, NULL);
          continue;
        }

        if (ctx->has_joined_room) {
          if (error_message == NULL || error_message[0] == '\0') {
            error_message = "unknown channel error";
          }
          printf("[session] channel read failure for %s after %u retries: %s\n", ctx->user.name,
                 ctx->channel_error_retries, error_message);
        }
        break;
      }
      continue;
    }

    if (read_result == 0) {
      if (!session_transport_is_open(ctx) || session_transport_is_eof(ctx)) {
        break;
      }
      if (ctx->game.active && ctx->game.type == SESSION_GAME_TETRIS) {
        session_game_tetris_process_timeout(ctx);
      }
      continue;
    }

    ctx->channel_error_retries = 0U;

    if (read_result == 0) {
      break;
    }
    if (read_result < 0) {
      continue;
    }

    for (int idx = 0; idx < read_result; ++idx) {
      const char ch = buffer[idx];

      if (ctx->game.active && ctx->game.type == SESSION_GAME_TETRIS) {
        if (session_game_tetris_process_raw_input(ctx, ch)) {
          continue;
        }
      }

      if (session_consume_escape_sequence(ctx, ch)) {
        continue;
      }

      if (ch == 0x01) {
        if (ctx->bbs_post_pending || ctx->asciiart_pending) {
          ctx->input_buffer[ctx->input_length] = '\0';
          session_apply_background_fill(ctx);
          if (ctx->bbs_post_pending) {
            if (ctx->editor_mode == SESSION_EDITOR_MODE_ASCIIART) {
              const char *cancel_message =
                  (ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE)
                      ? "Profile picture draft canceled."
                      : "ASCII art draft canceled.";
              session_asciiart_cancel(ctx, cancel_message);
            } else {
              const char *cancel_notice =
                  (ctx->editor_mode == SESSION_EDITOR_MODE_BBS_EDIT) ? "BBS edit canceled." : "BBS draft canceled.";
              session_bbs_reset_pending_post(ctx);
              session_send_system_line(ctx, cancel_notice);
            }
          } else {
            const char *cancel_message =
                (ctx->asciiart_target == SESSION_ASCIIART_TARGET_PROFILE_PICTURE)
                    ? "Profile picture draft canceled."
                    : "ASCII art draft canceled.";
            session_asciiart_cancel(ctx, cancel_message);
          }
          session_clear_input(ctx);
          if (ctx->should_exit) {
            break;
          }
          session_render_prompt(ctx, false);
        }
        continue;
      }

      if (ctx->transport_kind == SESSION_TRANSPORT_TELNET && ch == 0x00) {
        ctx->input_buffer[ctx->input_length] = '\0';
        session_apply_background_fill(ctx);
        session_handle_exit(ctx);
        session_clear_input(ctx);
        if (ctx->should_exit) {
          break;
        }
        session_render_prompt(ctx, false);
        continue;
      }

      if (ch == 0x03) {
        ctx->input_buffer[ctx->input_length] = '\0';
        session_apply_background_fill(ctx);
        session_handle_exit(ctx);
        session_clear_input(ctx);
        if (ctx->should_exit) {
          break;
        }
        session_render_prompt(ctx, false);
        continue;
      }

      if (ch == 0x1a) {
        ctx->input_buffer[ctx->input_length] = '\0';
        session_apply_background_fill(ctx);
        if (ctx->in_rss_mode) {
          session_rss_exit(ctx, NULL);
          session_clear_input(ctx);
          if (ctx->should_exit) {
            break;
          }
          session_render_prompt(ctx, false);
        } else if (ctx->game.active) {
          session_game_suspend(ctx, "Game suspended.");
          session_clear_input(ctx);
          if (ctx->should_exit) {
            break;
          }
          session_render_prompt(ctx, false);
        } else {
          session_handle_exit(ctx);
          session_clear_input(ctx);
          if (ctx->should_exit) {
            break;
          }
          session_render_prompt(ctx, false);
        }
        continue;
      }

      if (ch == 0x13) {
        if (ctx->bbs_post_pending || ctx->asciiart_pending) {
          ctx->input_buffer[ctx->input_length] = '\0';
          bool had_body = ctx->input_length > 0U;
          if (had_body) {
            session_local_echo_char(ctx, '\n');
            session_history_record(ctx, ctx->input_buffer);
            if (ctx->bbs_post_pending) {
              session_bbs_capture_body_text(ctx, ctx->input_buffer);
            } else {
              session_asciiart_capture_text(ctx, ctx->input_buffer);
            }
          } else {
            session_local_echo_char(ctx, '\n');
          }

          const char *terminator =
              ctx->bbs_post_pending ? session_editor_terminator(ctx) : session_asciiart_terminator(ctx);
          for (const char *cursor = terminator; *cursor != '\0'; ++cursor) {
            session_local_echo_char(ctx, *cursor);
          }
          session_local_echo_char(ctx, '\n');
          session_history_record(ctx, terminator);
          if (ctx->bbs_post_pending) {
            session_bbs_capture_body_line(ctx, terminator);
          } else {
            session_asciiart_capture_line(ctx, terminator);
          }
          session_clear_input(ctx);
          if (ctx->should_exit) {
            break;
          }
          session_render_prompt(ctx, false);
        } else if (ctx->game.active && ctx->game.type == SESSION_GAME_ALPHA) {
          session_game_alpha_manual_save(ctx);
        }
        continue;
      }

      if (ch == '\r' || ch == '\n') {
        session_apply_background_fill(ctx);
        const bool composing_draft = ctx->bbs_post_pending || ctx->asciiart_pending;
        if (ctx->input_length > 0U) {
          ctx->input_buffer[ctx->input_length] = '\0';
          session_history_record(ctx, ctx->input_buffer);
          session_process_line(ctx, ctx->input_buffer);
        } else if (composing_draft) {
          session_process_line(ctx, "");
        }
        session_clear_input(ctx);
        if (ctx->should_exit) {
          break;
        }
        if (!ctx->bracket_paste_active) {
          session_render_prompt(ctx, false);
        }
        continue;
      }

      if (ch == '\b' || ch == 0x7f) {
        ctx->input_history_position = -1;
        ctx->history_scroll_position = 0U;
        session_local_backspace(ctx);
        continue;
      }

      if (ch == '\t') {
        if (session_try_command_completion(ctx)) {
          continue;
        }
        if (ctx->input_length + 1U < sizeof(ctx->input_buffer)) {
          ctx->input_history_position = -1;
          ctx->history_scroll_position = 0U;
          ctx->input_buffer[ctx->input_length++] = ' ';
          session_local_echo_char(ctx, ' ');
        }
        continue;
      }

      if ((unsigned char)ch < 0x20U) {
        continue;
      }

      if (ctx->input_length + 1U >= sizeof(ctx->input_buffer)) {
        ctx->input_buffer[sizeof(ctx->input_buffer) - 1U] = '\0';
        session_history_record(ctx, ctx->input_buffer);
        session_process_line(ctx, ctx->input_buffer);
        session_clear_input(ctx);
        if (ctx->should_exit) {
          break;
        }
        session_render_prompt(ctx, false);
      }

      if (ctx->input_length + 1U < sizeof(ctx->input_buffer)) {
        ctx->input_history_position = -1;
        ctx->history_scroll_position = 0U;
        ctx->input_buffer[ctx->input_length++] = ch;
        session_local_echo_char(ctx, ch);
      }
    }

    if (ctx->should_exit) {
      break;
    }
  }

  session_translation_flush_ready(ctx);

  if (!ctx->should_exit && ctx->input_length > 0U) {
    ctx->input_buffer[ctx->input_length] = '\0';
    session_history_record(ctx, ctx->input_buffer);
    session_process_line(ctx, ctx->input_buffer);
    session_clear_input(ctx);
  }

  if (ctx->has_joined_room) {
    printf("[part] %s\n", ctx->user.name);
    char part_message[SSH_CHATTER_MESSAGE_LIMIT];
    snprintf(part_message, sizeof(part_message), "* [%s] has left the chat", ctx->user.name);
    host_history_record_system(ctx->owner, part_message);
    chat_room_broadcast(&ctx->owner->room, part_message, NULL);
    chat_room_remove(&ctx->owner->room, ctx);
  }

  session_cleanup(ctx);

  return NULL;
}

void host_init(host_t *host, auth_profile_t *auth) {
  if (host == NULL) {
    return;
  }

  translator_global_init();

  memset(&host->eliza_worker, 0, sizeof(host->eliza_worker));
  if (!host_eliza_worker_init(host)) {
    printf("[eliza] asynchronous intervention worker unavailable; interventions disabled.\n");
  }

  if (!host_moderation_init(host)) {
    printf("[security] moderation worker unavailable; using synchronous checks\n");
  }

  chat_room_init(&host->room);
  host->listener.handle = NULL;
  host->listener.inplace_recoveries = 0U;
  host->listener.restart_attempts = 0U;
  host->listener.last_error_time.tv_sec = 0;
  host->listener.last_error_time.tv_nsec = 0L;
  host->telnet.enabled = false;
  host->telnet.fd = -1;
  host->telnet.thread_initialized = false;
  atomic_store(&host->telnet.running, false);
  atomic_store(&host->telnet.stop, false);
  host->telnet.restart_attempts = 0U;
  host->telnet.last_error_time.tv_sec = 0;
  host->telnet.last_error_time.tv_nsec = 0L;
  host->telnet.bind_address[0] = '\0';
  host->telnet.port[0] = '\0';
  host->auth = auth;
  host->clients = NULL;
  host->web_client = NULL;
  host->matrix_client = NULL;
  host->security_layer_initialized = security_layer_init(&host->security_layer);
  if (!host->security_layer_initialized) {
    humanized_log_error("security", "failed to initialise layered message encryption", errno != 0 ? errno : EIO);
  }
  host_load_lan_operator_credentials(host);
  const palette_descriptor_t *default_palette = palette_find_descriptor("clean");
  if (default_palette != NULL) {
    host_apply_palette_descriptor(host, default_palette);
  } else {
    host->user_theme.userColor = ANSI_GREEN;
    host->user_theme.highlight = ANSI_BG_DEFAULT;
    host->user_theme.isBold = false;
    host->system_theme.backgroundColor = ANSI_BG_BLUE;
    host->system_theme.foregroundColor = ANSI_WHITE;
    host->system_theme.highlightColor = ANSI_BG_YELLOW;
    host->system_theme.isBold = true;
    snprintf(host->default_user_color_name, sizeof(host->default_user_color_name), "%s", "green");
    snprintf(host->default_user_highlight_name, sizeof(host->default_user_highlight_name), "%s", "default");
    snprintf(host->default_system_fg_name, sizeof(host->default_system_fg_name), "%s", "white");
    snprintf(host->default_system_bg_name, sizeof(host->default_system_bg_name), "%s", "blue");
    snprintf(host->default_system_highlight_name, sizeof(host->default_system_highlight_name), "%s", "yellow");
  }
  host->ban_count = 0U;
  memset(host->bans, 0, sizeof(host->bans));
  memset(host->replies, 0, sizeof(host->replies));
  host->reply_count = 0U;
  host->next_reply_id = 1U;
  memset(host->eliza_memory, 0, sizeof(host->eliza_memory));
  host->eliza_memory_count = 0U;
  host->eliza_memory_next_id = 1U;
  snprintf(host->version, sizeof(host->version), "ssh-chatter (C, rolling release)");
  snprintf(host->motd_base, sizeof(host->motd_base),
           "Welcome to ssh-chat!\n"
           "- Be polite to each other\n"
           "- fun fact: this server is written in pure c.\n"
           "============================================\n"
           " _      ____  ____  _____ ____  _        ____  _ \n"
           "/ \\__/|/  _ \\/  _ \\/  __//  __\\/ \\  /|  /   _\\/ \\\n"
           "| |\\/||| / \\|| | \\||  \\  |  \\/|| |\\ ||  |  /  | |\n"
           "| |  ||| \\_/|| |_/||  /_ |    /| | \\||  |  \\__\\_/\n"
           "\\_/  \\|\\____/\\____/\\____\\\\_/\\_\\\\_/  \\|  \\____/(_)\n"
           "                                                 \n"
           "============================================\n");
  snprintf(host->motd, sizeof(host->motd), "%s", host->motd_base);
  host->motd_path[0] = '\0';
  host->motd_has_file = false;
  host->motd_last_modified.tv_sec = 0;
  host->motd_last_modified.tv_nsec = 0L;


  host->translation_quota_exhausted = false;
  host->connection_count = 0U;
  host->history = NULL;
  host->history_count = 0U;
  host->history_capacity = 0U;
  host->next_message_id = 1U;
  memset(host->preferences, 0, sizeof(host->preferences));
  host->preference_count = 0U;
  host->state_file_path[0] = '\0';
  host_state_resolve_path(host);
  host->bbs_state_file_path[0] = '\0';
  host_bbs_resolve_path(host);
  host->vote_state_file_path[0] = '\0';
  host_vote_resolve_path(host);
  host->ban_state_file_path[0] = '\0';
  host_ban_resolve_path(host);
  host->reply_state_file_path[0] = '\0';
  host_reply_state_resolve_path(host);
  host->alpha_landers_file_path[0] = '\0';
  host_alpha_landers_resolve_path(host);
  snprintf(host->user_data_root, sizeof(host->user_data_root), "%s", "/var/lib/mailbox");
  host->user_data_ready = user_data_ensure_root(host->user_data_root);
  if (pthread_mutex_init(&host->user_data_lock, NULL) == 0) {
    host->user_data_lock_initialized = true;
  } else {
    humanized_log_error("mailbox", "failed to initialise mailbox lock", errno != 0 ? errno : ENOMEM);
    host->user_data_lock_initialized = false;
    host->user_data_ready = false;
  }
  if (pthread_mutex_init(&host->alpha_landers_lock, NULL) == 0) {
    host->alpha_landers_lock_initialized = true;
  } else {
    humanized_log_error("alpha", "failed to initialise alpha landers lock", errno != 0 ? errno : ENOMEM);
    host->alpha_landers_lock_initialized = false;
  }
  host->rss_state_file_path[0] = '\0';
  host_rss_resolve_path(host);
  host->eliza_memory_file_path[0] = '\0';
  host_eliza_memory_resolve_path(host);
  host->eliza_state_file_path[0] = '\0';
  host_eliza_state_resolve_path(host);
  host->security_clamav_thread_initialized = false;
  atomic_store(&host->security_clamav_thread_running, false);
  atomic_store(&host->security_clamav_thread_stop, false);
  host->security_clamav_last_run.tv_sec = 0;
  host->security_clamav_last_run.tv_nsec = 0;
  host->bbs_watchdog_thread_initialized = false;
  atomic_store(&host->bbs_watchdog_thread_running, false);
  atomic_store(&host->bbs_watchdog_thread_stop, false);
  host->bbs_watchdog_last_run.tv_sec = 0;
  host->bbs_watchdog_last_run.tv_nsec = 0;
  host->rss_thread_initialized = false;
  atomic_store(&host->rss_thread_running, false);
  atomic_store(&host->rss_thread_stop, false);
  host->rss_last_run.tv_sec = 0;
  host->rss_last_run.tv_nsec = 0L;
  host_security_configure(host);
  host_version_ip_rules_init(host);
  memset(host->protected_ips, 0, sizeof(host->protected_ips));
  host->protected_ip_count = 0U;
  pthread_mutex_init(&host->lock, NULL);
  host_protected_ips_bootstrap(host);
  poll_state_reset(&host->poll);
  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_NAMED_POLLS; ++idx) {
    named_poll_reset(&host->named_polls[idx]);
  }
  host->named_poll_count = 0U;
  for (size_t idx = 0U; idx < SSH_CHATTER_BBS_MAX_POSTS; ++idx) {
    host->bbs_posts[idx].in_use = false;
    host->bbs_posts[idx].id = 0U;
    host->bbs_posts[idx].author[0] = '\0';
    host->bbs_posts[idx].title[0] = '\0';
    host->bbs_posts[idx].body[0] = '\0';
    host->bbs_posts[idx].tag_count = 0U;
    host->bbs_posts[idx].created_at = 0;
    host->bbs_posts[idx].bumped_at = 0;
    host->bbs_posts[idx].comment_count = 0U;
    for (size_t comment = 0U; comment < SSH_CHATTER_BBS_MAX_COMMENTS; ++comment) {
      host->bbs_posts[idx].comments[comment].author[0] = '\0';
      host->bbs_posts[idx].comments[comment].text[0] = '\0';
      host->bbs_posts[idx].comments[comment].created_at = 0;
    }
  }
  host->bbs_post_count = 0U;
  host->next_bbs_id = 1U;
  for (size_t idx = 0U; idx < SSH_CHATTER_RSS_MAX_FEEDS; ++idx) {
    host_clear_rss_feed(&host->rss_feeds[idx]);
  }
  host->rss_feed_count = 0U;
  host->random_seeded = false;
  memset(host->operator_grants, 0, sizeof(host->operator_grants));
  host->operator_grant_count = 0U;
  host->next_join_ready_time = (struct timespec){0, 0};
  host->join_throttle_initialised = false;
  host->join_progress_length = 0U;
  host->join_activity = NULL;
  host->join_activity_count = 0U;
  host->join_activity_capacity = 0U;
  atomic_store(&host->captcha_enabled, false);
  host->captcha_nonce = 0U;
  host->has_last_captcha = false;
  host->last_captcha_question[0] = '\0';
  host->last_captcha_answer[0] = '\0';
  host->last_captcha_generated.tv_sec = 0;
  host->last_captcha_generated.tv_nsec = 0L;
  atomic_store(&host->eliza_enabled, false);
  atomic_store(&host->eliza_announced, false);
  host->eliza_last_action.tv_sec = 0;
  host->eliza_last_action.tv_nsec = 0L;

  (void)host_try_load_motd_from_path(host, "/etc/ssh-chatter/motd");

  host_state_load(host);
  host_vote_state_load(host);
  host_bbs_state_load(host);
  host_ban_state_load(host);
  host_reply_state_load(host);
  host_rss_state_load(host);
  host_eliza_memory_load(host);
  host_eliza_state_load(host);

  host_user_data_bootstrap(host);

  host_refresh_motd(host);

  host->clients = client_manager_create(host);
  if (host->clients == NULL) {
    humanized_log_error("host", "failed to create client manager", ENOMEM);
  } else {
    host->web_client = webssh_client_create(host, host->clients);
    if (host->web_client == NULL) {
      humanized_log_error("host", "failed to initialise webssh client", ENOMEM);
    }

    if (host->security_layer_initialized) {
      host->matrix_client = matrix_client_create(host, host->clients, &host->security_layer);
      if (host->matrix_client == NULL) {
        humanized_log_error("matrix", "matrix backend inactive; check CHATTER_MATRIX_* configuration", EINVAL);
      }
    }

  }
  host_security_start_clamav_backend(host);
  host_bbs_start_watchdog(host);
  host_rss_start_backend(host);
}

static void host_build_birthday_notice_locked(host_t *host, char *line, size_t length) {
  if (line == NULL || length == 0U) {
    return;
  }

  line[0] = '\0';

  if (host == NULL) {
    return;
  }

  time_t now = time(NULL);
  if (now == (time_t)-1) {
    return;
  }

  struct tm local_now;
  if (localtime_r(&now, &local_now) == NULL) {
    return;
  }

  struct tm today_tm = local_now;
  today_tm.tm_hour = 0;
  today_tm.tm_min = 0;
  today_tm.tm_sec = 0;
  today_tm.tm_isdst = -1;
  time_t today = mktime(&today_tm);
  if (today == (time_t)-1) {
    today = now;
  }

  char names[SSH_CHATTER_MESSAGE_LIMIT];
  names[0] = '\0';
  size_t name_count = 0U;

  for (size_t idx = 0U; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    const user_preference_t *pref = &host->preferences[idx];
    if (!pref->in_use || !pref->has_birthday) {
      continue;
    }
    if (pref->username[0] == '\0' || pref->birthday[0] == '\0') {
      continue;
    }

    int month = 0;
    int day = 0;
    if (sscanf(pref->birthday, "%*d-%d-%d", &month, &day) != 2) {
      continue;
    }
    if (month < 1 || month > 12 || day < 1 || day > 31) {
      continue;
    }

    int use_day = day;
    int use_month = month;
    const int current_year = local_now.tm_year + 1900;
    if (use_month == 2 && use_day == 29 && !host_is_leap_year(current_year)) {
      use_day = 28;
    }

    struct tm birthday_tm = today_tm;
    birthday_tm.tm_year = local_now.tm_year;
    birthday_tm.tm_mon = use_month - 1;
    birthday_tm.tm_mday = use_day;
    birthday_tm.tm_hour = 0;
    birthday_tm.tm_min = 0;
    birthday_tm.tm_sec = 0;
    birthday_tm.tm_isdst = -1;
    time_t birthday_time = mktime(&birthday_tm);
    if (birthday_time == (time_t)-1) {
      continue;
    }

    time_t diff = today - birthday_time;
    if (diff < 0) {
      birthday_tm.tm_year -= 1;
      birthday_tm.tm_isdst = -1;
      birthday_time = mktime(&birthday_tm);
      if (birthday_time == (time_t)-1) {
        continue;
      }
      diff = today - birthday_time;
    }

    if (diff < 0 || diff >= (time_t)SSH_CHATTER_BIRTHDAY_WINDOW_SECONDS) {
      continue;
    }

    size_t current_len = strnlen(names, sizeof(names));
    const size_t name_len = strnlen(pref->username, sizeof(pref->username));
    if (name_len == 0U) {
      continue;
    }

    if (current_len > 0U) {
      if (current_len + 2U >= sizeof(names)) {
        continue;
      }
      names[current_len++] = ',';
      names[current_len++] = ' ';
      names[current_len] = '\0';
    }

    if (name_len >= sizeof(names) - current_len) {
      continue;
    }

    memcpy(names + current_len, pref->username, name_len);
    current_len += name_len;
    names[current_len] = '\0';
    ++name_count;
  }

  if (name_count == 0U) {
    return;
  }

  snprintf(line, length, "Happy birthday to %s!\n", names);
}

static void host_refresh_motd_locked(host_t *host) {
  if (host == NULL) {
    return;
  }

  char birthday_line[SSH_CHATTER_MESSAGE_LIMIT];
  host_build_birthday_notice_locked(host, birthday_line, sizeof(birthday_line));

  if (birthday_line[0] != '\0') {
    snprintf(host->motd, sizeof(host->motd), "%s%s", birthday_line, host->motd_base);
  } else {
    snprintf(host->motd, sizeof(host->motd), "%s", host->motd_base);
  }
}

static void host_refresh_motd(host_t *host) {
  if (host == NULL) {
    return;
  }

  host_maybe_reload_motd_from_file(host);

  pthread_mutex_lock(&host->lock);
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static bool host_try_load_motd_from_path(host_t *host, const char *path) {
  if (host == NULL || path == NULL || path[0] == '\0') {
    return false;
  }

  FILE *motd_file = fopen(path, "rb");
  if (motd_file == NULL) {
    return false;
  }

  struct stat file_info;
  bool have_info = false;
  struct timespec modified = {0, 0};
  int descriptor = fileno(motd_file);
  if (descriptor >= 0 && fstat(descriptor, &file_info) == 0) {
    modified = host_stat_mtime(&file_info);
    have_info = true;
  } else {
    time_t now = time(NULL);
    if (now != (time_t)-1) {
      modified.tv_sec = now;
      modified.tv_nsec = 0L;
      have_info = true;
    }
  }

  char motd_buffer[sizeof(host->motd)];
  size_t total_read = 0U;
  // TODO: Extract a shared helper (e.g. host_read_text_file) so these buffered
  // reads share the same error handling path as other file loaders.
  while (total_read < sizeof(motd_buffer) - 1U) {
    const size_t bytes_to_read = sizeof(motd_buffer) - 1U - total_read;
    const size_t chunk = fread(motd_buffer + total_read, 1U, bytes_to_read, motd_file);
    if (chunk == 0U) {
      if (ferror(motd_file)) {
        const int read_error = errno;
        const int close_result = fclose(motd_file);
        if (close_result != 0) {
          const int close_error = errno;
          humanized_log_error("host", "failed to close motd file", close_error);
        }
        humanized_log_error("host", "failed to read motd file", read_error);
        return false;
      }
      break;
    }
    total_read += chunk;
    if (feof(motd_file)) {
      break;
    }
  }

  motd_buffer[total_read] = '\0';

  if (fclose(motd_file) != 0) {
    const int close_error = errno;
    humanized_log_error("host", "failed to close motd file", close_error);
  }

  session_normalize_newlines(motd_buffer);

  pthread_mutex_lock(&host->lock);
  char motd_clean[4096];
  motd_clean[0] = '\0';
  size_t offset = 0U;
  char *next_line;
  char *motd_line = strtok_r(motd_buffer, "\n", &next_line);
  while (motd_line != NULL && offset < sizeof(motd_clean)) {
    const int written =
        snprintf(motd_clean + offset, sizeof(motd_clean) - offset, "%s\n", motd_line);
    if (written < 0 || (size_t)written >= sizeof(motd_clean) - offset) {
      offset = sizeof(motd_clean) - 1U;
      break;
    }
    offset += (size_t)written;
    motd_line = strtok_r(NULL, "\n", &next_line);
  }
  motd_clean[sizeof(motd_clean) - 1U] = '\0';
  snprintf(host->motd_base, sizeof(host->motd_base), "%s", motd_clean);
  snprintf(host->motd_path, sizeof(host->motd_path), "%s", path);
  host->motd_has_file = true;
  if (have_info) {
    host->motd_last_modified = modified;
  } else {
    host->motd_last_modified.tv_sec = 0;
    host->motd_last_modified.tv_nsec = 0L;
  }
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
  return true;
}

void host_set_motd(host_t *host, const char *motd) {
  if (host == NULL || motd == NULL) {
    return;
  }

  char motd_path[PATH_MAX];
  motd_path[0] = '\0';
  snprintf(motd_path, sizeof(motd_path), "%s", motd);
  trim_whitespace_inplace(motd_path);

  const size_t max_paths = 2U;
  const char *paths_to_try[2] = {NULL, NULL};
  size_t path_count = 0U;

  char expanded_path[PATH_MAX];
  expanded_path[0] = '\0';
  if (motd_path[0] == '~') {
    const char *home = getenv("HOME");
    if (home != NULL && home[0] != '\0' &&
        (motd_path[1] == '\0' || motd_path[1] == '/')) {
      const int written = snprintf(expanded_path, sizeof(expanded_path), "%s%s", home, motd_path + 1);
      if (written > 0 && (size_t)written < sizeof(expanded_path) && path_count < max_paths) {
        paths_to_try[path_count++] = expanded_path;
      }
    }
  }

  if (motd_path[0] != '\0') {
    if (path_count < max_paths) {
      paths_to_try[path_count++] = motd_path;
    }
  }

  for (size_t idx = 0U; idx < path_count; ++idx) {
    if (paths_to_try[idx] != NULL && host_try_load_motd_from_path(host, paths_to_try[idx])) {
      return;
    }
  }

  char normalized[sizeof(host->motd)];
  snprintf(normalized, sizeof(normalized), "%s", motd);
  session_normalize_newlines(normalized);

  pthread_mutex_lock(&host->lock);
  if (motd_path[0] != '\0') {
    snprintf(host->motd_path, sizeof(host->motd_path), "%s", motd_path);
  } else {
    host->motd_path[0] = '\0';
  }
  host->motd_has_file = false;
  host->motd_last_modified.tv_sec = 0;
  host->motd_last_modified.tv_nsec = 0L;
  snprintf(host->motd_base, sizeof(host->motd_base), "%s", normalized);
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
}

bool host_post_client_message(host_t *host, const char *username, const char *message, const char *color_name,
                             const char *highlight_name, bool is_bold) {
  if (host == NULL || username == NULL || username[0] == '\0' || message == NULL) {
    return false;
  }

  chat_history_entry_t entry = {0};
  entry.is_user_message = true;
  snprintf(entry.username, sizeof(entry.username), "%s", username);
  snprintf(entry.message, sizeof(entry.message), "%s", message);
  entry.attachment_type = CHAT_ATTACHMENT_NONE;
  entry.user_is_bold = is_bold;

  const char *color_label = (color_name != NULL && color_name[0] != '\0') ? color_name : host->default_user_color_name;
  snprintf(entry.user_color_name, sizeof(entry.user_color_name), "%s", color_label);
  const char *highlight_label =
      (highlight_name != NULL && highlight_name[0] != '\0') ? highlight_name : host->default_user_highlight_name;
  snprintf(entry.user_highlight_name, sizeof(entry.user_highlight_name), "%s", highlight_label);

  const char *color_code = lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]), color_label);
  const char *highlight_code =
      lookup_color_code(HIGHLIGHT_COLOR_MAP, sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]), highlight_label);
  entry.user_color_code = color_code != NULL ? color_code : host->user_theme.userColor;
  entry.user_highlight_code = highlight_code != NULL ? highlight_code : host->user_theme.highlight;

  chat_history_entry_t stored = {0};
  if (!host_history_commit_entry(host, &entry, &stored)) {
    return false;
  }

  chat_room_broadcast_entry(&host->room, &stored, NULL);
  host_notify_external_clients(host, &stored);
  return true;
}

bool host_snapshot_last_captcha(host_t *host, char *question, size_t question_length, char *answer,
                               size_t answer_length, struct timespec *timestamp) {
  if (host == NULL) {
    return false;
  }

  pthread_mutex_lock(&host->lock);
  bool has_captcha = host->has_last_captcha;
  if (has_captcha) {
    if (question != NULL && question_length > 0U) {
      snprintf(question, question_length, "%s", host->last_captcha_question);
    }
    if (answer != NULL && answer_length > 0U) {
      snprintf(answer, answer_length, "%s", host->last_captcha_answer);
    }
    if (timestamp != NULL) {
      *timestamp = host->last_captcha_generated;
    }
  } else {
    if (question != NULL && question_length > 0U) {
      question[0] = '\0';
    }
    if (answer != NULL && answer_length > 0U) {
      answer[0] = '\0';
    }
    if (timestamp != NULL) {
      timestamp->tv_sec = 0;
      timestamp->tv_nsec = 0L;
    }
  }
  pthread_mutex_unlock(&host->lock);
  return has_captcha;
}

static void host_sleep_after_error(void) {
  struct timespec delay = {
      .tv_sec = 1,
      .tv_nsec = 0,
  };
  nanosleep(&delay, NULL);
}

void host_shutdown(host_t *host) {
  if (host == NULL) {
    return;
  }

  host_eliza_worker_shutdown(host);
  host_moderation_shutdown(host);

  host_telnet_listener_stop(host);

  if (host->rss_thread_initialized) {
    atomic_store(&host->rss_thread_stop, true);
    pthread_join(host->rss_thread, NULL);
    host->rss_thread_initialized = false;
    atomic_store(&host->rss_thread_running, false);
  }

  if (host->security_clamav_thread_initialized) {
    atomic_store(&host->security_clamav_thread_stop, true);
    pthread_join(host->security_clamav_thread, NULL);
    host->security_clamav_thread_initialized = false;
    atomic_store(&host->security_clamav_thread_running, false);
  }

  if (host->bbs_watchdog_thread_initialized) {
    atomic_store(&host->bbs_watchdog_thread_stop, true);
    pthread_join(host->bbs_watchdog_thread, NULL);
    host->bbs_watchdog_thread_initialized = false;
    atomic_store(&host->bbs_watchdog_thread_running, false);
  }

  if (host->matrix_client != NULL) {
    matrix_client_destroy(host->matrix_client);
    host->matrix_client = NULL;
  }
  if (host->web_client != NULL) {
    webssh_client_destroy(host->web_client);
    host->web_client = NULL;
  }
  if (host->clients != NULL) {
    client_manager_destroy(host->clients);
    host->clients = NULL;
  }
  pthread_mutex_lock(&host->lock);
  host->history = NULL;
  host->history_capacity = 0U;
  host->history_count = 0U;
  pthread_mutex_unlock(&host->lock);
  host->join_activity = NULL;
  host->join_activity_capacity = 0U;
  host->join_activity_count = 0U;
  pthread_mutex_lock(&host->room.lock);
  host->room.members = NULL;
  host->room.member_capacity = 0U;
  host->room.member_count = 0U;
  pthread_mutex_unlock(&host->room.lock);
  if (host->user_data_lock_initialized) {
    pthread_mutex_destroy(&host->user_data_lock);
    host->user_data_lock_initialized = false;
  }
  if (host->alpha_landers_lock_initialized) {
    pthread_mutex_destroy(&host->alpha_landers_lock);
    host->alpha_landers_lock_initialized = false;
  }
  if (host->security_layer_initialized) {
    security_layer_free(&host->security_layer);
    host->security_layer_initialized = false;
  }
}

int host_serve(host_t *host, const char *bind_addr, const char *port, const char *key_directory,
               const char *telnet_bind_addr, const char *telnet_port) {
  if (host == NULL) {
    return -1;
  }

  const char *address = (bind_addr != NULL && bind_addr[0] != '\0') ? bind_addr : "0.0.0.0";
  const char *bind_port = (port != NULL && port[0] != '\0') ? port : "2222";
  const char *telnet_bind = NULL;
  if (telnet_bind_addr != NULL) {
    telnet_bind = telnet_bind_addr;
  } else if (bind_addr != NULL && bind_addr[0] != '\0') {
    telnet_bind = bind_addr;
  } else {
    telnet_bind = address;
  }
  if (telnet_port != NULL && telnet_port[0] != '\0') {
    if (!host_telnet_listener_start(host, telnet_bind, telnet_port)) {
      const char *display_addr = (telnet_bind != NULL && telnet_bind[0] != '\0') ? telnet_bind : "*";
      printf("[telnet] telnet listener unavailable on %s:%s\n", display_addr, telnet_port);
    }
  } else {
    host_telnet_listener_stop(host);
  }
  host_register_protected_bind_address(host, address);
  host_register_protected_bind_address(host, telnet_bind);
  const bool key_dir_specified = key_directory != NULL && key_directory[0] != '\0';
  const host_key_definition_t host_key_definitions[] = {
      {"ssh-ed25519", "ssh_host_ed25519_key", SSH_BIND_OPTIONS_IMPORT_KEY, true},
      {"ecdsa-sha2-nistp256", "ssh_host_ecdsa_key", SSH_BIND_OPTIONS_ECDSAKEY, false},
      {"ssh-rsa", "ssh_host_rsa_key", SSH_BIND_OPTIONS_RSAKEY, false},
  };
  const size_t host_key_count = sizeof(host_key_definitions) / sizeof(host_key_definitions[0]);

  while (true) {
    ssh_bind bind_handle = ssh_bind_new();
    if (bind_handle == NULL) {
      humanized_log_error("host", "failed to allocate ssh_bind", ENOMEM);
      host_sleep_after_error();
      continue;
    }

    ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDADDR, address);
    ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDPORT_STR, bind_port);

    bool fatal_key_error = false;
    bool key_loaded = false;
    char preferred_algorithm[64];
    preferred_algorithm[0] = '\0';
    char algorithm_buffer[256];
    algorithm_buffer[0] = '\0';
    size_t algorithm_length = 0U;

    for (size_t idx = 0; idx < host_key_count; ++idx) {
      const host_key_definition_t *definition = &host_key_definitions[idx];
      char key_path[PATH_MAX];
      bool path_valid = false;
      char custom_candidate[PATH_MAX];
      bool attempted_custom = false;

      if (key_dir_specified) {
        attempted_custom = true;
        if (!host_join_key_path(key_directory, definition->filename, custom_candidate, sizeof(custom_candidate))) {
          humanized_log_error("host", "host key directory path is too long", ENAMETOOLONG);
          fatal_key_error = true;
          break;
        }
        if (access(custom_candidate, R_OK) == 0) {
          snprintf(key_path, sizeof(key_path), "%s", custom_candidate);
          path_valid = true;
        }
      }

      if (!path_valid) {
        if (access(definition->filename, R_OK) == 0) {
          snprintf(key_path, sizeof(key_path), "%s", definition->filename);
          path_valid = true;
        } else {
          char fallback_path[PATH_MAX];
          const int written = snprintf(fallback_path, sizeof(fallback_path), "/etc/ssh/%s", definition->filename);
          if (written >= 0 && (size_t)written < sizeof(fallback_path) && access(fallback_path, R_OK) == 0) {
            snprintf(key_path, sizeof(key_path), "%s", fallback_path);
            path_valid = true;
          }
        }
      }

      if (!path_valid) {
        if (attempted_custom) {
          printf("[listener] %s host key not found at %s (skipping)\n", definition->algorithm, custom_candidate);
        }
        continue;
      }

      if (attempted_custom && strcmp(key_path, custom_candidate) != 0) {
        printf("[listener] using fallback %s host key from %s\n", definition->algorithm, key_path);
      }

      if (!host_bind_load_key(bind_handle, definition, key_path)) {
        continue;
      }

      if (!key_loaded) {
        snprintf(preferred_algorithm, sizeof(preferred_algorithm), "%s", definition->algorithm);
      }
      host_bind_append_algorithm(algorithm_buffer, sizeof(algorithm_buffer), &algorithm_length, definition->algorithm);
      key_loaded = true;
      printf("[listener] loaded %s host key from %s\n", definition->algorithm, key_path);
    }

    if (fatal_key_error) {
      ssh_bind_free(bind_handle);
      host_sleep_after_error();
      continue;
    }

    if (!key_loaded) {
      humanized_log_error("host", "no usable host keys found", ENOENT);
      ssh_bind_free(bind_handle);
      host_sleep_after_error();
      continue;
    }

    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_HOSTKEY_ALGORITHMS, algorithm_buffer,
                                  "failed to configure host key algorithms");
    if (preferred_algorithm[0] != '\0') {
      host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_HOSTKEY, preferred_algorithm,
                                    "failed to configure preferred host key");
    }
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_KEY_EXCHANGE, SSH_CHATTER_SUPPORTED_KEX_ALGORITHMS,
                                  "failed to configure key exchange algorithms");
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_CIPHERS_C_S, SSH_CHATTER_STRONG_CIPHERS,
                                  "failed to configure forward cipher suite");
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_CIPHERS_S_C, SSH_CHATTER_STRONG_CIPHERS,
                                  "failed to configure reverse cipher suite");
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_HMAC_C_S, SSH_CHATTER_STRONG_MACS,
                                  "failed to configure forward MAC list");
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_HMAC_S_C, SSH_CHATTER_STRONG_MACS,
                                  "failed to configure reverse MAC list");
#ifdef SSH_BIND_OPTIONS_COMPRESSION_C_S
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_COMPRESSION_C_S, SSH_CHATTER_SECURE_COMPRESSION,
                                  "failed to restrict forward compression mode");
#endif
#ifdef SSH_BIND_OPTIONS_COMPRESSION_S_C
    host_bind_set_optional_string(bind_handle, SSH_BIND_OPTIONS_COMPRESSION_S_C, SSH_CHATTER_SECURE_COMPRESSION,
                                  "failed to restrict reverse compression mode");
#endif

    if (ssh_bind_listen(bind_handle) < 0) {
      humanized_log_error("host", ssh_get_error(bind_handle), EIO);
      ssh_bind_free(bind_handle);
      host_sleep_after_error();
      continue;
    }

    host->listener.handle = bind_handle;
    host->listener.last_error_time.tv_sec = 0;
    host->listener.last_error_time.tv_nsec = 0L;
    printf("[listener] listening on %s:%s\n", address, bind_port);

    bool restart_listener = false;
    while (!restart_listener) {
      ssh_session session = ssh_new();
      if (session == NULL) {
        humanized_log_error("host", "failed to allocate session", ENOMEM);
        continue;
      }

      if (ssh_bind_accept(bind_handle, session) == SSH_ERROR) {
        const int accept_error = errno;
        const char *bind_error = ssh_get_error(bind_handle);

        if (accept_error != 0) {
          char log_message[512];
          const char *system_message = strerror(accept_error);

          if (system_message != NULL && system_message[0] != '\0') {
            if (bind_error != NULL && bind_error[0] != '\0' &&
                !string_contains_case_insensitive(bind_error, system_message)) {
              snprintf(log_message, sizeof(log_message), "Socket error: %s (%s)", system_message,
                       bind_error);
            } else {
              snprintf(log_message, sizeof(log_message), "Socket error: %s", system_message);
            }
          } else if (bind_error != NULL && bind_error[0] != '\0') {
            snprintf(log_message, sizeof(log_message), "Socket error (code %d): %s", accept_error,
                     bind_error);
          } else {
            snprintf(log_message, sizeof(log_message), "Socket error (code %d)", accept_error);
          }

          humanized_log_error("host", log_message, accept_error);
        } else if (bind_error != NULL && bind_error[0] != '\0') {
          humanized_log_error("host", bind_error, EIO);
        } else {
          humanized_log_error("host", "Socket accept failed", EIO);
        }

        bool fatal_socket_error = false;
        bool should_backoff_after_socket_error = false;

        if (accept_error != 0) {
          should_backoff_after_socket_error = true;
          switch (accept_error) {
            case EAGAIN:
#ifdef EWOULDBLOCK
#if EWOULDBLOCK != EAGAIN
            case EWOULDBLOCK:
#endif
#endif
            case EINTR:
            case ECONNRESET:
            case ECONNABORTED:
            case ETIMEDOUT:
            case ENOTCONN:
            case EPIPE:
#ifdef EPROTO
            case EPROTO:
#endif
              should_backoff_after_socket_error = false;
              break;
            case EBADF:
            case ENOTSOCK:
            case EINVAL:
              fatal_socket_error = true;
              break;
            case EMFILE:
            case ENFILE:
            case ENOBUFS:
#ifdef ENOMEM
            case ENOMEM:
#endif
#ifdef ENOSR
            case ENOSR:
#endif
              break;
            default:
              break;
          }
        }

        if ((fatal_socket_error && bind_error != NULL)
           || string_contains_case_insensitive(bind_error, "kex")) {
            fatal_socket_error = false;
        }

        ssh_free(session);
        if (fatal_socket_error) {
          clock_gettime(CLOCK_MONOTONIC, &host->listener.last_error_time);
          if (host_listener_attempt_recover(host, bind_handle, address, bind_port)) {
            continue;
          }
          host->listener.restart_attempts += 1U;
          printf("[listener] scheduling full listener restart after socket error (attempt %u)\n",
                 host->listener.restart_attempts);
          restart_listener = true;
          break;
        }

        if (should_backoff_after_socket_error) {
          struct timespec retry_delay = {
              .tv_sec = 0,
              .tv_nsec = 200000000L,
          };
          nanosleep(&retry_delay, NULL);
        }
        continue;
      }

      hostkey_probe_result_t hostkey_probe = session_probe_client_hostkey_algorithms(
          session, SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS, SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS_COUNT);
      if (hostkey_probe.status == HOSTKEY_SUPPORT_REJECTED) {
        char peer_address[NI_MAXHOST];
        session_describe_peer(session, peer_address, sizeof(peer_address));
        if (peer_address[0] == '\0') {
          strncpy(peer_address, "unknown", sizeof(peer_address) - 1U);
          peer_address[sizeof(peer_address) - 1U] = '\0';
        }

        if (hostkey_probe.offered_algorithms[0] != '\0') {
          printf("[reject] client %s does not accept one of [%s] host keys (client offered: %s)\n",
                 peer_address, SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS_DISPLAY, hostkey_probe.offered_algorithms);
        } else {
          printf("[reject] client %s does not accept one of [%s] host keys\n", peer_address,
                 SSH_CHATTER_REQUIRED_HOSTKEY_ALGORITHMS_DISPLAY);
        }

        ssh_disconnect(session);
        ssh_free(session);
        continue;
      }

      if (ssh_handle_key_exchange(session) != SSH_OK) {
        humanized_log_error("host", ssh_get_error(session), EPROTO);
        ssh_disconnect(session);
        ssh_free(session);
        continue;
      }

      char peer_address[NI_MAXHOST];
      session_describe_peer(session, peer_address, sizeof(peer_address));
      if (peer_address[0] == '\0') {
        strncpy(peer_address, "unknown", sizeof(peer_address) - 1U);
        peer_address[sizeof(peer_address) - 1U] = '\0';
      }

      printf("[connect] accepted client from %s\n", peer_address);

      const char *client_banner = ssh_get_clientbanner(session);
      const version_ip_ban_rule_t *matched_rule = NULL;
      if (host_version_ip_should_ban(host, client_banner, peer_address, &matched_rule)) {
        const char *version_display = (client_banner != NULL && client_banner[0] != '\0') ? client_banner : "unknown";
        const char *pattern_display = (matched_rule != NULL && matched_rule->original_pattern[0] != '\0')
                                          ? matched_rule->original_pattern
                                          : "policy";
        const char *cidr_display = (matched_rule != NULL && matched_rule->cidr_text[0] != '\0')
                                       ? matched_rule->cidr_text
                                       : "unknown range";
        const char *note_display = (matched_rule != NULL && matched_rule->note[0] != '\0')
                                       ? matched_rule->note
                                       : "version/IP policy";
        printf("[auto-ban] %s banned for client version '%s' (%s in %s; %s)\n", peer_address, version_display,
               pattern_display, cidr_display, note_display);
        (void)host_add_ban_entry(host, "", peer_address);
        ssh_disconnect(session);
        ssh_free(session);
        continue;
      }

      session_ctx_t *ctx = GC_CALLOC(1U, sizeof(session_ctx_t));
      if (ctx == NULL) {
        humanized_log_error("host", "failed to allocate session context", ENOMEM);
        ssh_disconnect(session);
        ssh_free(session);
        continue;
      }
      ctx->ops = &ssh_session_ops;

      ctx->session = session;
      ctx->channel = NULL;
      ctx->transport_kind = SESSION_TRANSPORT_SSH;
      ctx->telnet_fd = -1;
      ctx->telnet_eof = false;
      ctx->telnet_pending_valid = false;
      ctx->owner = host;
      ctx->auth = (auth_profile_t){0};
      snprintf(ctx->client_ip, sizeof(ctx->client_ip), "%.*s", (int)sizeof(ctx->client_ip) - 1, peer_address);
      ctx->input_mode = SESSION_INPUT_MODE_CHAT;

      session_ui_language_t geo_language = session_client_geo_language(ctx);
      if (geo_language != SESSION_UI_LANGUAGE_COUNT) {
          ctx->ui_language = geo_language;
      } else {
          ctx->ui_language = SESSION_UI_LANGUAGE_KO;
      }
      if (client_banner != NULL && client_banner[0] != '\0') {
        snprintf(ctx->client_banner, sizeof(ctx->client_banner), "%s", client_banner);
      }
      session_refresh_output_encoding(ctx);

      pthread_mutex_lock(&host->lock);
      ++host->connection_count;
      snprintf(ctx->user.name, sizeof(ctx->user.name), "Guest%zu", host->connection_count);
      ctx->user.is_operator = false;
      ctx->user.is_lan_operator = false;
      pthread_mutex_unlock(&host->lock);

      pthread_t thread_id;
      if (pthread_create(&thread_id, NULL, session_thread, ctx) != 0) {
        humanized_log_error("host", "failed to spawn session thread", errno);
        session_cleanup(ctx);
        continue;
      }

      pthread_detach(thread_id);
    }

    ssh_bind_free(bind_handle);
    host->listener.handle = NULL;

    if (!restart_listener) {
      host_sleep_after_error();
      continue;
    }

    struct timespec backoff = {
        .tv_sec = 1,
        .tv_nsec = 0,
    };
    nanosleep(&backoff, NULL);

    if (host->listener.restart_attempts > 0U) {
      printf("[listener] attempting full listener restart after socket error (attempt %u)\n",
             host->listener.restart_attempts);
    } else {
      printf("[listener] attempting full listener restart after socket error\n");
    }

    if (host->listener.last_error_time.tv_sec != 0 || host->listener.last_error_time.tv_nsec != 0L) {
      struct timespec now;
      clock_gettime(CLOCK_MONOTONIC, &now);
      struct timespec elapsed = timespec_diff(&now, &host->listener.last_error_time);
      double elapsed_seconds = (double)elapsed.tv_sec + (double)elapsed.tv_nsec / 1000000000.0;
      printf("[listener] last fatal error occurred %.3f seconds ago\n", elapsed_seconds);
    }
  }

  return 0;
}
