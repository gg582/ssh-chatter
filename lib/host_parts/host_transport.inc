// Connection setup, listener management, and transport helpers.

static void session_format_telnet_identity(session_ctx_t *ctx, const char *primary_label) {
  if (ctx == NULL) {
    return;
  }

  ctx->telnet_identity[0] = '\0';
  if (ctx->transport_kind != SESSION_TRANSPORT_TELNET) {
    return;
  }

  const char *label = primary_label;
  char snippet[SSH_CHATTER_TERMINAL_TYPE_LEN];
  snippet[0] = '\0';

  if (label == NULL || label[0] == '\0') {
    if (ctx->terminal_type[0] != '\0') {
      label = ctx->terminal_type;
    } else if (ctx->client_banner[0] != '\0') {
      session_extract_banner_token(ctx->client_banner, snippet, sizeof(snippet));
      if (snippet[0] != '\0') {
        label = snippet;
      }
    }
  }

  if (label == NULL || label[0] == '\0') {
    label = "unknown";
  }

  snprintf(ctx->telnet_identity, sizeof(ctx->telnet_identity), "telnet/%s", label);
}

static bool host_is_leap_year(int year) {
  if (year <= 0) {
    return false;
  }

  if ((year % 4) != 0) {
    return false;
  }
  if ((year % 100) != 0) {
    return true;
  }
  return (year % 400) == 0;
}

static struct timespec timespec_diff(const struct timespec *end, const struct timespec *start) {
  struct timespec result = {0, 0};
  if (end == NULL || start == NULL) {
    return result;
  }

  time_t sec = end->tv_sec - start->tv_sec;
  long nsec = end->tv_nsec - start->tv_nsec;
  if (nsec < 0) {
    --sec;
    nsec += 1000000000L;
  }
  if (sec < 0) {
    sec = 0;
    nsec = 0;
  }
  result.tv_sec = sec;
  result.tv_nsec = nsec;
  return result;
}

static long long timespec_to_ns(const struct timespec *value) {
  if (value == NULL) {
    return 0LL;
  }

  return (long long)value->tv_sec * 1000000000LL + (long long)value->tv_nsec;
}

static bool host_listener_attempt_recover(host_t *host, ssh_bind bind_handle, const char *address,
                                          const char *bind_port) {
  if (host == NULL || bind_handle == NULL) {
    return false;
  }

  printf("[listener] attempting in-place recovery on %s:%s after socket error\n", address, bind_port);
  ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDADDR, address);
  ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_BINDPORT_STR, bind_port);
  if (ssh_bind_listen(bind_handle) == SSH_OK) {
    host->listener.inplace_recoveries += 1U;
    printf("[listener] listener recovered without restart (total in-place recoveries: %u)\n",
           host->listener.inplace_recoveries);
    return true;
  }

  const char *error_message = ssh_get_error(bind_handle);
  if (error_message == NULL || error_message[0] == '\0') {
    error_message = "unknown error";
  }
  printf("[listener] in-place recovery failed: %s\n", error_message);
  return false;
}

static bool host_join_key_path(const char *directory, const char *filename, char *buffer, size_t buffer_len) {
  if (directory == NULL || filename == NULL || buffer == NULL || buffer_len == 0U) {
    return false;
  }

  const size_t dir_len = strlen(directory);
  const bool needs_separator = dir_len > 0U && directory[dir_len - 1U] != '/';
  const int written = snprintf(buffer, buffer_len, "%s%s%s", directory, needs_separator ? "/" : "",
                               filename);
  if (written < 0 || (size_t)written >= buffer_len) {
    return false;
  }

  return true;
}

static bool host_bind_algorithm_is_rsa(const char *algorithm) {
  return algorithm != NULL && strcmp(algorithm, "ssh-rsa") == 0;
}

static void host_bind_append_single_algorithm(char *buffer, size_t buffer_len, size_t *current_len,
                                              const char *algorithm) {
  if (buffer == NULL || current_len == NULL || algorithm == NULL || algorithm[0] == '\0' || buffer_len == 0U) {
    return;
  }

  const size_t usable_length = buffer_len - 1U;
  if (*current_len > usable_length) {
    *current_len = usable_length;
    buffer[usable_length] = '\0';
    return;
  }

  if (*current_len > 0U) {
    if (*current_len >= usable_length) {
      buffer[usable_length] = '\0';
      return;
    }
    buffer[*current_len] = ',';
    ++(*current_len);
  }

  size_t remaining = usable_length - *current_len;
  if (remaining == 0U) {
    buffer[*current_len] = '\0';
    return;
  }

  size_t algorithm_length = strlen(algorithm);
  if (algorithm_length > remaining) {
    algorithm_length = remaining;
  }

  memcpy(buffer + *current_len, algorithm, algorithm_length);
  *current_len += algorithm_length;
  buffer[*current_len] = '\0';
}

static void host_bind_append_algorithm(char *buffer, size_t buffer_len, size_t *current_len,
                                       const char *algorithm) {
  if (buffer == NULL || current_len == NULL || algorithm == NULL || algorithm[0] == '\0' || buffer_len == 0U) {
    return;
  }

  if (host_bind_algorithm_is_rsa(algorithm)) {
    host_bind_append_single_algorithm(buffer, buffer_len, current_len, "rsa-sha2-512");
    host_bind_append_single_algorithm(buffer, buffer_len, current_len, "rsa-sha2-256");
  }

  host_bind_append_single_algorithm(buffer, buffer_len, current_len, algorithm);
}

static bool host_bind_import_key(ssh_bind bind_handle, const char *algorithm, const char *key_path) {
  if (bind_handle == NULL || algorithm == NULL || key_path == NULL) {
    return false;
  }

  ssh_key imported_key = NULL;
  if (ssh_pki_import_privkey_file(key_path, NULL, NULL, NULL, &imported_key) != SSH_OK || imported_key == NULL) {
    char message[256];
    snprintf(message, sizeof(message), "failed to import %s host key", algorithm);
    humanized_log_error("host", message, errno != 0 ? errno : EIO);
    if (imported_key != NULL) {
      ssh_key_free(imported_key);
    }
    return false;
  }

  errno = 0;
  const int import_result = ssh_bind_options_set(bind_handle, SSH_BIND_OPTIONS_IMPORT_KEY, imported_key);
  ssh_key_free(imported_key);
  if (import_result != SSH_OK) {
    const char *error_message = ssh_get_error(bind_handle);
    char message[256];
    snprintf(message, sizeof(message), "failed to register %s host key", algorithm);
    humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
    return false;
  }

  return true;
}

static bool host_bind_load_key(ssh_bind bind_handle, const host_key_definition_t *definition,
                               const char *key_path) {
  if (bind_handle == NULL || definition == NULL || key_path == NULL) {
    return false;
  }

  bool require_import = definition->requires_import;
  if (!require_import) {
    errno = 0;
    const int set_result = ssh_bind_options_set(bind_handle, definition->option, key_path);
    if (set_result == SSH_OK) {
      return true;
    }

    const char *error_message = ssh_get_error(bind_handle);
    const bool unsupported_option =
        (error_message != NULL && strstr(error_message, "Unknown ssh option") != NULL) || errno == ENOTSUP;
    if (!unsupported_option) {
      char message[256];
      snprintf(message, sizeof(message), "failed to load %s host key", definition->algorithm);
      humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
      return false;
    }
    require_import = true;
  }

  if (require_import && !definition->requires_import) {
    printf("[listener] importing %s host key due to limited libssh support\n", definition->algorithm);
  }

  return host_bind_import_key(bind_handle, definition->algorithm, key_path);
}

static void host_bind_set_optional_string(ssh_bind bind_handle, ssh_bind_options_e option, const char *value,
                                          const char *label) {
  if (bind_handle == NULL || value == NULL || value[0] == '\0') {
    return;
  }

  errno = 0;
  if (ssh_bind_options_set(bind_handle, option, value) == SSH_OK) {
    return;
  }

  const char *error_message = ssh_get_error(bind_handle);
  const bool unsupported_option =
      (error_message != NULL && strstr(error_message, "Unknown ssh option") != NULL) || errno == ENOTSUP;
  if (unsupported_option) {
    return;
  }

  char message[256];
  snprintf(message, sizeof(message), "%s", label != NULL ? label : "failed to configure listener option");
  humanized_log_error("host", error_message != NULL ? error_message : message, errno != 0 ? errno : EIO);
}

static struct timespec timespec_add_ns(const struct timespec *start, long long nanoseconds) {
  struct timespec result = {0, 0};
  if (start != NULL) {
    result = *start;
  }

  if (nanoseconds < 0) {
    return result;
  }

  result.tv_sec += (time_t)(nanoseconds / 1000000000LL);
  result.tv_nsec += (long)(nanoseconds % 1000000000LL);
  if (result.tv_nsec >= 1000000000L) {
    result.tv_sec += result.tv_nsec / 1000000000L;
    result.tv_nsec %= 1000000000L;
  }
  return result;
}

static struct timespec timespec_add_ms(const struct timespec *start, long milliseconds) {
  struct timespec result = {0, 0};
  if (start != NULL) {
    result = *start;
  }

  long seconds = milliseconds / 1000L;
  long remaining_ms = milliseconds % 1000L;
  result.tv_sec += seconds;
  result.tv_nsec += remaining_ms * 1000000L;
  if (result.tv_nsec >= 1000000000L) {
    result.tv_sec += result.tv_nsec / 1000000000L;
    result.tv_nsec %= 1000000000L;
  }
  return result;
}

static int timespec_compare(const struct timespec *lhs, const struct timespec *rhs) {
  if (lhs == NULL || rhs == NULL) {
    return 0;
  }
  if (lhs->tv_sec < rhs->tv_sec) {
    return -1;
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return 1;
  }
  if (lhs->tv_nsec < rhs->tv_nsec) {
    return -1;
  }
  if (lhs->tv_nsec > rhs->tv_nsec) {
    return 1;
  }
  return 0;
}

typedef struct connection_guard_result {
  bool blocked;
  bool escalate_ban;
  struct timespec blocked_until;
  size_t attempt_count;
  unsigned int block_count;
} connection_guard_result_t;

static void host_connection_guard_prune_locked(host_t *host, const struct timespec *now) {
  if (host == NULL || now == NULL || host->connection_guard_count == 0U) {
    return;
  }

  size_t write_idx = 0U;
  const size_t original_count = host->connection_guard_count;
  for (size_t idx = 0U; idx < original_count; ++idx) {
    connection_guard_entry_t *entry = &host->connection_guard[idx];
    if (entry->ip[0] == '\0') {
      continue;
    }

    if (entry->last_seen.tv_sec != 0 || entry->last_seen.tv_nsec != 0) {
      struct timespec age = timespec_diff(now, &entry->last_seen);
      long long age_ns = timespec_to_ns(&age);
      if (age_ns > SSH_CHATTER_CONNECTION_GUARD_RETENTION_NS) {
        continue;
      }
    }

    if (write_idx != idx) {
      host->connection_guard[write_idx] = *entry;
    }
    ++write_idx;
  }

  if (write_idx < original_count) {
    size_t cleared = original_count - write_idx;
    memset(&host->connection_guard[write_idx], 0, cleared * sizeof(host->connection_guard[write_idx]));
  }
  host->connection_guard_count = write_idx;
}

static connection_guard_entry_t *host_find_connection_guard_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL) {
    return NULL;
  }

  for (size_t idx = 0U; idx < host->connection_guard_count; ++idx) {
    connection_guard_entry_t *entry = &host->connection_guard[idx];
    if (strncmp(entry->ip, ip, SSH_CHATTER_IP_LEN) == 0) {
      return entry;
    }
  }

  return NULL;
}

static connection_guard_entry_t *host_ensure_connection_guard_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return NULL;
  }

  connection_guard_entry_t *entry = host_find_connection_guard_locked(host, ip);
  if (entry != NULL) {
    return entry;
  }

  if (host->connection_guard_count >= host->connection_guard_capacity) {
    size_t new_capacity = host->connection_guard_capacity > 0U ? host->connection_guard_capacity * 2U : 16U;
    connection_guard_entry_t *resized =
        realloc(host->connection_guard, new_capacity * sizeof(connection_guard_entry_t));
    if (resized == NULL) {
      return NULL;
    }
    host->connection_guard = resized;
    memset(&host->connection_guard[host->connection_guard_capacity], 0,
           (new_capacity - host->connection_guard_capacity) * sizeof(connection_guard_entry_t));
    host->connection_guard_capacity = new_capacity;
  }

  entry = &host->connection_guard[host->connection_guard_count++];
  memset(entry, 0, sizeof(*entry));
  snprintf(entry->ip, sizeof(entry->ip), "%s", ip);
  return entry;
}

static connection_guard_result_t host_connection_guard_register(host_t *host, const char *ip) {
  connection_guard_result_t result = {0};
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return result;
  }

  struct timespec now = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &now);

  pthread_mutex_lock(&host->lock);
  host_connection_guard_prune_locked(host, &now);
  connection_guard_entry_t *entry = host_ensure_connection_guard_locked(host, ip);
  if (entry == NULL) {
    pthread_mutex_unlock(&host->lock);
    return result;
  }

  entry->last_seen = now;

  if (entry->blocked_until.tv_sec != 0 || entry->blocked_until.tv_nsec != 0) {
    if (timespec_compare(&entry->blocked_until, &now) > 0) {
      result.blocked = true;
      result.blocked_until = entry->blocked_until;
      result.block_count = entry->block_count;
      result.attempt_count = entry->attempts;
      pthread_mutex_unlock(&host->lock);
      return result;
    }
    entry->blocked_until.tv_sec = 0;
    entry->blocked_until.tv_nsec = 0L;
  }

  if (entry->window_start.tv_sec == 0 && entry->window_start.tv_nsec == 0) {
    entry->window_start = now;
    entry->attempts = 0U;
  } else {
    struct timespec diff = timespec_diff(&now, &entry->window_start);
    long long window_ns = timespec_to_ns(&diff);
    if (window_ns > SSH_CHATTER_CONNECTION_GUARD_WINDOW_NS) {
      entry->window_start = now;
      entry->attempts = 0U;
      if (window_ns > SSH_CHATTER_CONNECTION_GUARD_RETENTION_NS) {
        entry->block_count = 0U;
      }
    }
  }

  if (entry->attempts < SIZE_MAX) {
    entry->attempts += 1U;
  }
  result.attempt_count = entry->attempts;
  result.block_count = entry->block_count;

  if (entry->attempts >= SSH_CHATTER_CONNECTION_GUARD_THRESHOLD) {
    size_t attempt_snapshot = entry->attempts;
    if (entry->block_count < UINT_MAX) {
      entry->block_count += 1U;
    }
    long long penalty_ns = SSH_CHATTER_CONNECTION_GUARD_BLOCK_BASE_NS +
                           (long long)(entry->block_count > 0U ? entry->block_count - 1U : 0U) *
                               SSH_CHATTER_CONNECTION_GUARD_BLOCK_STEP_NS;
    if (penalty_ns > SSH_CHATTER_CONNECTION_GUARD_BLOCK_MAX_NS) {
      penalty_ns = SSH_CHATTER_CONNECTION_GUARD_BLOCK_MAX_NS;
    }
    entry->blocked_until = timespec_add_ns(&now, penalty_ns);
    entry->window_start = now;
    entry->attempts = 0U;

    result.blocked = true;
    result.blocked_until = entry->blocked_until;
    result.block_count = entry->block_count;
    result.attempt_count = attempt_snapshot;
    if (entry->block_count >= SSH_CHATTER_CONNECTION_GUARD_BAN_THRESHOLD) {
      result.escalate_ban = true;
    }
  }

  pthread_mutex_unlock(&host->lock);
  return result;
}

static void host_error_guard_register_success(host_t *host) {
  if (host == NULL) {
    return;
  }

  host->health_guard.consecutive_errors = 0U;
  host->health_guard.last_error_time.tv_sec = 0;
  host->health_guard.last_error_time.tv_nsec = 0L;
}

static bool host_try_load_motd_from_path(host_t *host, const char *path);

static struct timespec host_stat_mtime(const struct stat *info) {
  struct timespec result = {0, 0};
  if (info == NULL) {
    return result;
  }

#if defined(__APPLE__)
  result.tv_sec = info->st_mtimespec.tv_sec;
  result.tv_nsec = info->st_mtimespec.tv_nsec;
#elif defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(__USE_XOPEN2K8)
  result.tv_sec = info->st_mtim.tv_sec;
  result.tv_nsec = info->st_mtim.tv_nsec;
#else
  result.tv_sec = info->st_mtime;
  result.tv_nsec = 0;
#endif

  if (result.tv_sec < 0) {
    result.tv_sec = 0;
  }
  if (result.tv_nsec < 0) {
    result.tv_nsec = 0;
  }
  return result;
}

static void host_maybe_reload_motd_from_file(host_t *host) {
  if (host == NULL) {
    return;
  }

  char stored_path[PATH_MAX];
  stored_path[0] = '\0';
  struct timespec last_loaded = {0, 0};
  bool had_file = false;

  pthread_mutex_lock(&host->lock);
  if (host->motd_path[0] != '\0') {
    snprintf(stored_path, sizeof(stored_path), "%s", host->motd_path);
    last_loaded = host->motd_last_modified;
    had_file = host->motd_has_file;
  }
  pthread_mutex_unlock(&host->lock);

  if (stored_path[0] == '\0') {
    return;
  }

  char resolved_path[PATH_MAX];
  resolved_path[0] = '\0';

  if (stored_path[0] == '~' && (stored_path[1] == '\0' || stored_path[1] == '/')) {
    const char *home = getenv("HOME");
    if (home != NULL && home[0] != '\0') {
      int expanded = snprintf(resolved_path, sizeof(resolved_path), "%s%s", home, stored_path + 1);
      if (expanded <= 0 || (size_t)expanded >= sizeof(resolved_path)) {
        resolved_path[0] = '\0';
      }
    }
  }

  const char *path_to_try = resolved_path[0] != '\0' ? resolved_path : stored_path;

  struct stat file_info;
  if (stat(path_to_try, &file_info) != 0 || !S_ISREG(file_info.st_mode)) {
    if (!had_file) {
      (void)host_try_load_motd_from_path(host, path_to_try);
    }
    if (had_file) {
      pthread_mutex_lock(&host->lock);
      if (host->motd_has_file && strncmp(host->motd_path, stored_path, sizeof(host->motd_path)) == 0) {
        host->motd_has_file = false;
        host->motd_last_modified.tv_sec = 0;
        host->motd_last_modified.tv_nsec = 0L;
      }
      pthread_mutex_unlock(&host->lock);
    }
    return;
  }

  struct timespec modified = host_stat_mtime(&file_info);

  if (had_file && modified.tv_sec == last_loaded.tv_sec && modified.tv_nsec == last_loaded.tv_nsec) {
    return;
  }

  (void)host_try_load_motd_from_path(host, path_to_try);
}

static unsigned session_simple_hash(const char *text) {
  unsigned hash = 5381U;
  if (text == NULL) {
    return hash;
  }

  for (const unsigned char *cursor = (const unsigned char *)text; *cursor != '\0'; ++cursor) {
    hash = (hash * 33U) ^ *cursor;
  }
  return hash;
}

static void session_build_captcha_prompt(session_ctx_t *ctx, captcha_prompt_t *prompt) {
  if (prompt == NULL) {
    return;
  }

  memset(prompt, 0, sizeof(*prompt));

  unsigned basis = session_simple_hash(ctx != NULL ? ctx->user.name : "user");
  basis ^= session_simple_hash(ctx != NULL ? ctx->client_ip : "ip");

  unsigned entropy = 0U;
  struct timespec now = {0, 0};
  if (clock_gettime(CLOCK_REALTIME, &now) == 0) {
    uint64_t now_sec = (uint64_t)now.tv_sec;
    entropy ^= (unsigned)now_sec;
    entropy ^= (unsigned)(now_sec >> 32);
    entropy ^= (unsigned)now.tv_nsec;
  } else {
    uint64_t fallback = (uint64_t)time(NULL);
    entropy ^= (unsigned)fallback;
    entropy ^= (unsigned)(fallback >> 32);
  }

  host_t *host = (ctx != NULL) ? ctx->owner : NULL;
  if (host != NULL) {
    pthread_mutex_lock(&host->lock);
    uint64_t nonce = ++host->captcha_nonce;
    pthread_mutex_unlock(&host->lock);
    entropy ^= (unsigned)nonce;
    entropy ^= (unsigned)(nonce >> 32);
  }

  basis ^= entropy;

  const unsigned variant_seed = basis ^ (basis >> 16U) ^ (entropy << 1U);
  unsigned prng_state = variant_seed | 1U;

  session_fill_digit_sum_prompt(prompt, &prng_state);
}

typedef struct {
  const char *name;
  const char *code;
} color_entry_t;

static const color_entry_t USER_COLOR_MAP[] = {
  {"black", ANSI_BLACK},          {"red", ANSI_RED},
  {"green", ANSI_GREEN},          {"yellow", ANSI_YELLOW},
  {"blue", ANSI_BLUE},           {"magenta", ANSI_MAGENTA},
  {"cyan", ANSI_CYAN},           {"white", ANSI_WHITE},
  {"default", ANSI_DEFAULT},

  {"검정", ANSI_BLACK},           {"검은색", ANSI_BLACK},
  {"黒", ANSI_BLACK},             {"黑", ANSI_BLACK},
  {"黑色", ANSI_BLACK},           {"черный", ANSI_BLACK},
  {"чёрный", ANSI_BLACK},

  {"빨강", ANSI_RED},            {"빨간색", ANSI_RED},
  {"赤", ANSI_RED},               {"红", ANSI_RED},
  {"红色", ANSI_RED},             {"красный", ANSI_RED},

  {"초록", ANSI_GREEN},          {"초록색", ANSI_GREEN},
  {"緑", ANSI_GREEN},             {"绿", ANSI_GREEN},
  {"绿色", ANSI_GREEN},           {"зелёный", ANSI_GREEN},
  {"зеленый", ANSI_GREEN},

  {"노랑", ANSI_YELLOW},         {"노란색", ANSI_YELLOW},
  {"黄色", ANSI_YELLOW},          {"黄", ANSI_YELLOW},
  {"黄色い", ANSI_YELLOW},        {"黃色", ANSI_YELLOW},
  {"жёлтый", ANSI_YELLOW},        {"желтый", ANSI_YELLOW},

  {"파랑", ANSI_BLUE},           {"파란색", ANSI_BLUE},
  {"青", ANSI_BLUE},              {"青色", ANSI_BLUE},
  {"蓝", ANSI_BLUE},             {"蓝色", ANSI_BLUE},
  {"синий", ANSI_BLUE},

  {"마젠타", ANSI_MAGENTA},      {"자주", ANSI_MAGENTA},
  {"보라", ANSI_MAGENTA},        {"보라색", ANSI_MAGENTA},
  {"マゼンタ", ANSI_MAGENTA},      {"紫", ANSI_MAGENTA},
  {"洋红", ANSI_MAGENTA},         {"品红", ANSI_MAGENTA},
  {"紫色", ANSI_MAGENTA},        {"пурпурный", ANSI_MAGENTA},
  {"фиолетовый", ANSI_MAGENTA},

  {"시안", ANSI_CYAN},           {"청록", ANSI_CYAN},
  {"하늘", ANSI_CYAN},           {"하늘색", ANSI_CYAN},
  {"シアン", ANSI_CYAN},          {"水色", ANSI_CYAN},
  {"青绿", ANSI_CYAN},           {"青色", ANSI_CYAN},
  {"青綠", ANSI_CYAN},           {"青藍", ANSI_CYAN},
  {"青蓝", ANSI_CYAN},           {"циан", ANSI_CYAN},
  {"бирюзовый", ANSI_CYAN},      {"голубой", ANSI_CYAN},

  {"하양", ANSI_WHITE},          {"흰색", ANSI_WHITE},
  {"白", ANSI_WHITE},             {"白色", ANSI_WHITE},
  {"белый", ANSI_WHITE},

  {"기본", ANSI_DEFAULT},        {"기본값", ANSI_DEFAULT},
  {"デフォルト", ANSI_DEFAULT},    {"既定", ANSI_DEFAULT},
  {"默认", ANSI_DEFAULT},         {"默認", ANSI_DEFAULT},
  {"по умолчанию", ANSI_DEFAULT},

  {"bright-black", ANSI_BRIGHT_BLACK},   {"bright-red", ANSI_BRIGHT_RED},
  {"bright-green", ANSI_BRIGHT_GREEN}, {"bright-yellow", ANSI_BRIGHT_YELLOW},
  {"bright-blue", ANSI_BRIGHT_BLUE},   {"bright-magenta", ANSI_BRIGHT_MAGENTA},
  {"bright-cyan", ANSI_BRIGHT_CYAN},   {"bright-white", ANSI_BRIGHT_WHITE},

  {"밝은검정", ANSI_BRIGHT_BLACK}, {"회색", ANSI_BRIGHT_BLACK},
  {"明るい黒", ANSI_BRIGHT_BLACK}, {"グレー", ANSI_BRIGHT_BLACK},
  {"灰色", ANSI_BRIGHT_BLACK},    {"серый", ANSI_BRIGHT_BLACK},

  {"밝은빨강", ANSI_BRIGHT_RED},  {"밝은빨간색", ANSI_BRIGHT_RED},
  {"明るい赤", ANSI_BRIGHT_RED},   {"亮红", ANSI_BRIGHT_RED},
  {"亮红色", ANSI_BRIGHT_RED},     {"ярко-красный", ANSI_BRIGHT_RED},

  {"밝은초록", ANSI_BRIGHT_GREEN}, {"밝은초록색", ANSI_BRIGHT_GREEN},
  {"明るい緑", ANSI_BRIGHT_GREEN}, {"亮绿", ANSI_BRIGHT_GREEN},
  {"亮绿色", ANSI_BRIGHT_GREEN},   {"ярко-зелёный", ANSI_BRIGHT_GREEN},
  {"ярко-зеленый", ANSI_BRIGHT_GREEN},

  {"밝은노랑", ANSI_BRIGHT_YELLOW}, {"밝은노란색", ANSI_BRIGHT_YELLOW},
  {"明るい黄", ANSI_BRIGHT_YELLOW}, {"亮黄", ANSI_BRIGHT_YELLOW},
  {"亮黄色", ANSI_BRIGHT_YELLOW},   {"ярко-жёлтый", ANSI_BRIGHT_YELLOW},
  {"ярко-желтый", ANSI_BRIGHT_YELLOW},

  {"밝은파랑", ANSI_BRIGHT_BLUE}, {"밝은파란색", ANSI_BRIGHT_BLUE},
  {"明るい青", ANSI_BRIGHT_BLUE},  {"亮蓝", ANSI_BRIGHT_BLUE},
  {"亮蓝色", ANSI_BRIGHT_BLUE},    {"ярко-синий", ANSI_BRIGHT_BLUE},

  {"밝은마젠타", ANSI_BRIGHT_MAGENTA}, {"밝은자주", ANSI_BRIGHT_MAGENTA},
  {"밝은보라", ANSI_BRIGHT_MAGENTA},   {"밝은보라색", ANSI_BRIGHT_MAGENTA},
  {"明るいマゼンタ", ANSI_BRIGHT_MAGENTA}, {"明るい紫", ANSI_BRIGHT_MAGENTA},
  {"亮洋红", ANSI_BRIGHT_MAGENTA}, {"亮品红", ANSI_BRIGHT_MAGENTA},
  {"亮紫色", ANSI_BRIGHT_MAGENTA}, {"ярко-пурпурный", ANSI_BRIGHT_MAGENTA},
  {"ярко-фиолетовый", ANSI_BRIGHT_MAGENTA},

  {"밝은시안", ANSI_BRIGHT_CYAN}, {"밝은청록", ANSI_BRIGHT_CYAN},
  {"밝은하늘", ANSI_BRIGHT_CYAN}, {"밝은하늘색", ANSI_BRIGHT_CYAN},
  {"明るいシアン", ANSI_BRIGHT_CYAN}, {"明るい水色", ANSI_BRIGHT_CYAN},
  {"亮青色", ANSI_BRIGHT_CYAN},   {"亮青绿", ANSI_BRIGHT_CYAN},
  {"亮青綠", ANSI_BRIGHT_CYAN},   {"亮青藍", ANSI_BRIGHT_CYAN},
  {"亮青蓝", ANSI_BRIGHT_CYAN},   {"ярко-циан", ANSI_BRIGHT_CYAN},
  {"ярко-бирюзовый", ANSI_BRIGHT_CYAN}, {"ярко-голубой", ANSI_BRIGHT_CYAN},

  {"밝은하양", ANSI_BRIGHT_WHITE}, {"밝은흰색", ANSI_BRIGHT_WHITE},
  {"明るい白", ANSI_BRIGHT_WHITE}, {"亮白", ANSI_BRIGHT_WHITE},
  {"亮白色", ANSI_BRIGHT_WHITE},   {"ярко-белый", ANSI_BRIGHT_WHITE},
};

static const color_entry_t HIGHLIGHT_COLOR_MAP[] = {
  {"black", ANSI_BG_BLACK},       {"red", ANSI_BG_RED},
  {"green", ANSI_BG_GREEN},       {"yellow", ANSI_BG_YELLOW},
  {"blue", ANSI_BG_BLUE},        {"magenta", ANSI_BG_MAGENTA},
  {"cyan", ANSI_BG_CYAN},        {"white", ANSI_BG_WHITE},
  {"default", ANSI_BG_DEFAULT},

  {"검정", ANSI_BG_BLACK},         {"검은색", ANSI_BG_BLACK},
  {"黒", ANSI_BG_BLACK},           {"黑", ANSI_BG_BLACK},
  {"黑色", ANSI_BG_BLACK},         {"черный", ANSI_BG_BLACK},
  {"чёрный", ANSI_BG_BLACK},

  {"빨강", ANSI_BG_RED},          {"빨간색", ANSI_BG_RED},
  {"赤", ANSI_BG_RED},             {"红", ANSI_BG_RED},
  {"红色", ANSI_BG_RED},           {"красный", ANSI_BG_RED},

  {"초록", ANSI_BG_GREEN},        {"초록색", ANSI_BG_GREEN},
  {"緑", ANSI_BG_GREEN},           {"绿", ANSI_BG_GREEN},
  {"绿色", ANSI_BG_GREEN},         {"зелёный", ANSI_BG_GREEN},
  {"зеленый", ANSI_BG_GREEN},

  {"노랑", ANSI_BG_YELLOW},       {"노란색", ANSI_BG_YELLOW},
  {"黄色", ANSI_BG_YELLOW},        {"黄", ANSI_BG_YELLOW},
  {"黄色い", ANSI_BG_YELLOW},      {"黃色", ANSI_BG_YELLOW},
  {"жёлтый", ANSI_BG_YELLOW},      {"желтый", ANSI_BG_YELLOW},

  {"파랑", ANSI_BG_BLUE},         {"파란색", ANSI_BG_BLUE},
  {"青", ANSI_BG_BLUE},            {"青色", ANSI_BG_BLUE},
  {"蓝", ANSI_BG_BLUE},           {"蓝色", ANSI_BG_BLUE},
  {"синий", ANSI_BG_BLUE},

  {"마젠타", ANSI_BG_MAGENTA},    {"자주", ANSI_BG_MAGENTA},
  {"보라", ANSI_BG_MAGENTA},      {"보라색", ANSI_BG_MAGENTA},
  {"マゼンタ", ANSI_BG_MAGENTA},    {"紫", ANSI_BG_MAGENTA},
  {"洋红", ANSI_BG_MAGENTA},       {"品红", ANSI_BG_MAGENTA},
  {"紫色", ANSI_BG_MAGENTA},      {"пурпурный", ANSI_BG_MAGENTA},
  {"фиолетовый", ANSI_BG_MAGENTA},

  {"시안", ANSI_BG_CYAN},         {"청록", ANSI_BG_CYAN},
  {"하늘", ANSI_BG_CYAN},         {"하늘색", ANSI_BG_CYAN},
  {"シアン", ANSI_BG_CYAN},        {"水色", ANSI_BG_CYAN},
  {"青绿", ANSI_BG_CYAN},         {"青色", ANSI_BG_CYAN},
  {"青綠", ANSI_BG_CYAN},         {"青藍", ANSI_BG_CYAN},
  {"青蓝", ANSI_BG_CYAN},         {"циан", ANSI_BG_CYAN},
  {"бирюзовый", ANSI_BG_CYAN},    {"голубой", ANSI_BG_CYAN},

  {"하양", ANSI_BG_WHITE},        {"흰색", ANSI_BG_WHITE},
  {"白", ANSI_BG_WHITE},           {"白色", ANSI_BG_WHITE},
  {"белый", ANSI_BG_WHITE},

  {"기본", ANSI_BG_DEFAULT},      {"기본값", ANSI_BG_DEFAULT},
  {"デフォルト", ANSI_BG_DEFAULT},  {"既定", ANSI_BG_DEFAULT},
  {"默认", ANSI_BG_DEFAULT},       {"默認", ANSI_BG_DEFAULT},
  {"по умолчанию", ANSI_BG_DEFAULT},

  {"bright-black", ANSI_BG_BRIGHT_BLACK}, {"bright-red", ANSI_BG_BRIGHT_RED},
  {"bright-green", ANSI_BG_BRIGHT_GREEN}, {"bright-yellow", ANSI_BG_BRIGHT_YELLOW},
  {"bright-blue", ANSI_BG_BRIGHT_BLUE},  {"bright-magenta", ANSI_BG_BRIGHT_MAGENTA},
  {"bright-cyan", ANSI_BG_BRIGHT_CYAN},  {"bright-white", ANSI_BG_BRIGHT_WHITE},

  {"밝은검정", ANSI_BG_BRIGHT_BLACK}, {"회색", ANSI_BG_BRIGHT_BLACK},
  {"明るい黒", ANSI_BG_BRIGHT_BLACK}, {"グレー", ANSI_BG_BRIGHT_BLACK},
  {"灰色", ANSI_BG_BRIGHT_BLACK},    {"серый", ANSI_BG_BRIGHT_BLACK},

  {"밝은빨강", ANSI_BG_BRIGHT_RED},  {"밝은빨간색", ANSI_BG_BRIGHT_RED},
  {"明るい赤", ANSI_BG_BRIGHT_RED},   {"亮红", ANSI_BG_BRIGHT_RED},
  {"亮红色", ANSI_BG_BRIGHT_RED},     {"ярко-красный", ANSI_BG_BRIGHT_RED},

  {"밝은초록", ANSI_BG_BRIGHT_GREEN}, {"밝은초록색", ANSI_BG_BRIGHT_GREEN},
  {"明るい緑", ANSI_BG_BRIGHT_GREEN}, {"亮绿", ANSI_BG_BRIGHT_GREEN},
  {"亮绿色", ANSI_BG_BRIGHT_GREEN},   {"ярко-зелёный", ANSI_BG_BRIGHT_GREEN},
  {"ярко-зеленый", ANSI_BG_BRIGHT_GREEN},

  {"밝은노랑", ANSI_BG_BRIGHT_YELLOW}, {"밝은노란색", ANSI_BG_BRIGHT_YELLOW},
  {"明るい黄", ANSI_BG_BRIGHT_YELLOW}, {"亮黄", ANSI_BG_BRIGHT_YELLOW},
  {"亮黄色", ANSI_BG_BRIGHT_YELLOW},   {"ярко-жёлтый", ANSI_BG_BRIGHT_YELLOW},
  {"ярко-желтый", ANSI_BG_BRIGHT_YELLOW},

  {"밝은파랑", ANSI_BG_BRIGHT_BLUE}, {"밝은파란색", ANSI_BG_BRIGHT_BLUE},
  {"明るい青", ANSI_BG_BRIGHT_BLUE},  {"亮蓝", ANSI_BG_BRIGHT_BLUE},
  {"亮蓝色", ANSI_BG_BRIGHT_BLUE},    {"ярко-синий", ANSI_BG_BRIGHT_BLUE},

  {"밝은마젠타", ANSI_BG_BRIGHT_MAGENTA}, {"밝은자주", ANSI_BG_BRIGHT_MAGENTA},
  {"밝은보라", ANSI_BG_BRIGHT_MAGENTA},   {"밝은보라색", ANSI_BG_BRIGHT_MAGENTA},
  {"明るいマゼンタ", ANSI_BG_BRIGHT_MAGENTA}, {"明るい紫", ANSI_BG_BRIGHT_MAGENTA},
  {"亮洋红", ANSI_BG_BRIGHT_MAGENTA}, {"亮品红", ANSI_BG_BRIGHT_MAGENTA},
  {"亮紫色", ANSI_BG_BRIGHT_MAGENTA}, {"ярко-пурпурный", ANSI_BG_BRIGHT_MAGENTA},
  {"ярко-фиолетовый", ANSI_BG_BRIGHT_MAGENTA},

  {"밝은시안", ANSI_BG_BRIGHT_CYAN}, {"밝은청록", ANSI_BG_BRIGHT_CYAN},
  {"밝은하늘", ANSI_BG_BRIGHT_CYAN}, {"밝은하늘색", ANSI_BG_BRIGHT_CYAN},
  {"明るいシアン", ANSI_BG_BRIGHT_CYAN}, {"明るい水色", ANSI_BG_BRIGHT_CYAN},
  {"亮青色", ANSI_BG_BRIGHT_CYAN},   {"亮青绿", ANSI_BG_BRIGHT_CYAN},
  {"亮青綠", ANSI_BG_BRIGHT_CYAN},   {"亮青藍", ANSI_BG_BRIGHT_CYAN},
  {"亮青蓝", ANSI_BG_BRIGHT_CYAN},   {"ярко-циан", ANSI_BG_BRIGHT_CYAN},
  {"ярко-бирюзовый", ANSI_BG_BRIGHT_CYAN}, {"ярко-голубой", ANSI_BG_BRIGHT_CYAN},

  {"밝은하양", ANSI_BG_BRIGHT_WHITE}, {"밝은흰색", ANSI_BG_BRIGHT_WHITE},
  {"明るい白", ANSI_BG_BRIGHT_WHITE}, {"亮白", ANSI_BG_BRIGHT_WHITE},
  {"亮白色", ANSI_BG_BRIGHT_WHITE},   {"ярко-белый", ANSI_BG_BRIGHT_WHITE},
};

typedef struct palette_descriptor {
  const char *name;
  const char *description;
  const char *user_color_name;
  const char *user_highlight_name;
  bool user_is_bold;
  const char *system_fg_name;
  const char *system_bg_name;
  const char *system_highlight_name;
  bool system_is_bold;
} palette_descriptor_t;

static const palette_descriptor_t PALETTE_DEFINITIONS[] = {
  {"windows", "High contrast palette reminiscent of Windows", "cyan", "blue", true, "white", "blue", "yellow", true},
  {"gnu-linux", "Modern, elegant, and free. the universal rhythm of your workflow.", "bright-green", "black", true, "blue", "black", "bright-yellow", true},
  {"macos", "Precision in silence. Minimalist contemporary unix.", "bright-white", "black", false, "bright-blue", "black", "white", false},
  {"freebsd", "Rigid and graceful BSD. The biggest 'True UNIX'", "bright-red", "black", false, "red", "black", "bright-white", false},
  {"solaris", "Ancient sun of enterprise UNIX: Sun, Machine, nostalgia.", "bright-yellow", "black", true, "bright-red", "black", "bright-white", true},
  {"openbsd-fortress", "Security through simplicity. calm blue walls over disciplined darkness.", "bright-blue", "black", false, "bright-white", "black", "cyan", false},
  {"netbsd-universal", "Runs on anything. Maybe your fridge, too?", "bright-cyan", "black", false, "bright-white", "black", "bright-yellow", false},

  {"moe", "Soft magenta accents with playful highlights", "bright-magenta", "white", true, "white", "bright-magenta", "cyan", true},
  {"neon-genesis-evangelion", "Sho-nen yo Shin-wa ni nare--", "bright-red", "white", true, "white", "bright-magenta", "blue", true},
  {"megami", "Japanese anime goddess cliché", "bright-white", "black", false, "bright-yellow", "blue", "cyan", false},

  {"clean", "Balanced neutral palette", "default", "default", false, "white", "default", "default", false},
  {"adwaita", "Bright background inspired by GNOME Adwaita", "blue", "default", false, "blue", "bright-white", "white", true},

  {"80shacker", "Bright monochrome green inspired by old CRT", "bright-green", "default", true, "bright-green", "default", "default", true},
  {"plato", "Bright monochrome yellow inspired by old Amber CRT", "yellow", "default", false, "yellow", "default", "default", false},
  {"atarist", "Sharp paper-white monochrome for high-res work", "bright-white", "black", true, "bright-white", "black", "black", false},
  {"win95bsod", "High-contrast blue screen of death style", "bright-white", "blue", true, "bright-white", "blue", "cyan", true},
  {"chn-hanzi", "Bright cyan high-clarity Chinese text terminal", "bright-cyan", "black", true, "white", "black", "cyan", true},

  {"usa-flag", "Flag blue base with red/white highlights", "bright-white", "blue", true, "red", "blue", "bright-white", true},
  {"jpn-flag", "Minimalist white with rising sun red accent", "bright-white", "black", false, "red", "black", "black", true},
  {"chn-flag", "Star-red background with lucky yellow text", "bright-yellow", "red", true, "white", "red", "white", true},
  {"rus-flag", "Tricolor base with strong red emphasis", "bright-white", "blue", true, "red", "blue", "bright-white", true},
  {"de-flag", "Tricolor base with strong red/yellow emphasis", "bright-black", "black", true, "yellow", "black", "red", true},
  {"holy-light", "Christian sacred light on pure white/blue base", "bright-white", "blue", false, "blue", "black", "yellow", true},

  {"islam", "Iconic color of muslim, white/green base", "bright-white", "green", false, "green", "black", "bright-white", true},
  {"dharma-ochre", "Ochre robes of enlightenment and vitality", "yellow", "black", true, "red", "black", "yellow", true},
  {"yin-yang", "Balance of Black and White with Jade accent", "white", "black", false, "green", "black", "white", false},

  {"soviet-cold", "Cold blue/white terminal for scientific systems", "white", "blue", false, "white", "cyan", "blue", true},
  {"hi-tel", "1990s Korean BBS blue background and text style", "bright-white", "blue", true, "bright-white", "blue", "magenta", true},
  {"amiga-cli", "AmigaOS style with cyan/blue", "cyan", "blue", true, "cyan", "blue", "blue", true},
  {"jpn-pc98", "NEC PC-9801 subtle, earthy low-res tones", "yellow", "black", false, "red", "black", "yellow", false},
  {"deep-blue", "IBM Supercomputer monitoring interface style", "white", "blue", true, "cyan", "blue", "white", true},

  {"korea", "Taegeuk-gi inspired black base with red and blue accents", "bright-blue", "blue", true, "bright-white", "blue", "red", true},

  {"neo-seoul", "Neon skyline of Gangnam and Hongdae: glowing magenta and cyan lights on dark asphalt", "bright-magenta", "black", true, "bright-cyan", "black", "cyan", true},
  {"incheon-industrial", "Metallic cranes and sodium streetlights of Incheon docks", "bright-yellow", "black", true, "bright-yellow", "black", "bright-red", true},
  {"gyeonggi-modern", "Suburban calm of modern Korea. asphalt gray and warm window light", "bright-white", "black", false, "bright-yellow", "black", "bright-cyan", false},
  {"korean-palace", "Royal dancheong harmony: jade green, vermilion red, and gold over black lacquer", "bright-yellow", "black", true, "red", "black", "green", false},

  {"gyeongsangbukdo", "Stoic mountains and agricultural spirit. stone, pine, and the quiet gold of temples", "bright-yellow", "black", false, "bright-green", "black", "bright-white", false},
  {"daegu-summer", "The biggest, the hottest of north gyeongsang: Blazing red-orange heat and festival gold under night sky", "bright-red", "black", true, "bright-yellow", "black", "yellow", true},
  {"gyeongju-heritage", "Eternal relics and golden crowns: moonlit stone and ancient buddhism with blue flag of shilla military force", "bright-white", "black", false, "bright-yellow", "black", "blue", false},
  {"kangwon-winter", "Cold white peaks and blue shadows of Gangwon’s frozen dawn", "bright-white", "blue", true, "bright-cyan", "blue", "white", true},
  {"ulsan-steel", "Molten metal glow inside heavy industry furnace halls", "bright-red", "black", true, "bright-yellow", "black", "red", true},

  {"jeolla-seaside", "Quiet sea and horizon light of Mokpo and Yeosu nights", "bright-cyan", "black", false, "cyan", "black", "bright-blue", true},
  {"gwangju-biennale", "Experimental art city with a heritage of democracy: violet neon and philosophical blue", "bright-magenta", "black", true, "bright-blue", "black", "magenta", true},
  {"jeonju-hanok", "The symbol of north jeolla. warm roofs and calm golden light", "bright-yellow", "black", false, "yellow", "black", "bright-white", false},

  {"daejeon-tech", "Futuristic research district glow: clean LED light on steel gray night", "white", "black", true, "white", "black", "bright-green", true},
  {"sejong-night", "Balanced dark-blue administration city under cool LED light", "bright-white", "blue", true, "bright-cyan", "blue", "white", true},
  {"cheongju-intellect", "Scholarly ink and soft dawn over hills: serene blue clarity", "bright-cyan", "black", false, "bright-white", "black", "cyan", false},
  {"chungcheong-field", "Muted greens and dust gold of inland farmlands", "yellow", "black", false, "green", "black", "yellow", false},

  {"jeju-rock", "Volcanic basalt, moss green, and deep sea mist of Jeju Island", "bright-green", "black", false, "bright-cyan", "black", "green", false},

  {"gyeongsangnamdo", "Sea breeze and industry — blue steel, orange dusk, and vibrant harbors", "bright-blue", "black", true, "bright-yellow", "black", "bright-cyan", true},
  {"busan-harbor", "Night harbor lights and steel-blue waters of Busan Port", "bright-blue", "black", true, "cyan", "black", "bright-blue", true},

  {"han", "Deep unresolved sorrow and austere beauty pale blue and gray layers", "bright-cyan", "blue", false, "white", "blue", "bright-white", false},
  {"jeong", "Warm emotional bonds and communal comfort soft red and gold glow on darkness", "bright-red", "black", true, "black", "black", "bright-yellow", true},
  {"heung", "Joyful energy and dynamic spirit: brilliant magenta and yellow over black", "bright-magenta", "black", true, "bright-yellow", "black", "magenta", true},
  {"nunchi", "Subtle perception and quiet adaptation: dim neutral tones with cyan glints", "white", "black", false, "bright-cyan", "black", "cyan", false},

  {"pcbang-night", "Late-night gaming neon: cold blue LEDs, energy drink, and so on", "bright-cyan", "black", true, "bright-red", "black", "bright-blue", true},
  {"alcohol", "Soju nights and neon haze: industrial green bottles and pink laughter", "bright-green", "black", true, "bright-magenta", "black", "green", true},

  {"korean-hardcore", "I don't wanna die yet! neon blood and cold steel over asphalt black", "bright-red", "black", true, "bright-blue", "black", "bright-red", true},
  {"korean-nationalists", "Slightly exclusive types. you know the kind.", "bright-green", "black", true, "bright-blue", "black", "bright-cyan", true},

  {"medieval-korea", "Celadon grace and temple gold over aged ink-black lacquer", "bright-cyan", "black", false, "bright-yellow", "black", "cyan", false},
  {"stoneage-korea", "Primitive contrast of pale clothing and ground stone tools - raw earth and silence", "bright-white", "black", false, "bright-yellow", "black", "white", false},

  {"flame-and-blood", "An East Asian war of 1592–1598. A great conflict akin to a world war, where flame met blood and nothing could be forsaken.", "bright-blue", "black", true, "bright-yellow", "black", "red", true},
  {"korean-war", "The Korean War: an unforgettable sorrow beneath ash, blood, and snow.", "bright-white", "black", false, "bright-red", "black", "white", false},
  {"independence-spirit", "The spirit of independence. A soul that we must remember.", "bright-red", "black", true, "blue", "black", "bright-yellow", true},
};

typedef int (*accept_channel_fn_t)(ssh_message, ssh_channel);

#if defined(__GNUC__)
extern int ssh_message_channel_request_open_reply_accept_channel(ssh_message message,
                                                                 ssh_channel channel)
    __attribute__((weak));
#endif

static void resolve_accept_channel_once(void);
static accept_channel_fn_t g_accept_channel_fn = NULL;
static pthread_once_t g_accept_channel_once = PTHREAD_ONCE_INIT;

static accept_channel_fn_t resolve_accept_channel_fn(void) {
  pthread_once(&g_accept_channel_once, resolve_accept_channel_once);
  return g_accept_channel_fn;
}

static void resolve_accept_channel_once(void) {
#if defined(__GNUC__)
  if (ssh_message_channel_request_open_reply_accept_channel != NULL) {
    g_accept_channel_fn = ssh_message_channel_request_open_reply_accept_channel;
    return;
  }
#endif

  static const char *kSymbol = "ssh_message_channel_request_open_reply_accept_channel";

#if defined(RTLD_DEFAULT)
  g_accept_channel_fn = (accept_channel_fn_t)dlsym(RTLD_DEFAULT, kSymbol);
  if (g_accept_channel_fn != NULL) {
    return;
  }
#endif

  const char *candidates[] = {"libssh.so.4", "libssh.so", "libssh.dylib"};
  for (size_t idx = 0; idx < sizeof(candidates) / sizeof(candidates[0]); ++idx) {
    const char *name = candidates[idx];
    void *handle = dlopen(name, RTLD_LAZY | RTLD_LOCAL);
    if (handle == NULL) {
      handle = dlopen(name, RTLD_LAZY);
    }
    if (handle == NULL) {
      continue;
    }

    g_accept_channel_fn = (accept_channel_fn_t)dlsym(handle, kSymbol);
    if (g_accept_channel_fn != NULL) {
      return;
    }
  }
}

static void trim_whitespace_inplace(char *text);
static const char *lookup_color_code(const color_entry_t *entries, size_t entry_count, const char *name);
static bool parse_bool_token(const char *token, bool *value);
static bool session_transport_active(const session_ctx_t *ctx);
static void session_transport_request_close(session_ctx_t *ctx);
static void session_channel_write(session_ctx_t *ctx, const void *data, size_t length);
static bool session_channel_write_cp437(session_ctx_t *ctx, const char *data, size_t length);
static bool session_channel_write_utf16(session_ctx_t *ctx, const char *data, size_t length);
static bool session_channel_write_utf16_segment(session_ctx_t *ctx, const char *data, size_t length);
static size_t session_utf8_decode_codepoint(const unsigned char *data, size_t length, uint32_t *codepoint);
static bool session_utf8_to_utf16le(const char *input, size_t length, unsigned char *output, size_t capacity,
                                    size_t *produced);
static bool session_channel_write_all(session_ctx_t *ctx, const void *data, size_t length);
static bool session_output_lock(session_ctx_t *ctx);
static void session_output_unlock(session_ctx_t *ctx);
static bool session_channel_wait_writable(session_ctx_t *ctx, int timeout_ms);
static void session_channel_log_write_failure(session_ctx_t *ctx, const char *reason);
static int session_transport_read(session_ctx_t *ctx, void *buffer, size_t length, int timeout_ms);
static bool session_transport_is_open(const session_ctx_t *ctx);
static bool session_transport_is_eof(const session_ctx_t *ctx);
static void session_apply_background_fill(session_ctx_t *ctx);
static void session_write_rendered_line(session_ctx_t *ctx, const char *render_source);
static void session_send_caption_line(session_ctx_t *ctx, const char *message);
static void session_render_caption_with_offset(session_ctx_t *ctx, const char *message, size_t move_up);
static void session_send_line(session_ctx_t *ctx, const char *message);
static void session_send_plain_line(session_ctx_t *ctx, const char *message);
static void session_send_system_line(session_ctx_t *ctx, const char *message);
static void session_send_raw_text(session_ctx_t *ctx, const char *text);
static void session_send_raw_text_bulk(session_ctx_t *ctx, const char *text);
static bool session_render_external_banner(session_ctx_t *ctx);
static void session_render_banner_ascii(session_ctx_t *ctx);
static void session_render_prelogin_banner(session_ctx_t *ctx);
static session_ui_language_t session_client_geo_language(const session_ctx_t *ctx);
static void session_render_prelogin_language_prompt(session_ctx_t *ctx);
static void session_render_banner(session_ctx_t *ctx);
static const char *session_editor_terminator(const session_ctx_t *ctx);
static bool session_editor_matches_terminator(const session_ctx_t *ctx, const char *line);
static size_t session_editor_body_capacity(const session_ctx_t *ctx);
static size_t session_editor_max_lines(const session_ctx_t *ctx);
static void session_format_separator_line(session_ctx_t *ctx, const char *label, char *out, size_t length);
static void session_render_separator(session_ctx_t *ctx, const char *label);
static void session_clear_screen(session_ctx_t *ctx);
static void session_bbs_prepare_canvas(session_ctx_t *ctx);
static void session_bbs_render_editor(session_ctx_t *ctx, const char *status);
static void session_bbs_recalculate_line_count(session_ctx_t *ctx);
static bool session_bbs_get_line_range(const session_ctx_t *ctx, size_t line_index, size_t *start, size_t *length);
static void session_bbs_copy_line(const session_ctx_t *ctx, size_t line_index, char *buffer, size_t length);
static bool session_bbs_append_line(session_ctx_t *ctx, const char *line, char *status, size_t status_length);
static bool session_bbs_replace_line(session_ctx_t *ctx, size_t line_index, const char *line, char *status,
                                     size_t status_length);
static void session_bbs_move_cursor(session_ctx_t *ctx, int direction);
static bool session_bbs_is_admin_only_tag(const char *tag);
static void session_bbs_buffer_breaking_notice(session_ctx_t *ctx, const char *message);
static bool session_bbs_should_defer_breaking(session_ctx_t *ctx, const char *message);
static void session_render_prompt(session_ctx_t *ctx, bool include_separator);
static void session_refresh_input_line(session_ctx_t *ctx);
static void session_set_input_text(session_ctx_t *ctx, const char *text);
static void session_local_echo_char(session_ctx_t *ctx, char ch);
static void session_local_backspace(session_ctx_t *ctx);
static void session_clear_input(session_ctx_t *ctx);
static bool session_try_command_completion(session_ctx_t *ctx);
static bool session_consume_escape_sequence(session_ctx_t *ctx, char ch);
static void session_cleanup(session_ctx_t *ctx);
static void *session_thread(void *arg);
static void host_telnet_listener_stop(host_t *host);
static void session_refresh_output_encoding(session_ctx_t *ctx);
static bool session_detect_retro_client(session_ctx_t *ctx);
static void session_telnet_request_terminal_type(session_ctx_t *ctx);
static void session_telnet_capture_startup_metadata(session_ctx_t *ctx);
static void session_history_record(session_ctx_t *ctx, const char *line);
static void session_history_navigate(session_ctx_t *ctx, int direction);
static void session_scrollback_reset_position(session_ctx_t *ctx);
static void session_scrollback_navigate(session_ctx_t *ctx, int direction);
static bool session_try_localized_command_forward(session_ctx_t *ctx, const char *line);
static void chat_history_entry_prepare_user(chat_history_entry_t *entry, const session_ctx_t *from, const char *message);
static bool host_history_record_user(host_t *host, const session_ctx_t *from, const char *message, chat_history_entry_t *stored_entry);
static bool host_history_commit_entry(host_t *host, chat_history_entry_t *entry, chat_history_entry_t *stored_entry);
static void host_notify_external_clients(host_t *host, const chat_history_entry_t *entry);
static bool host_history_append_locked(host_t *host, const chat_history_entry_t *entry);
static bool host_history_reserve_locked(host_t *host, size_t min_capacity);
static size_t host_history_total(host_t *host);
static size_t host_history_copy_range(host_t *host, size_t start_index, chat_history_entry_t *buffer, size_t capacity);
static bool host_history_find_entry_by_id(host_t *host, uint64_t message_id, chat_history_entry_t *entry);
static size_t host_history_delete_range(host_t *host, uint64_t start_id, uint64_t end_id, uint64_t *first_removed,
                                        uint64_t *last_removed, size_t *replies_removed);
static void chat_room_broadcast_entry(chat_room_t *room, const chat_history_entry_t *entry, const session_ctx_t *from);
static void chat_room_broadcast(chat_room_t *room, const char *message, const session_ctx_t *from);
static void chat_room_broadcast_caption(chat_room_t *room, const char *message);
static bool host_history_apply_reaction(host_t *host, uint64_t message_id, size_t reaction_index, chat_history_entry_t *updated_entry);
static bool chat_history_entry_build_reaction_summary(const chat_history_entry_t *entry, char *buffer, size_t length);
static void host_ban_resolve_path(host_t *host);
static void host_ban_state_save_locked(host_t *host);
static void host_ban_state_load(host_t *host);
static void host_reply_state_resolve_path(host_t *host);
static void host_reply_state_save_locked(host_t *host);
static void host_reply_state_load(host_t *host);
static bool host_replies_find_entry_by_id(host_t *host, uint64_t reply_id, chat_reply_entry_t *entry);
static bool host_replies_commit_entry(host_t *host, chat_reply_entry_t *entry, chat_reply_entry_t *stored_entry);
static void session_send_reply_tree(session_ctx_t *ctx, uint64_t parent_message_id, uint64_t parent_reply_id, size_t depth);
static void host_broadcast_reply(host_t *host, const chat_reply_entry_t *entry);
static void session_send_private_message_line(session_ctx_t *ctx, const session_ctx_t *color_source,
                                              const char *label, const char *message);
static session_ctx_t *chat_room_find_user(chat_room_t *room, const char *username);
static bool host_is_ip_banned(host_t *host, const char *ip);
static bool host_is_username_banned(host_t *host, const char *username);
static bool host_add_ban_entry(host_t *host, const char *username, const char *ip);
static bool host_remove_ban_entry(host_t *host, const char *token);
static join_activity_entry_t *host_find_join_activity_locked(host_t *host, const char *ip);
static join_activity_entry_t *host_ensure_join_activity_locked(host_t *host, const char *ip);
static bool host_register_suspicious_activity(host_t *host, const char *username, const char *ip,
                                             size_t *attempts_out);
static bool session_is_private_ipv4(const unsigned char octets[4]);
static bool session_is_lan_client(const char *ip);
static void session_assign_lan_privileges(session_ctx_t *ctx);
static void session_apply_granted_privileges(session_ctx_t *ctx);
static void session_apply_theme_defaults(session_ctx_t *ctx);
static void session_apply_system_theme_defaults(session_ctx_t *ctx);
static void session_force_dark_mode_foreground(session_ctx_t *ctx);
static void session_apply_saved_preferences(session_ctx_t *ctx);
static void session_dispatch_command(session_ctx_t *ctx, const char *line);
static void session_handle_exit(session_ctx_t *ctx);
static void session_force_disconnect(session_ctx_t *ctx, const char *reason);
static void session_handle_nick(session_ctx_t *ctx, const char *arguments);
static bool session_detect_provider_ip(const char *ip, char *label, size_t length);
static bool host_lookup_member_ip(host_t *host, const char *username, char *ip, size_t length);
static bool host_lookup_last_ip(host_t *host, const char *username, char *ip, size_t length);
static bool session_should_hide_entry(session_ctx_t *ctx, const chat_history_entry_t *entry);
static bool session_blocklist_add(session_ctx_t *ctx, const char *ip, const char *username, bool ip_wide,
                                  bool *already_present);
static bool session_blocklist_remove(session_ctx_t *ctx, const char *token);
static void session_blocklist_show(session_ctx_t *ctx);
static void session_handle_reply(session_ctx_t *ctx, const char *arguments);
static void session_handle_block(session_ctx_t *ctx, const char *arguments);
static void session_handle_unblock(session_ctx_t *ctx, const char *arguments);
static void session_handle_pm(session_ctx_t *ctx, const char *arguments);
static void session_handle_motd(session_ctx_t *ctx);
static void session_handle_system_color(session_ctx_t *ctx, const char *arguments);
static void session_handle_palette(session_ctx_t *ctx, const char *arguments);
static void session_handle_translate(session_ctx_t *ctx, const char *arguments);
static void session_handle_translate_scope(session_ctx_t *ctx, const char *arguments);
static void session_handle_gemini(session_ctx_t *ctx, const char *arguments);
static void session_handle_captcha(session_ctx_t *ctx, const char *arguments);
static void session_handle_set_trans_lang(session_ctx_t *ctx, const char *arguments);
static void session_handle_set_target_lang(session_ctx_t *ctx, const char *arguments);
static void session_handle_chat_spacing(session_ctx_t *ctx, const char *arguments);
static void session_handle_mode(session_ctx_t *ctx, const char *arguments);
static void session_handle_history(session_ctx_t *ctx, const char *arguments);
static void session_handle_eliza(session_ctx_t *ctx, const char *arguments);
static void session_handle_status(session_ctx_t *ctx, const char *arguments);
static void session_handle_showstatus(session_ctx_t *ctx, const char *arguments);
static void session_handle_weather(session_ctx_t *ctx, const char *arguments);
static void session_handle_pardon(session_ctx_t *ctx, const char *arguments);
static void session_handle_ban_name(session_ctx_t *ctx, const char *arguments);
static void session_handle_ban_list(session_ctx_t *ctx, const char *arguments);
static void session_handle_kick(session_ctx_t *ctx, const char *arguments);
static void session_handle_usercount(session_ctx_t *ctx);
static bool host_username_reserved(host_t *host, const char *username);
static void session_handle_search(session_ctx_t *ctx, const char *arguments);
static void session_handle_chat_lookup(session_ctx_t *ctx, const char *arguments);
static void session_handle_image(session_ctx_t *ctx, const char *arguments);
static void session_handle_video(session_ctx_t *ctx, const char *arguments);
static void session_handle_audio(session_ctx_t *ctx, const char *arguments);
static void session_handle_files(session_ctx_t *ctx, const char *arguments);
static void session_handle_reaction(session_ctx_t *ctx, size_t reaction_index, const char *arguments);
static void session_handle_mail(session_ctx_t *ctx, const char *arguments);
static void session_handle_profile_picture(session_ctx_t *ctx, const char *arguments);
static void session_handle_today(session_ctx_t *ctx);
static void session_handle_date(session_ctx_t *ctx, const char *arguments);
static void session_handle_os(session_ctx_t *ctx, const char *arguments);
static void session_handle_getos(session_ctx_t *ctx, const char *arguments);
static void session_handle_getaddr(session_ctx_t *ctx, const char *arguments);
static void session_handle_pair(session_ctx_t *ctx);
static void session_handle_connected(session_ctx_t *ctx);
static bool session_parse_birthday(const char *input, char *normalized, size_t length);
static void session_handle_birthday(session_ctx_t *ctx, const char *arguments);
static void session_handle_soulmate(session_ctx_t *ctx);
static void session_handle_grant(session_ctx_t *ctx, const char *arguments);
static void session_handle_revoke(session_ctx_t *ctx, const char *arguments);
static void session_handle_delete_message(session_ctx_t *ctx, const char *arguments);
static void session_normalize_newlines(char *text);
static bool timezone_sanitize_identifier(const char *input, char *output, size_t length);
static bool timezone_resolve_identifier(const char *input, char *resolved, size_t length);
static const palette_descriptor_t *palette_find_descriptor(const char *name);
static bool palette_apply_to_session(session_ctx_t *ctx, const palette_descriptor_t *descriptor);
static void session_translation_flush_ready(session_ctx_t *ctx);
static bool session_translation_queue_caption(session_ctx_t *ctx, const char *message, size_t placeholder_lines);
static void session_translation_reserve_placeholders(session_ctx_t *ctx, size_t placeholder_lines);
static void session_translation_clear_queue(session_ctx_t *ctx);
static bool session_translation_worker_ensure(session_ctx_t *ctx);
static void session_translation_worker_shutdown(session_ctx_t *ctx);
static void *session_translation_worker(void *arg);
static void session_translation_queue_block(session_ctx_t *ctx, const char *text);
static bool session_translation_queue_private_message(session_ctx_t *ctx, session_ctx_t *target, const char *message);
static void session_translation_normalize_output(char *text);
static void host_handle_translation_quota_exhausted(host_t *host);
static void session_handle_translation_quota_exhausted(session_ctx_t *ctx, const char *error_detail);
static bool session_argument_is_disable(const char *token);
static void session_language_normalize(const char *input, char *normalized, size_t length);
static bool session_language_equals(const char *lhs, const char *rhs);
static session_ui_language_t session_ui_language_from_code(const char *code);
static const char *session_ui_language_code(session_ui_language_t language);
static const char *session_ui_language_name(session_ui_language_t language, session_ui_language_t locale);
static const session_ui_locale_t *session_ui_get_locale(const session_ctx_t *ctx);
static const char *session_command_prefix(const session_ctx_t *ctx);
static int session_utf8_display_width(const char *text);
static void session_format_help_line(session_ctx_t *ctx, const session_help_entry_t *entry, const char *description,
                                     char *buffer, size_t length);
static void session_help_send_entries(session_ctx_t *ctx, const session_help_entry_t *entries, size_t count);
static bool session_fetch_weather_summary(const char *region, const char *city, char *summary, size_t summary_len);
static void session_handle_poll(session_ctx_t *ctx, const char *arguments);
static void session_handle_vote(session_ctx_t *ctx, size_t option_index);
static void session_handle_named_vote(session_ctx_t *ctx, size_t option_index, const char *label);
static void session_handle_elect_command(session_ctx_t *ctx, const char *arguments);
static void session_handle_vote_command(session_ctx_t *ctx, const char *arguments, bool allow_multiple);
static void session_handle_alpha_centauri_landers(session_ctx_t *ctx);
static void session_print_help(session_ctx_t *ctx);
static void session_print_help_extra(session_ctx_t *ctx);
static void session_handle_set_ui_lang(session_ctx_t *ctx, const char *arguments);
static bool session_line_is_exit_command(const char *line);
static void session_handle_username_conflict_input(session_ctx_t *ctx, const char *line);
static const char *session_consume_token(const char *input, char *token, size_t length);
static bool session_user_data_available(session_ctx_t *ctx);
static bool session_user_data_load(session_ctx_t *ctx);
static bool session_user_data_commit(session_ctx_t *ctx);
static void session_user_data_touch(session_ctx_t *ctx);
static bool host_user_data_send_mail(host_t *host, const char *recipient, const char *recipient_ip,
                                    const char *sender, const char *message, char *error, size_t error_length);
static bool host_user_data_load_existing(host_t *host, const char *username, const char *ip,
                                        user_data_record_t *record, bool create_if_missing);
static void host_user_data_bootstrap(host_t *host);
static bool session_parse_color_arguments(char *working, char **tokens, size_t max_tokens, size_t *token_count);
static size_t session_utf8_prev_char_len(const char *buffer, size_t length);
static int session_utf8_char_width(const char *bytes, size_t length);
static void host_history_record_system(host_t *host, const char *message);
static void session_send_history_entry(session_ctx_t *ctx, const chat_history_entry_t *entry);
static void session_deliver_outgoing_message(session_ctx_t *ctx, const char *message,
                                             bool clear_prompt_text);
static void chat_room_broadcast_reaction_update(host_t *host, const chat_history_entry_t *entry);
static user_preference_t *host_find_preference_locked(host_t *host, const char *username);
static user_preference_t *host_ensure_preference_locked(host_t *host, const char *username);
static void host_store_user_theme(host_t *host, const session_ctx_t *ctx);
static size_t host_prepare_join_delay(host_t *host, struct timespec *wait_duration);
static host_join_attempt_result_t host_register_join_attempt(host_t *host, const char *username, const char *ip);
static bool session_run_captcha(session_ctx_t *ctx);
static bool session_is_captcha_exempt(const session_ctx_t *ctx);
static void host_store_system_theme(host_t *host, const session_ctx_t *ctx);
static void host_store_user_os(host_t *host, const session_ctx_t *ctx);
static void host_store_birthday(host_t *host, const session_ctx_t *ctx, const char *birthday);
static void host_store_chat_spacing(host_t *host, const session_ctx_t *ctx);
static void host_store_translation_preferences(host_t *host, const session_ctx_t *ctx);
static void host_store_ui_language(host_t *host, const session_ctx_t *ctx);
static bool host_ip_has_grant_locked(host_t *host, const char *ip);
static bool host_ip_has_grant(host_t *host, const char *ip);
static bool host_add_operator_grant_locked(host_t *host, const char *ip);
static bool host_remove_operator_grant_locked(host_t *host, const char *ip);
static void host_apply_grant_to_ip(host_t *host, const char *ip);
static void host_refresh_motd_locked(host_t *host);
static void host_refresh_motd(host_t *host);
static void host_build_birthday_notice_locked(host_t *host, char *line, size_t length);
static bool host_is_leap_year(int year);
static void host_revoke_grant_from_ip(host_t *host, const char *ip);
static void host_history_normalize_entry(host_t *host, chat_history_entry_t *entry);
static const char *chat_attachment_type_label(chat_attachment_type_t type);
static void host_state_resolve_path(host_t *host);
static void host_state_load(host_t *host);
static void host_state_save_locked(host_t *host);
static void host_eliza_state_resolve_path(host_t *host);
static void host_eliza_state_load(host_t *host);
static void host_eliza_state_save_locked(host_t *host);
static void host_eliza_memory_resolve_path(host_t *host);
static void host_eliza_memory_load(host_t *host);
static void host_eliza_memory_save_locked(host_t *host);
static void host_eliza_memory_store(host_t *host, const char *prompt, const char *reply);
static size_t host_eliza_memory_collect_context(host_t *host, const char *prompt, char *context,
                                                size_t context_length);
static void host_eliza_history_normalize_line(char *text);
static size_t host_eliza_history_collect_context(host_t *host, char *context, size_t context_length);
static void host_eliza_prepare_preview(const char *source, char *dest, size_t dest_length);
static size_t host_eliza_bbs_collect_context(host_t *host, char *context, size_t context_length);
static size_t host_eliza_memory_collect_tokens(const char *prompt, char tokens[][32], size_t max_tokens);
static void host_bbs_resolve_path(host_t *host);
static void host_bbs_state_load(host_t *host);
static void host_bbs_state_save_locked(host_t *host);
static void host_bbs_start_watchdog(host_t *host);
static void *host_bbs_watchdog_thread(void *arg);
static void host_bbs_watchdog_scan(host_t *host);
static void host_security_configure(host_t *host);
static bool host_ensure_private_data_path(host_t *host, const char *path, bool create_directories);
static void host_security_compact_whitespace(char *text);
static bool host_security_execute_clamav_backend(host_t *host, char *notice, size_t notice_length);
static void *host_security_clamav_backend(void *arg);
static void host_security_start_clamav_backend(host_t *host);
static void host_security_disable_filter(host_t *host, const char *reason);
static void host_security_disable_clamav(host_t *host, const char *reason);
static host_security_scan_result_t host_security_scan_payload(host_t *host, const char *category, const char *payload,
                                                              size_t length, char *diagnostic, size_t diagnostic_length);
static void host_security_process_blocked(host_t *host, const char *category, const char *diagnostic,
                                         const char *username, const char *ip, session_ctx_t *session,
                                         bool post_send, const char *content);
static void host_security_process_error(host_t *host, const char *category, const char *diagnostic,
                                         const char *username, const char *ip, session_ctx_t *session,
                                         bool post_send);
static bool host_moderation_init(host_t *host);
static void host_moderation_shutdown(host_t *host);
static void host_moderation_backoff(unsigned int attempts);
static bool host_moderation_spawn_worker(host_t *host);
static void host_moderation_close_worker(host_t *host);
static bool host_moderation_recover_worker(host_t *host, const char *diagnostic);
static bool host_moderation_queue_chat(session_ctx_t *ctx, const char *message, size_t length);
static void *host_moderation_thread(void *arg);
static bool host_moderation_write_all(int fd, const void *buffer, size_t length);
static bool host_moderation_read_all(int fd, void *buffer, size_t length);
static void host_moderation_worker_loop(int request_fd, int response_fd);
static void host_moderation_handle_failure(host_t *host, host_moderation_task_t *task, const char *diagnostic);
static void host_moderation_apply_result(host_t *host, host_moderation_task_t *task,
                                         const host_moderation_ipc_response_t *response, const char *message);
static void host_moderation_flush_pending(host_t *host, const char *diagnostic);
static double host_elapsed_seconds(const struct timespec *start, const struct timespec *end);
static bool host_eliza_enable(host_t *host);
static bool host_eliza_disable(host_t *host);
static void host_eliza_announce_join(host_t *host);
static void host_eliza_announce_depart(host_t *host);
static void host_eliza_say(host_t *host, const char *message);
static void host_eliza_handle_private_message(session_ctx_t *ctx, const char *message);
static void host_eliza_prepare_private_reply(const char *message, char *reply, size_t reply_length);
static bool host_eliza_content_is_severe(const char *text);
static bool host_eliza_worker_init(host_t *host);
static void host_eliza_worker_shutdown(host_t *host);
static bool host_eliza_worker_enqueue(host_t *host, host_eliza_intervene_task_t *task);
static void *host_eliza_worker_thread(void *arg);
static bool host_eliza_intervene(session_ctx_t *ctx, const char *content, const char *reason, bool from_filter);
static void host_eliza_intervene_execute(session_ctx_t *ctx, const char *reason, bool from_filter);
static host_security_scan_result_t session_security_check_text(session_ctx_t *ctx, const char *category,
                                                               const char *content, size_t length, bool post_send);
static void host_vote_resolve_path(host_t *host);
static void host_vote_state_load(host_t *host);
static void host_vote_state_save_locked(host_t *host);
static bool host_try_load_motd_from_path(host_t *host, const char *path);
static bool username_contains(const char *username, const char *needle);
static void host_apply_palette_descriptor(host_t *host, const palette_descriptor_t *descriptor);
static bool host_lookup_user_os(host_t *host, const char *username, char *buffer, size_t length);
static void session_send_poll_summary(session_ctx_t *ctx);
static void session_send_poll_summary_generic(session_ctx_t *ctx, const poll_state_t *poll, const char *label);
static void session_list_named_polls(session_ctx_t *ctx);
static void session_handle_bbs(session_ctx_t *ctx, const char *arguments);
static void poll_state_reset(poll_state_t *poll);
static void named_poll_reset(named_poll_state_t *poll);
static named_poll_state_t *host_find_named_poll_locked(host_t *host, const char *label);
static named_poll_state_t *host_ensure_named_poll_locked(host_t *host, const char *label);
static void host_recount_named_polls_locked(host_t *host);
static bool poll_label_is_valid(const char *label);
static void session_bbs_show_dashboard(session_ctx_t *ctx);
static void session_bbs_list(session_ctx_t *ctx);
static void session_bbs_list_topic(session_ctx_t *ctx, const char *topic);
static void session_bbs_read(session_ctx_t *ctx, uint64_t id);
static void session_bbs_begin_post(session_ctx_t *ctx, const char *arguments);
static void session_bbs_begin_edit(session_ctx_t *ctx, uint64_t id);
static void session_bbs_capture_body_text(session_ctx_t *ctx, const char *text);
static void session_bbs_capture_body_line(session_ctx_t *ctx, const char *line);
static bool session_bbs_capture_continue(const session_ctx_t *ctx);
static void session_bbs_add_comment(session_ctx_t *ctx, const char *arguments);
static void session_bbs_regen_post(session_ctx_t *ctx, uint64_t id);
static void session_bbs_delete(session_ctx_t *ctx, uint64_t id);
static void session_bbs_reset_pending_post(session_ctx_t *ctx);
static bbs_post_t *host_find_bbs_post_locked(host_t *host, uint64_t id);
static bbs_post_t *host_allocate_bbs_post_locked(host_t *host);
static void host_clear_bbs_post_locked(host_t *host, bbs_post_t *post);
static void session_bbs_queue_translation(session_ctx_t *ctx, const bbs_post_t *post);
static void session_bbs_render_post(session_ctx_t *ctx, const bbs_post_t *post, const char *notice,
                                    bool reset_scroll, bool scroll_to_bottom);
static bool host_user_data_load_existing(host_t *host, const char *username, const char *ip,
                                        user_data_record_t *record, bool create_if_missing);
static void host_user_data_build_match_key(const char *username, char *key, size_t length);
static bool host_user_data_find_profile_picture(host_t *host, const char *alias, user_data_record_t *record);
static bool session_bbs_scroll(session_ctx_t *ctx, int direction, size_t step);
static bool session_bbs_refresh_view(session_ctx_t *ctx);
static void session_handle_rss(session_ctx_t *ctx, const char *arguments);
static void session_rss_list(session_ctx_t *ctx);
static void session_rss_read(session_ctx_t *ctx, const char *tag);
static void session_rss_begin(session_ctx_t *ctx, const char *tag, const rss_session_item_t *items, size_t count);
static void session_rss_show_current(session_ctx_t *ctx);
static bool session_rss_move(session_ctx_t *ctx, int delta);
static void session_rss_exit(session_ctx_t *ctx, const char *reason);
static void session_rss_clear(session_ctx_t *ctx);
static bool session_parse_command(const char *line, const char *command, const char **arguments);
static bool session_parse_localized_command(session_ctx_t *ctx, const session_command_alias_t *alias, const char *line,
                                            const char **arguments);
static void rss_strip_html(char *text);
static void rss_decode_entities(char *text);
static void rss_trim_whitespace(char *text);
static bool rss_tag_is_valid(const char *tag);
static rss_feed_t *host_find_rss_feed_locked(host_t *host, const char *tag);
static void host_clear_rss_feed(rss_feed_t *feed);
static void host_rss_recount_locked(host_t *host);
static bool host_rss_add_feed(host_t *host, const char *url, const char *tag, char *error, size_t error_length);
static bool host_rss_remove_feed(host_t *host, const char *tag, char *error, size_t error_length);
static void host_rss_resolve_path(host_t *host);
static void host_rss_state_load(host_t *host);
static void host_rss_state_save_locked(host_t *host);
static size_t host_rss_write_callback(void *contents, size_t size, size_t nmemb, void *userp);
static bool host_rss_download(const char *url, char **payload, size_t *length);
static bool host_rss_extract_tag(const char *block, const char *tag, char *out, size_t out_len);
static bool host_rss_extract_atom_link(const char *block, char *out, size_t out_len);
static size_t host_rss_parse_items(const char *payload, rss_session_item_t *items, size_t max_items);
static bool host_rss_fetch_items(const rss_feed_t *feed, rss_session_item_t *items, size_t max_items, size_t *out_count);
static void host_rss_start_backend(host_t *host);
static void *host_rss_backend(void *arg);
static bool host_rss_should_broadcast_breaking(const rss_session_item_t *item);
static bool host_asciiart_cooldown_active(host_t *host, const char *ip, const struct timespec *now,
                                          long *remaining_seconds);
static void host_asciiart_register_post(host_t *host, const char *ip, const struct timespec *when);
static bool session_asciiart_cooldown_active(session_ctx_t *ctx, struct timespec *now, long *remaining_seconds);
static void session_asciiart_reset(session_ctx_t *ctx);
static void session_asciiart_begin(session_ctx_t *ctx, session_asciiart_target_t target);
static void session_asciiart_import_from_editor(session_ctx_t *ctx);
static void session_asciiart_capture_text(session_ctx_t *ctx, const char *text);
static void session_asciiart_capture_line(session_ctx_t *ctx, const char *line);
static void session_asciiart_commit(session_ctx_t *ctx);
static void session_asciiart_cancel(session_ctx_t *ctx, const char *reason);
typedef void (*session_text_line_consumer_t)(session_ctx_t *, const char *);
typedef bool (*session_text_continue_predicate_t)(const session_ctx_t *);
static void session_capture_multiline_text(session_ctx_t *ctx, const char *text, session_text_line_consumer_t consumer,
                                           session_text_continue_predicate_t should_continue);
static bool session_asciiart_capture_continue(const session_ctx_t *ctx);
static void session_handle_game(session_ctx_t *ctx, const char *arguments);
static void session_game_suspend(session_ctx_t *ctx, const char *reason);
static int session_channel_read_poll(session_ctx_t *ctx, char *buffer, size_t length, int timeout_ms);
static void session_game_seed_rng(session_ctx_t *ctx);
static uint32_t session_game_random(session_ctx_t *ctx);
static int session_game_random_range(session_ctx_t *ctx, int max);
static void session_game_start_tetris(session_ctx_t *ctx);
static void session_game_tetris_reset(tetris_game_state_t *state);
static void session_game_tetris_apply_round_settings(tetris_game_state_t *state);
static void session_game_tetris_handle_round_progress(session_ctx_t *ctx);
static void session_game_tetris_fill_bag(session_ctx_t *ctx);
static int session_game_tetris_take_piece(session_ctx_t *ctx);
static bool session_game_tetris_spawn_piece(session_ctx_t *ctx);
static bool session_game_tetris_cell_occupied(int piece, int rotation, int row, int column);
static bool session_game_tetris_position_valid(const tetris_game_state_t *state, int piece, int rotation, int row,
                                               int column);
static bool session_game_tetris_move(session_ctx_t *ctx, int drow, int dcol);
static bool session_game_tetris_soft_drop(session_ctx_t *ctx);
static bool session_game_tetris_rotate(session_ctx_t *ctx);
static bool session_game_tetris_apply_gravity(session_ctx_t *ctx, unsigned ticks);
static bool session_game_tetris_update_timer(session_ctx_t *ctx, bool accelerate);
static bool session_game_tetris_process_timeout(session_ctx_t *ctx);
static bool session_game_tetris_process_action(session_ctx_t *ctx, int action);
static bool session_game_tetris_process_raw_input(session_ctx_t *ctx, char ch);
static void session_game_tetris_lock_piece(session_ctx_t *ctx);
static void session_game_tetris_clear_lines(session_ctx_t *ctx, unsigned *cleared);
static void session_game_tetris_render(session_ctx_t *ctx);
static void session_game_tetris_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_start_liargame(session_ctx_t *ctx);
static void session_game_liar_present_round(session_ctx_t *ctx);
static void session_game_liar_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_start_alpha(session_ctx_t *ctx);
static void session_game_alpha_reset(session_ctx_t *ctx);
static void session_game_alpha_prepare_navigation(session_ctx_t *ctx);
static void session_game_alpha_reroll_navigation(session_ctx_t *ctx);
static void session_game_alpha_add_gravity_source(alpha_centauri_game_state_t *state, int x, int y, double mu,
                                                  int influence_radius, char symbol, const char *name);
static void session_game_alpha_configure_gravity(session_ctx_t *ctx);
static void session_game_alpha_apply_gravity(alpha_centauri_game_state_t *state);
static const char *const kAlphaStarCatalog[] = {
    "Midway Star",
    "Binary Torch",
    "Turnover Sun",
    "Arrival Flare",
    "Relay Star",
    "Shepherd Star",
};

static const char *const kAlphaPlanetCatalog[] = {
    "Departure World",
    "Drift Planet",
    "Relay Outpost",
    "Approach World",
    "Proxima b",
    "Immigrants' Harbor",
};

static const char *const kAlphaDebrisCatalog[] = {
    "Comet Trail",
    "Asteroid Swarm",
    "Ice Shard",
    "Dust Ribbon",
    "Sail Wreck",
};

#define ALPHA_STAR_CATALOG_COUNT (sizeof(kAlphaStarCatalog) / sizeof(kAlphaStarCatalog[0]))
#define ALPHA_PLANET_CATALOG_COUNT (sizeof(kAlphaPlanetCatalog) / sizeof(kAlphaPlanetCatalog[0]))
#define ALPHA_DEBRIS_CATALOG_COUNT (sizeof(kAlphaDebrisCatalog) / sizeof(kAlphaDebrisCatalog[0]))

static bool session_game_alpha_position_occupied(const alpha_centauri_game_state_t *state, int x, int y) {
  if (state == NULL) {
    return true;
  }
  if (state->nav_x == x && state->nav_y == y) {
    return true;
  }
  if (state->nav_target_x == x && state->nav_target_y == y) {
    return true;
  }
  for (unsigned idx = 0U; idx < state->gravity_source_count; ++idx) {
    const alpha_gravity_source_t *existing = &state->gravity_sources[idx];
    if (existing->x == x && existing->y == y) {
      return true;
    }
  }
  if (state->stage == 4U) {
    if (!state->eva_ready) {
      for (unsigned idx = 0U; idx < state->waypoint_count; ++idx) {
        const alpha_waypoint_t *waypoint = &state->waypoints[idx];
        if (waypoint->x == x && waypoint->y == y) {
          return true;
        }
      }
    }
    if (state->final_waypoint.symbol != '\0' && state->final_waypoint.x == x && state->final_waypoint.y == y) {
      return true;
    }
  }
  return false;
}

static void session_game_alpha_place_random_source(session_ctx_t *ctx, alpha_centauri_game_state_t *state, int margin,
                                                   double mu, int radius, char symbol, const char *name) {
  if (ctx == NULL || state == NULL) {
    return;
  }

  int attempts = 0;
  int min_margin = margin >= 0 ? margin : 0;
  int usable_width = ALPHA_NAV_WIDTH - (min_margin * 2);
  int usable_height = ALPHA_NAV_HEIGHT - (min_margin * 2);
  if (usable_width <= 0) {
    usable_width = ALPHA_NAV_WIDTH;
    min_margin = 0;
  }
  if (usable_height <= 0) {
    usable_height = ALPHA_NAV_HEIGHT;
    min_margin = 0;
  }

  while (attempts < 128) {
    int x = min_margin + session_game_random_range(ctx, usable_width);
    int y = min_margin + session_game_random_range(ctx, usable_height);
    if (!session_game_alpha_position_occupied(state, x, y)) {
      session_game_alpha_add_gravity_source(state, x, y, mu, radius, symbol, name);
      return;
    }
    ++attempts;
  }

  int fallback_x = min_margin < ALPHA_NAV_WIDTH ? min_margin : 0;
  int fallback_y = min_margin < ALPHA_NAV_HEIGHT ? min_margin : 0;
  session_game_alpha_add_gravity_source(state, fallback_x, fallback_y, mu, radius, symbol, name);
}

static double session_game_alpha_random_double(session_ctx_t *ctx, double min_value, double max_value) {
  if (ctx == NULL) {
    return min_value;
  }
  if (max_value <= min_value) {
    return min_value;
  }
  double fraction = (double)session_game_random(ctx) / (double)UINT32_MAX;
  if (fraction < 0.0) {
    fraction = 0.0;
  } else if (fraction > 1.0) {
    fraction = 1.0;
  }
  return min_value + (max_value - min_value) * fraction;
}

static int session_game_alpha_random_with_margin(session_ctx_t *ctx, int extent, int margin) {
  if (extent <= 0) {
    return 0;
  }
  int safe_margin = margin;
  if (safe_margin < 0) {
    safe_margin = 0;
  }
  int usable = extent - (safe_margin * 2);
  if (usable <= 0) {
    usable = extent;
    safe_margin = 0;
  }
  return safe_margin + session_game_random_range(ctx, usable);
}
static void session_game_alpha_sync_from_save(session_ctx_t *ctx);
static void session_game_alpha_sync_to_save(session_ctx_t *ctx);
static void session_game_alpha_present_stage(session_ctx_t *ctx);
static void session_game_alpha_handle_line(session_ctx_t *ctx, const char *line);
static void session_game_alpha_log_completion(session_ctx_t *ctx);
static void session_game_alpha_render_navigation(session_ctx_t *ctx);
static void session_game_alpha_refresh_navigation(session_ctx_t *ctx);
static void session_game_alpha_plan_waypoints(session_ctx_t *ctx);
static void session_game_alpha_present_waypoints(session_ctx_t *ctx);
static void session_game_alpha_complete_waypoint(session_ctx_t *ctx);
static bool session_game_alpha_handle_arrow(session_ctx_t *ctx, int dx, int dy);
static bool session_game_alpha_attempt_completion(session_ctx_t *ctx);
static void session_game_alpha_execute_ignite(session_ctx_t *ctx);
static void session_game_alpha_execute_trim(session_ctx_t *ctx);
static void session_game_alpha_execute_flip(session_ctx_t *ctx);
static void session_game_alpha_execute_retro(session_ctx_t *ctx);
static void session_game_alpha_execute_eva(session_ctx_t *ctx);
static void session_game_alpha_manual_lock(session_ctx_t *ctx);
static void session_game_alpha_manual_save(session_ctx_t *ctx);
static void host_update_last_captcha_prompt(host_t *host, const captcha_prompt_t *prompt,
                                            const captcha_language_t *order, size_t count);

typedef struct liar_prompt {
  const char *statements[3];
  unsigned liar_index;
} liar_prompt_t;

static const liar_prompt_t LIAR_PROMPTS[] = {
    {{"I have contributed code to an open source project.", "I once replaced an entire server rack solo.",
      "I prefer mechanical keyboards with clicky switches."}, 1U},
    {{"I have memorized pi to 200 digits.", "I used to write BASIC games in middle school.",
      "I cannot solve a Rubik's Cube."}, 0U},
    {{"I drink my coffee without sugar.", "I debug using `printf` more than any other tool.",
      "I have never broken a build."}, 2U},
    {{"I run Linux on my primary laptop.", "I have camped overnight for a console launch.",
      "I have attended a demoparty."}, 1U},
    {{"I know how to solder surface-mount components.", "I have written an emulator in C.",
      "I have a pet snake named Segfault."}, 2U},
    {{"I play at least one rhythm game competitively.", "I once deployed to production from my phone.",
      "I have built a keyboard from scratch."}, 1U},
};

static const char *const TETROMINO_SHAPES[7][4] = {
    {
        "...."
        "####"
        "...."
        "....",
        "..#."
        "..#."
        "..#."
        "..#.",
        "...."
        "####"
        "...."
        "....",
        "..#."
        "..#."
        "..#."
        "..#.",
    },
    {
        "#..."
        "###."
        "...."
        "....",
        ".##."
        ".#.."
        ".#.."
        "....",
        "...."
        "###."
        "..#."
        "....",
        ".#.."
        ".#.."
        "##.."
        "....",
    },
    {
        "..#."
        "###."
        "...."
        "....",
        ".#.."
        ".#.."
        ".##."
        "....",
        "...."
        "###."
        "#..."
        "....",
        "##.."
        ".#.."
        ".#.."
        "....",
    },
    {
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
        ".##."
        ".##."
        "...."
        "....",
    },
    {
        ".##."
        "##.."
        "...."
        "....",
        ".#.."
        ".##."
        "..#."
        "....",
        ".##."
        "##.."
        "...."
        "....",
        ".#.."
        ".##."
        "..#."
        "....",
    },
    {
        ".#.."
        "###."
        "...."
        "....",
        ".#.."
        ".##."
        ".#.."
        "....",
        "...."
        "###."
        ".#.."
        "....",
        ".#.."
        "##.."
        ".#.."
        "....",
    },
    {
        "##.."
        ".##."
        "...."
        "....",
        "..#."
        ".##."
        ".#.."
        "....",
        "##.."
        ".##."
        "...."
        "....",
        "..#."
        ".##."
        ".#.."
        "....",
    },
};

static const char TETROMINO_DISPLAY_CHARS[7] = {'I', 'J', 'L', 'O', 'S', 'T', 'Z'};

static const uint32_t HOST_STATE_MAGIC = 0x53484354U; /* 'SHCT' */
static const uint32_t HOST_STATE_VERSION = 9U;
static const uint32_t ELIZA_STATE_MAGIC = 0x454c5354U; /* 'ELST' */
static const uint32_t ELIZA_STATE_VERSION = 1U;

#define HOST_STATE_SOUND_ALIAS_LEN 32U

typedef struct eliza_memory_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint32_t reserved;
  uint64_t next_id;
} eliza_memory_header_t;

typedef struct eliza_memory_entry_serialized {
  uint64_t id;
  int64_t stored_at;
  char prompt[SSH_CHATTER_MESSAGE_LIMIT];
  char reply[SSH_CHATTER_MESSAGE_LIMIT];
} eliza_memory_entry_serialized_t;

typedef struct eliza_state_record {
  uint32_t magic;
  uint32_t version;
  uint8_t enabled;
  uint8_t reserved[7];
} eliza_state_record_t;

typedef struct host_state_header_v1 {
  uint32_t magic;
  uint32_t version;
  uint32_t history_count;
  uint32_t preference_count;
} host_state_header_v1_t;

typedef struct host_state_header {
  host_state_header_v1_t base;
  uint32_t legacy_sound_count;
  uint32_t grant_count;
  uint64_t next_message_id;
  uint8_t captcha_enabled;
  uint8_t reserved[7];
} host_state_header_t;

typedef struct host_state_history_entry_v1 {
  uint8_t is_user_message;
  uint8_t user_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char message[SSH_CHATTER_MESSAGE_LIMIT];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
} host_state_history_entry_v1_t;

typedef struct host_state_history_entry_v2 {
  host_state_history_entry_v1_t base;
  uint64_t message_id;
  uint8_t attachment_type;
  char attachment_target[SSH_CHATTER_ATTACHMENT_TARGET_LEN];
  char attachment_caption[SSH_CHATTER_ATTACHMENT_CAPTION_LEN];
  char sound_alias[HOST_STATE_SOUND_ALIAS_LEN];
  uint32_t reaction_counts[SSH_CHATTER_REACTION_KIND_COUNT];
} host_state_history_entry_v2_t;

typedef struct host_state_history_entry_v3 {
  host_state_history_entry_v1_t base;
  uint64_t message_id;
  uint8_t attachment_type;
  uint8_t reserved[7];
  char attachment_target[SSH_CHATTER_ATTACHMENT_TARGET_LEN];
  char attachment_caption[SSH_CHATTER_ATTACHMENT_CAPTION_LEN];
  uint32_t reaction_counts[SSH_CHATTER_REACTION_KIND_COUNT];
} host_state_history_entry_v3_t;

typedef struct host_state_preference_entry_v3 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
} host_state_preference_entry_v3_t;

typedef struct host_state_preference_entry_v4 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
} host_state_preference_entry_v4_t;

typedef struct host_state_preference_entry_v5 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t reserved[3];
  char birthday[16];
} host_state_preference_entry_v5_t;

typedef struct host_state_preference_entry_v6 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t reserved[3];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_v6_t;

typedef struct host_state_preference_entry_v7 {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t translation_master_explicit;
  uint8_t reserved[2];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_v7_t;

typedef struct host_state_preference_entry {
  uint8_t has_user_theme;
  uint8_t has_system_theme;
  uint8_t user_is_bold;
  uint8_t system_is_bold;
  char username[SSH_CHATTER_USERNAME_LEN];
  char user_color_name[SSH_CHATTER_COLOR_NAME_LEN];
  char user_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_fg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_bg_name[SSH_CHATTER_COLOR_NAME_LEN];
  char system_highlight_name[SSH_CHATTER_COLOR_NAME_LEN];
  char os_name[SSH_CHATTER_OS_NAME_LEN];
  int32_t daily_year;
  int32_t daily_yday;
  char daily_function[64];
  uint64_t last_poll_id;
  int32_t last_poll_choice;
  uint8_t has_birthday;
  uint8_t translation_caption_spacing;
  uint8_t translation_enabled;
  uint8_t output_translation_enabled;
  uint8_t input_translation_enabled;
  uint8_t translation_master_explicit;
  uint8_t reserved[2];
  char birthday[16];
  char output_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char input_translation_language[SSH_CHATTER_LANG_NAME_LEN];
  char ui_language[SSH_CHATTER_LANG_NAME_LEN];
} host_state_preference_entry_t;

static const uint32_t BAN_STATE_MAGIC = 0x5348424eU; /* 'SHBN' */
static const uint32_t BAN_STATE_VERSION = 1U;

typedef struct ban_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
} ban_state_header_t;

typedef struct ban_state_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  char ip[SSH_CHATTER_IP_LEN];
} ban_state_entry_t;

static const uint32_t REPLY_STATE_MAGIC = 0x53485250U; /* 'SHRP' */
static const uint32_t REPLY_STATE_VERSION = 1U;

typedef struct reply_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint64_t next_reply_id;
} reply_state_header_t;

typedef struct reply_state_entry {
  uint64_t reply_id;
  uint64_t parent_message_id;
  uint64_t parent_reply_id;
  int64_t created_at;
  char username[SSH_CHATTER_USERNAME_LEN];
  char message[SSH_CHATTER_MESSAGE_LIMIT];
} reply_state_entry_t;

typedef struct host_state_grant_entry {
  char ip[SSH_CHATTER_IP_LEN];
} host_state_grant_entry_t;

static const uint32_t BBS_STATE_MAGIC = 0x42425331U; /* 'BBS1' */
static const uint32_t BBS_STATE_VERSION = 4U;

#define SSH_CHATTER_BBS_TITLE_LEN_V1 96U
#define SSH_CHATTER_BBS_BODY_LEN_V1 2048U
#define SSH_CHATTER_BBS_BODY_LEN_V2 10240U
#define SSH_CHATTER_BBS_BODY_LEN_V3 20480U

typedef struct bbs_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t post_count;
  uint32_t reserved;
  uint64_t next_id;
} bbs_state_header_t;

typedef struct bbs_state_comment_entry {
  char author[SSH_CHATTER_USERNAME_LEN];
  char text[SSH_CHATTER_BBS_COMMENT_LEN];
  int64_t created_at;
} bbs_state_comment_entry_t;

typedef struct bbs_state_post_entry {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_t;

typedef struct bbs_state_post_entry_v1 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN_V1];
  char body[SSH_CHATTER_BBS_BODY_LEN_V1];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v1_t;

typedef struct bbs_state_post_entry_v2 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN_V2];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v2_t;

typedef struct bbs_state_post_entry_v3 {
  uint64_t id;
  int64_t created_at;
  int64_t bumped_at;
  uint32_t tag_count;
  uint32_t comment_count;
  char author[SSH_CHATTER_USERNAME_LEN];
  char title[SSH_CHATTER_BBS_TITLE_LEN];
  char body[SSH_CHATTER_BBS_BODY_LEN_V3];
  char tags[SSH_CHATTER_BBS_MAX_TAGS][SSH_CHATTER_BBS_TAG_LEN];
  bbs_state_comment_entry_t comments[SSH_CHATTER_BBS_MAX_COMMENTS];
} bbs_state_post_entry_v3_t;

static const uint32_t RSS_STATE_MAGIC = 0x52535331U; /* 'RSS1' */
static const uint32_t RSS_STATE_VERSION = 1U;

typedef struct rss_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t feed_count;
  uint32_t reserved;
} rss_state_header_t;

typedef struct rss_state_entry {
  char tag[SSH_CHATTER_RSS_TAG_LEN];
  char url[SSH_CHATTER_RSS_URL_LEN];
  char last_item_key[SSH_CHATTER_RSS_ITEM_KEY_LEN];
} rss_state_entry_t;

static const uint32_t ALPHA_LANDERS_STATE_MAGIC = 0x464C4147U; /* 'FLAG' */
static const uint32_t ALPHA_LANDERS_STATE_VERSION = 1U;

typedef struct alpha_landers_file_header {
  uint32_t magic;
  uint32_t version;
  uint32_t entry_count;
  uint32_t reserved;
} alpha_landers_file_header_t;

typedef struct alpha_landers_file_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  uint32_t flag_count;
  uint64_t last_flag_timestamp;
  uint32_t reserved;
} alpha_landers_file_entry_t;

static const uint32_t VOTE_STATE_MAGIC = 0x564F5445U; /* 'VOTE' */
static const uint32_t VOTE_STATE_VERSION = 1U;

typedef struct vote_state_header {
  uint32_t magic;
  uint32_t version;
  uint32_t named_count;
  uint32_t reserved;
} vote_state_header_t;

typedef struct vote_state_poll_option_entry {
  char text[SSH_CHATTER_MESSAGE_LIMIT];
  uint32_t votes;
} vote_state_poll_option_entry_t;

typedef struct vote_state_poll_entry {
  uint8_t active;
  uint8_t allow_multiple;
  uint8_t reserved[6];
  uint64_t id;
  uint32_t option_count;
  uint32_t reserved2;
  char question[SSH_CHATTER_MESSAGE_LIMIT];
  vote_state_poll_option_entry_t options[5];
} vote_state_poll_entry_t;

typedef struct vote_state_named_voter_entry {
  char username[SSH_CHATTER_USERNAME_LEN];
  int32_t choice;
  uint32_t choices_mask;
} vote_state_named_voter_entry_t;

typedef struct vote_state_named_entry {
  vote_state_poll_entry_t poll;
  char label[SSH_CHATTER_POLL_LABEL_LEN];
  char owner[SSH_CHATTER_USERNAME_LEN];
  uint32_t voter_count;
  uint32_t reserved;
  vote_state_named_voter_entry_t voters[SSH_CHATTER_MAX_NAMED_VOTERS];
} vote_state_named_entry_t;


typedef struct reaction_descriptor {
  const char *command;
  const char *label;
  const char *icon;
} reaction_descriptor_t;

static const reaction_descriptor_t REACTION_DEFINITIONS[SSH_CHATTER_REACTION_KIND_COUNT] = {
    {"good", "good", "b"},   {"sad", "sad", ":("},   {"cool", "cool", "(ツ)!"},
    {"angry", "angry", ":/"}, {"checked", "checked", "[v]"},
    {"love", "love", "<3"},   {"wtf", "wtf", "凸_(ツ)"},
};

typedef struct os_descriptor {
  const char *name;
  const char *display;
} os_descriptor_t;

static const os_descriptor_t OS_CATALOG[] = {
    {"windows", "Windows"},      {"macos", "macOS"},      {"linux", "Linux"},
    {"freebsd", "FreeBSD"},      {"ios", "iOS"},          {"android", "Android"},
    {"watchos", "watchOS"},      {"solaris", "Solaris"},  {"openbsd", "OpenBSD"},
    {"netbsd", "NetBSD"},        {"dragonflybsd", "DragonFlyBSD"},
    {"reactos", "ReactOS"},      {"tizen", "Tizen"}, {"bsd", "BSD"},
    {"msdos", "MS-DOS"}, {"drdos", "DR-DOS"}, {"kdos", "K-DOS"},
    {"templeos", "TempleOS"}, {"zealos", "ZealOS"},
    {"haiku", "Haiku"}, {"pcdos", "PC-DOS"}
};

static const os_descriptor_t *session_lookup_os_descriptor(const char *name);

// random pool for daily functions
static const char *DAILY_FUNCTIONS[] = {"sin",   "cos",   "tan",   "sqrt",  "log",   "exp",     "printf",
                                        "malloc", "free",  "memcpy", "strncpy", "qsort", "fopen",   "close",
                                        "select", "poll",  "fork",  "exec",  "pthread_create", "strtok"};

static bool chat_room_ensure_capacity(chat_room_t *room, size_t required) { // chat members should be within capacity
  if (room == NULL) {
    return false;
  }

  if (required <= room->member_capacity) {
    return true;
  }

  size_t new_capacity = room->member_capacity == 0U ? 8U : room->member_capacity;
  while (new_capacity < required) {
    if (new_capacity > SIZE_MAX / 2U) {
      new_capacity = required;
      break;
    }
    new_capacity *= 2U;
  }

  session_ctx_t **resized = realloc(room->members, new_capacity * sizeof(*resized));
  if (resized == NULL) {
    return false;
  }

  for (size_t idx = room->member_capacity; idx < new_capacity; ++idx) {
    resized[idx] = NULL;
  }

  room->members = resized;
  room->member_capacity = new_capacity;
  return true;
}

static void chat_room_init(chat_room_t *room) {
  if (room == NULL) {
    return;
  }
  pthread_mutex_init(&room->lock, NULL);
  room->members = NULL;
  room->member_count = 0U;
  room->member_capacity = 0U;
}

static void session_describe_peer(ssh_session session, char *buffer, size_t len) {
  if (buffer == NULL || len == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (session == NULL) {
    return;
  }

  const int socket_fd = ssh_get_fd(session);
  if (socket_fd < 0) {
    return;
  }

  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);
  if (getpeername(socket_fd, (struct sockaddr *)&addr, &addr_len) != 0) {
    return;
  }

  char host[NI_MAXHOST];
  if (getnameinfo((struct sockaddr *)&addr, addr_len, host, sizeof(host), NULL, 0,
                  NI_NUMERICHOST) != 0) {
    return;
  }

  snprintf(buffer, len, "%s", host);
}

static void host_format_sockaddr(const struct sockaddr *addr, socklen_t len, char *buffer, size_t size) {
  if (buffer == NULL || size == 0U) {
    return;
  }

  buffer[0] = '\0';
  if (addr == NULL) {
    return;
  }

  socklen_t host_len = (socklen_t)(size > (size_t)UINT_MAX ? UINT_MAX : size);
  if (host_len == 0) {
    return;
  }

  if (getnameinfo(addr, len, buffer, host_len, NULL, 0, NI_NUMERICHOST) != 0) {
    buffer[0] = '\0';
  }
}

typedef enum {
  HOSTKEY_SUPPORT_UNKNOWN = 0,
  HOSTKEY_SUPPORT_ACCEPTED,
  HOSTKEY_SUPPORT_REJECTED, // unlisted auth key should be rejected.
} hostkey_support_status_t;

typedef struct {
  hostkey_support_status_t status;
  char offered_algorithms[256];
} hostkey_probe_result_t;

static bool hostkey_list_contains(const unsigned char *data, size_t data_len, const char *needle,
                                 size_t needle_len) {
  if (data == NULL || needle == NULL || needle_len == 0U) {
    return false;
  }

  size_t position = 0U;
  while (position < data_len) {
    size_t token_end = position;
    while (token_end < data_len && data[token_end] != ',') {
      ++token_end;
    }

    const size_t token_length = token_end - position;
    if (token_length == needle_len && memcmp(data + position, needle, needle_len) == 0) {
      return true;
    }

    if (token_end >= data_len) {
      break;
    }

    position = token_end + 1U;
  }

  return false;
}

static hostkey_probe_result_t session_probe_client_hostkey_algorithms(
    ssh_session session, const char *const *required_algorithms, size_t required_algorithm_count) {
  hostkey_probe_result_t result;
  result.status = HOSTKEY_SUPPORT_UNKNOWN;
  result.offered_algorithms[0] = '\0';

  if (session == NULL || required_algorithms == NULL || required_algorithm_count == 0U) {
    return result;
  }

  for (size_t i = 0; i < required_algorithm_count; ++i) {
    if (required_algorithms[i] == NULL || required_algorithms[i][0] == '\0') {
      return result;
    }
  }

  const int socket_fd = ssh_get_fd(session);
  if (socket_fd < 0) {
    return result;
  }

  const size_t max_buffer_size = 65536U;
  size_t buffer_size = 16384U;
  unsigned char *buffer = (unsigned char *)GC_MALLOC(buffer_size);
  if (buffer == NULL) {
    return result;
  }

  unsigned int attempts = 0U;
  const unsigned int max_attempts = 5U;

  while (attempts < max_attempts) {
    struct pollfd poll_fd;
    poll_fd.fd = socket_fd;
    poll_fd.events = POLLIN;
    poll_fd.revents = 0;

    int poll_result = poll(&poll_fd, 1, 1000);
    if (poll_result < 0) {
      if (errno == EINTR) {
        continue;
      }
      break;
    }

    if (poll_result == 0) {
      ++attempts;
      continue;
    }

    if ((poll_fd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
      break;
    }

    ssize_t peeked = recv(socket_fd, buffer, buffer_size, MSG_PEEK | MSG_DONTWAIT);
    if (peeked < 0) {
      if (errno == EINTR) {
        continue;
      }
      if (errno == EAGAIN
#ifdef EWOULDBLOCK
          || errno == EWOULDBLOCK
#endif
      ) {
        ++attempts;
        continue;
      }
      break;
    }

    if (peeked == 0) {
      break;
    }

    size_t available = (size_t)peeked;
    unsigned char *newline = memchr(buffer, '\n', available);
    if (newline == NULL) {
      if (available == buffer_size && buffer_size < max_buffer_size) {
        size_t new_size = buffer_size * 2U;
        if (new_size > max_buffer_size) {
          new_size = max_buffer_size;
        }
        unsigned char *resized = realloc(buffer, new_size);
        if (resized != NULL) {
          buffer = resized;
          buffer_size = new_size;
          continue;
        }
      }
      ++attempts;
      continue;
    }

    size_t payload_offset = (size_t)(newline - buffer) + 1U;
    while (payload_offset < available && (buffer[payload_offset] == '\r' || buffer[payload_offset] == '\n')) {
      ++payload_offset;
    }

    if (available <= payload_offset || available - payload_offset < 5U) {
      ++attempts;
      continue;
    }

    const unsigned char *packet = buffer + payload_offset;
    uint32_t packet_length = ((uint32_t)packet[0] << 24) | ((uint32_t)packet[1] << 16) |
                             ((uint32_t)packet[2] << 8) | (uint32_t)packet[3];
    if (packet_length == 0U) {
      break;
    }

    size_t total_packet_size = 4U + (size_t)packet_length;
    if (total_packet_size > available - payload_offset) {
      if (payload_offset + total_packet_size > buffer_size && buffer_size < max_buffer_size) {
        size_t new_size = buffer_size;
        while (new_size < payload_offset + total_packet_size && new_size < max_buffer_size) {
          new_size *= 2U;
          if (new_size > max_buffer_size) {
            new_size = max_buffer_size;
          }
        }
        if (new_size > buffer_size) {
          unsigned char *resized = realloc(buffer, new_size);
          if (resized != NULL) {
            buffer = resized;
            buffer_size = new_size;
            continue;
          }
        }
      }
      ++attempts;
      continue;
    }

    unsigned int padding_length = packet[4];
    if ((size_t)padding_length + 1U > packet_length) {
      break;
    }

    size_t payload_length = (size_t)packet_length - (size_t)padding_length - 1U;
    if (payload_length < 17U) {
      break;
    }

    const unsigned char *payload = packet + 5;
    if (payload[0] != 20U) {
      break;
    }

    const unsigned char *cursor = payload + 17U;
    size_t remaining = payload_length - 17U;
    if (remaining < 4U) {
      break;
    }

    uint32_t kex_names_len = ((uint32_t)cursor[0] << 24) | ((uint32_t)cursor[1] << 16) |
                             ((uint32_t)cursor[2] << 8) | (uint32_t)cursor[3];
    cursor += 4U;
    if ((size_t)kex_names_len > remaining - 4U) {
      break;
    }

    cursor += (size_t)kex_names_len;
    remaining -= 4U + (size_t)kex_names_len;
    if (remaining < 4U) {
      break;
    }

    uint32_t hostkey_names_len = ((uint32_t)cursor[0] << 24) | ((uint32_t)cursor[1] << 16) |
                                 ((uint32_t)cursor[2] << 8) | (uint32_t)cursor[3];
    cursor += 4U;
    if ((size_t)hostkey_names_len > remaining - 4U) {
      break;
    }

    size_t hostkey_len = (size_t)hostkey_names_len;
    const unsigned char *hostkey_data = cursor;

    size_t copy_length = hostkey_len;
    if (copy_length >= sizeof(result.offered_algorithms)) {
      copy_length = sizeof(result.offered_algorithms) - 1U;
    }
    memcpy(result.offered_algorithms, hostkey_data, copy_length);
    result.offered_algorithms[copy_length] = '\0';

    if (hostkey_len == 0U) {
      result.status = HOSTKEY_SUPPORT_REJECTED;
    } else {
      bool supported = false;
      for (size_t i = 0; i < required_algorithm_count; ++i) {
        const char *algorithm = required_algorithms[i];
        const size_t required_length = strlen(algorithm);
        if (required_length == 0U) {
          continue;
        }

        if (hostkey_list_contains(hostkey_data, hostkey_len, algorithm, required_length)) {
          supported = true;
          break;
        }
      }

      if (supported) {
        result.status = HOSTKEY_SUPPORT_ACCEPTED;
      } else {
        result.status = HOSTKEY_SUPPORT_REJECTED;
      }
    }

    return result;
  }

  return result;
}

static bool session_is_private_ipv4(const unsigned char octets[4]) {
  if (octets == NULL) {
    return false;
  }

  if (octets[0] == 10U || octets[0] == 127U) {
    return true;
  }

  if (octets[0] == 172U && octets[1] >= 16U && octets[1] <= 31U) {
    return true;
  }

  if ((octets[0] == 192U && octets[1] == 168U) || (octets[0] == 169U && octets[1] == 254U)) {
    return true;
  }

  return false;
}

static bool session_is_lan_client(const char *ip) {
  if (ip == NULL || ip[0] == '\0') {
    return false;
  }

  struct in_addr addr4;
  if (inet_pton(AF_INET, ip, &addr4) == 1) {
    unsigned char octets[4];
    memcpy(octets, &addr4.s_addr, sizeof(octets));
    return session_is_private_ipv4(octets);
  }

  struct in6_addr addr6;
  if (inet_pton(AF_INET6, ip, &addr6) != 1) {
    return false;
  }

  if (IN6_IS_ADDR_LOOPBACK(&addr6) || IN6_IS_ADDR_LINKLOCAL(&addr6)) {
    return true;
  }

  if (IN6_IS_ADDR_V4MAPPED(&addr6)) {
    return session_is_private_ipv4(&addr6.s6_addr[12]);
  }

  const unsigned char first_byte = addr6.s6_addr[0];
  if ((first_byte & 0xfeU) == 0xfcU) { // fc00::/7 unique local
    return true;
  }

  return false;
}

static void session_assign_lan_privileges(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (!ctx->lan_operator_credentials_valid) {
    ctx->user.is_lan_operator = false;
    return;
  }

  if (!session_is_lan_client(ctx->client_ip)) {
    ctx->lan_operator_credentials_valid = false;
    ctx->user.is_lan_operator = false;
    return;
  }

  if (!host_is_lan_operator_username(ctx->owner, ctx->user.name)) {
    ctx->lan_operator_credentials_valid = false;
    ctx->user.is_lan_operator = false;
    return;
  }

  ctx->user.is_operator = true;
  ctx->auth.is_operator = true;
  ctx->user.is_lan_operator = true;
}

static void session_apply_granted_privileges(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  if (host_ip_has_grant(ctx->owner, ctx->client_ip)) {
    ctx->user.is_operator = true;
    ctx->auth.is_operator = true;
  }
}

static void chat_room_add(chat_room_t *room, session_ctx_t *session) {
  if (room == NULL || session == NULL) {
    return;
  }

  pthread_mutex_lock(&room->lock);
  if (chat_room_ensure_capacity(room, room->member_count + 1U)) {
    room->members[room->member_count++] = session;
  } else {
    humanized_log_error("chat-room", "failed to grow member list", ENOMEM);
  }
  pthread_mutex_unlock(&room->lock);
}

static void chat_room_remove(chat_room_t *room, const session_ctx_t *session) {
  if (room == NULL || session == NULL) {
    return;
  }

  pthread_mutex_lock(&room->lock);
  for (size_t idx = 0; idx < room->member_count; ++idx) {
    if (room->members[idx] == session) {
      for (size_t shift = idx; shift + 1U < room->member_count; ++shift) {
        room->members[shift] = room->members[shift + 1U];
      }
      room->members[room->member_count - 1U] = NULL;
      room->member_count--;
      break;
    }
  }
  pthread_mutex_unlock(&room->lock);
}

static void chat_room_broadcast(chat_room_t *room, const char *message, const session_ctx_t *from) {
  if (room == NULL || message == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  chat_history_entry_t entry = {0};
  if (from != NULL) {
    chat_history_entry_prepare_user(&entry, from, message);
  }

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        if (from != NULL && member == from) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    if (from != NULL) {
      session_send_history_entry(member, &entry);
    } else {
      session_send_system_line(member, message);
    }

    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  if (from != NULL) {
    printf("[broadcast:%s] %s\n", from->user.name, message);
  } else {
    printf("[broadcast] %s\n", message);
  }

}

static void chat_room_broadcast_caption(chat_room_t *room, const char *message) {
  if (room == NULL || message == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    session_send_caption_line(member, message);
    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  printf("[broadcast caption] %s\n", message);

}

static void chat_room_broadcast_entry(chat_room_t *room, const chat_history_entry_t *entry, const session_ctx_t *from) {
  if (room == NULL || entry == NULL) {
    return;
  }

  session_ctx_t **targets = NULL;
  size_t target_count = 0U;
  size_t expected_targets = 0U;

  pthread_mutex_lock(&room->lock);
  expected_targets = room->member_count;
  if (expected_targets > 0U) {
    targets = GC_CALLOC(expected_targets, sizeof(*targets));
    if (targets != NULL) {
      for (size_t idx = 0; idx < room->member_count; ++idx) {
        session_ctx_t *member = room->members[idx];
        if (member == NULL || member->channel == NULL) {
          continue;
        }
        if (from != NULL && member == from) {
          continue;
        }
        targets[target_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&room->lock);

  if (targets == NULL && expected_targets > 0U) {
    humanized_log_error("chat-room", "failed to allocate entry broadcast buffer", ENOMEM);
    return;
  }

  for (size_t idx = 0; idx < target_count; ++idx) {
    session_ctx_t *member = targets[idx];
    session_send_history_entry(member, entry);
    if (member->history_scroll_position == 0U) {
      session_refresh_input_line(member);
    }
  }

  if (entry->is_user_message) {
    const char *message_text = entry->message;
    char fallback[SSH_CHATTER_MESSAGE_LIMIT + 64];
    if ((message_text == NULL || message_text[0] == '\0') && entry->attachment_type != CHAT_ATTACHMENT_NONE) {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      snprintf(fallback, sizeof(fallback), "shared a %s", label);
      message_text = fallback;
    } else if (message_text == NULL) {
      message_text = "";
    }

    printf("[broadcast:%s#%" PRIu64 "] %s\n", entry->username, entry->message_id, message_text);
    if (entry->attachment_type != CHAT_ATTACHMENT_NONE && entry->attachment_target[0] != '\0') {
      const char *label = chat_attachment_type_label(entry->attachment_type);
      printf("           %s: %s\n", label, entry->attachment_target);
    }
  }

}

static void chat_room_broadcast_reaction_update(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  char summary[SSH_CHATTER_MESSAGE_LIMIT];
  if (!chat_history_entry_build_reaction_summary(entry, summary, sizeof(summary))) {
    return;
  }

  char line[SSH_CHATTER_MESSAGE_LIMIT + 64];
  if (entry->message_id > 0U) {
    snprintf(line, sizeof(line), "    ↳ [#%" PRIu64 "] reactions: %s", entry->message_id, summary);
  } else {
    snprintf(line, sizeof(line), "    ↳ reactions: %s", summary);
  }

  chat_room_broadcast_caption(&host->room, line);
}

static void host_broadcast_reply(host_t *host, const chat_reply_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  const char *target_prefix = (entry->parent_reply_id == 0U) ? "#" : "r#";
  uint64_t target_id = (entry->parent_reply_id == 0U) ? entry->parent_message_id : entry->parent_reply_id;

  char line[SSH_CHATTER_MESSAGE_LIMIT + 160];
  snprintf(line, sizeof(line), "↳ [r#%" PRIu64 " → %s%" PRIu64 "] %s: %s", entry->reply_id, target_prefix, target_id,
           entry->username, entry->message);

  chat_room_broadcast(&host->room, line, NULL);
}

static bool host_history_reserve_locked(host_t *host, size_t min_capacity) {
  if (host == NULL) {
    return false;
  }

  if (min_capacity <= host->history_capacity) {
    return true;
  }

  if (min_capacity > SIZE_MAX / sizeof(chat_history_entry_t)) {
    humanized_log_error("host-history", "history buffer too large to allocate", ENOMEM);
    return false;
  }

  size_t new_capacity = host->history_capacity > 0U ? host->history_capacity : 64U;
  if (new_capacity == 0U) {
    new_capacity = 64U;
  }

  while (new_capacity < min_capacity) {
    if (new_capacity > SIZE_MAX / 2U) {
      new_capacity = min_capacity;
      break;
    }
    size_t doubled = new_capacity * 2U;
    if (doubled < new_capacity || doubled > SIZE_MAX / sizeof(chat_history_entry_t)) {
      new_capacity = min_capacity;
      break;
    }
    new_capacity = doubled;
  }

  size_t bytes = new_capacity * sizeof(chat_history_entry_t);
  chat_history_entry_t *resized = realloc(host->history, bytes);
  if (resized == NULL) {
    humanized_log_error("host-history", "failed to grow chat history buffer", errno != 0 ? errno : ENOMEM);
    return false;
  }

  if (new_capacity > host->history_capacity) {
    size_t old_capacity = host->history_capacity;
    size_t added = new_capacity - old_capacity;
    memset(resized + old_capacity, 0, added * sizeof(chat_history_entry_t));
  }

  host->history = resized;
  host->history_capacity = new_capacity;
  return true;
}

static bool host_history_append_locked(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  if (!host_history_reserve_locked(host, host->history_count + 1U)) {
    return false;
  }

  host->history[host->history_count++] = *entry;
  host_state_save_locked(host);
  return true;
}

static size_t host_history_total(host_t *host) {
  if (host == NULL) {
    return 0U;
  }

  size_t count = 0U;
  pthread_mutex_lock(&host->lock);
  count = host->history_count;
  pthread_mutex_unlock(&host->lock);
  return count;
}

static size_t host_history_copy_range(host_t *host, size_t start_index, chat_history_entry_t *buffer, size_t capacity) {
  if (host == NULL || buffer == NULL || capacity == 0U) {
    return 0U;
  }

  size_t copied = 0U;
  pthread_mutex_lock(&host->lock);
  size_t total = host->history_count;
  if (start_index >= total || host->history == NULL) {
    pthread_mutex_unlock(&host->lock);
    return 0U;
  }

  size_t available = total - start_index;
  if (available > capacity) {
    available = capacity;
  }

  memcpy(buffer, host->history + start_index, available * sizeof(chat_history_entry_t));
  copied = available;
  pthread_mutex_unlock(&host->lock);
  return copied;
}

static bool host_history_find_entry_by_id(host_t *host, uint64_t message_id, chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL || message_id == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  if (host->history != NULL) {
    for (size_t idx = 0U; idx < host->history_count; ++idx) {
      const chat_history_entry_t *candidate = &host->history[idx];
      if (candidate->message_id != message_id) {
        continue;
      }

      *entry = *candidate;
      found = true;
      break;
    }
  }
  pthread_mutex_unlock(&host->lock);

  return found;
}

static size_t host_history_delete_range(host_t *host, uint64_t start_id, uint64_t end_id, uint64_t *first_removed,
                                        uint64_t *last_removed, size_t *replies_removed) {
  if (first_removed != NULL) {
    *first_removed = 0U;
  }
  if (last_removed != NULL) {
    *last_removed = 0U;
  }
  if (replies_removed != NULL) {
    *replies_removed = 0U;
  }

  if (host == NULL || start_id == 0U || end_id == 0U || start_id > end_id) {
    return 0U;
  }

  size_t removed = 0U;
  size_t reply_removed = 0U;
  uint64_t local_first = 0U;
  uint64_t local_last = 0U;

  pthread_mutex_lock(&host->lock);
  if (host->history != NULL && host->history_count > 0U) {
    size_t write_index = 0U;
    for (size_t idx = 0U; idx < host->history_count; ++idx) {
      chat_history_entry_t *entry = &host->history[idx];
      const bool drop = entry->is_user_message && entry->message_id >= start_id && entry->message_id <= end_id;
      if (drop) {
        if (local_first == 0U || entry->message_id < local_first) {
          local_first = entry->message_id;
        }
        if (entry->message_id > local_last) {
          local_last = entry->message_id;
        }
        ++removed;
        continue;
      }

      if (write_index != idx) {
        host->history[write_index] = *entry;
      }
      ++write_index;
    }

    if (removed > 0U) {
      for (size_t idx = write_index; idx < host->history_count; ++idx) {
        memset(&host->history[idx], 0, sizeof(host->history[idx]));
      }
      host->history_count = write_index;
      host_state_save_locked(host);
    }
  }

  if (removed > 0U && host->reply_count > 0U) {
    size_t write_index = 0U;
    for (size_t idx = 0U; idx < host->reply_count; ++idx) {
      chat_reply_entry_t *entry = &host->replies[idx];
      if (!entry->in_use) {
        continue;
      }

      const bool drop = entry->parent_message_id >= start_id && entry->parent_message_id <= end_id;
      if (drop) {
        ++reply_removed;
        continue;
      }

      if (write_index != idx) {
        host->replies[write_index] = *entry;
      }
      ++write_index;
    }

    if (reply_removed > 0U) {
      for (size_t idx = write_index; idx < host->reply_count; ++idx) {
        memset(&host->replies[idx], 0, sizeof(host->replies[idx]));
      }
      host->reply_count = write_index;

      uint64_t max_reply_id = 0U;
      for (size_t idx = 0U; idx < host->reply_count; ++idx) {
        const chat_reply_entry_t *entry = &host->replies[idx];
        if (!entry->in_use) {
          continue;
        }
        if (entry->reply_id > max_reply_id) {
          max_reply_id = entry->reply_id;
        }
      }

      if (max_reply_id == 0U) {
        host->next_reply_id = host->reply_count == 0U ? 1U : host->next_reply_id;
      } else if (host->next_reply_id <= max_reply_id) {
        host->next_reply_id = (max_reply_id == UINT64_MAX) ? UINT64_MAX : max_reply_id + 1U;
      }

      host_reply_state_save_locked(host);
    }
  }
  pthread_mutex_unlock(&host->lock);

  if (removed > 0U) {
    if (first_removed != NULL) {
      *first_removed = local_first;
    }
    if (last_removed != NULL) {
      *last_removed = local_last;
    }
  }
  if (replies_removed != NULL) {
    *replies_removed = reply_removed;
  }

  return removed;
}

static bool host_replies_find_entry_by_id(host_t *host, uint64_t reply_id, chat_reply_entry_t *entry) {
  if (host == NULL || entry == NULL || reply_id == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  for (size_t idx = 0U; idx < host->reply_count; ++idx) {
    const chat_reply_entry_t *candidate = &host->replies[idx];
    if (!candidate->in_use) {
      continue;
    }
    if (candidate->reply_id != reply_id) {
      continue;
    }

    *entry = *candidate;
    found = true;
    break;
  }
  pthread_mutex_unlock(&host->lock);

  return found;
}

static void chat_history_entry_prepare_user(chat_history_entry_t *entry, const session_ctx_t *from, const char *message) {
  if (entry == NULL || from == NULL) {
    return;
  }

  memset(entry, 0, sizeof(*entry));
  entry->is_user_message = true;
  if (message != NULL) {
    snprintf(entry->message, sizeof(entry->message), "%s", message);
  }
  snprintf(entry->username, sizeof(entry->username), "%s", from->user.name);
  entry->user_color_code = from->user_color_code;
  entry->user_highlight_code = from->user_highlight_code;
  entry->user_is_bold = from->user_is_bold;
  snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", from->user_color_name);
  snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s", from->user_highlight_name);
  entry->attachment_type = CHAT_ATTACHMENT_NONE;
  entry->message_id = 0U;
}

static bool host_history_commit_entry(host_t *host, chat_history_entry_t *entry, chat_history_entry_t *stored_entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  host_history_normalize_entry(host, entry);

  pthread_mutex_lock(&host->lock);
  if (entry->is_user_message) {
    if (host->next_message_id == 0U) {
      host->next_message_id = 1U;
    }
    entry->message_id = host->next_message_id++;
  } else {
    entry->message_id = 0U;
  }

  if (!host_history_append_locked(host, entry)) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }

  if (stored_entry != NULL) {
    *stored_entry = *entry;
  }

  pthread_mutex_unlock(&host->lock);
  return true;
}

static bool host_replies_commit_entry(host_t *host, chat_reply_entry_t *entry, chat_reply_entry_t *stored_entry) {
  if (host == NULL || entry == NULL) {
    return false;
  }

  bool committed = false;

  pthread_mutex_lock(&host->lock);
  if (host->reply_count >= SSH_CHATTER_MAX_REPLIES) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }

  uint64_t assigned_id = host->next_reply_id;
  if (assigned_id == 0U || assigned_id == UINT64_MAX) {
    assigned_id = (uint64_t)host->reply_count + 1U;
  }

  entry->reply_id = assigned_id;
  if (assigned_id < UINT64_MAX) {
    host->next_reply_id = assigned_id + 1U;
  } else {
    host->next_reply_id = assigned_id;
  }

  entry->in_use = true;

  size_t slot = host->reply_count;
  host->replies[slot] = *entry;
  host->reply_count = slot + 1U;

  host_reply_state_save_locked(host);

  if (stored_entry != NULL) {
    *stored_entry = host->replies[slot];
  }

  committed = true;

  pthread_mutex_unlock(&host->lock);
  return committed;
}

static void host_notify_external_clients(host_t *host, const chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }
  if (host->clients == NULL) {
    return;
  }
  client_manager_notify_history(host->clients, entry);
}

static bool host_history_record_user(host_t *host, const session_ctx_t *from, const char *message,
                                     chat_history_entry_t *stored_entry) {
  if (host == NULL || from == NULL || message == NULL || message[0] == '\0') {
    return false;
  }

  chat_history_entry_t entry;
  chat_history_entry_prepare_user(&entry, from, message);
  return host_history_commit_entry(host, &entry, stored_entry);
}

static void host_history_record_system(host_t *host, const char *message) {
  if (host == NULL || message == NULL || message[0] == '\0') {
    return;
  }

  chat_history_entry_t entry = {0};
  entry.is_user_message = false;
  snprintf(entry.message, sizeof(entry.message), "%s", message);
  entry.user_color_name[0] = '\0';
  entry.user_highlight_name[0] = '\0';
  entry.attachment_type = CHAT_ATTACHMENT_NONE;
  entry.message_id = 0U;

  if (!host_history_commit_entry(host, &entry, NULL)) {
    return;
  }
  host_notify_external_clients(host, &entry);
}

static bool host_history_apply_reaction(host_t *host, uint64_t message_id, size_t reaction_index,
                                        chat_history_entry_t *updated_entry) {
  if (host == NULL || message_id == 0U || reaction_index >= SSH_CHATTER_REACTION_KIND_COUNT) {
    return false;
  }

  bool applied = false;

  pthread_mutex_lock(&host->lock);
  if (host->history == NULL) {
    pthread_mutex_unlock(&host->lock);
    return false;
  }
  for (size_t idx = 0U; idx < host->history_count; ++idx) {
    chat_history_entry_t *entry = &host->history[idx];
    if (!entry->is_user_message) {
      continue;
    }
    if (entry->message_id != message_id) {
      continue;
    }

    if (entry->reaction_counts[reaction_index] < UINT32_MAX) {
      entry->reaction_counts[reaction_index] += 1U;
    }

    if (updated_entry != NULL) {
      *updated_entry = *entry;
    }

    host_state_save_locked(host);
    applied = true;
    break;
  }
  pthread_mutex_unlock(&host->lock);

  return applied;
}

static void session_apply_theme_defaults(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;

  ctx->user_color_code = host->user_theme.userColor;
  ctx->user_highlight_code = host->user_theme.highlight;
  ctx->user_is_bold = host->user_theme.isBold;
  snprintf(ctx->user_color_name, sizeof(ctx->user_color_name), "%s", host->default_user_color_name);
  snprintf(ctx->user_highlight_name, sizeof(ctx->user_highlight_name), "%s", host->default_user_highlight_name);

  session_apply_system_theme_defaults(ctx);
}

static void session_apply_system_theme_defaults(session_ctx_t *ctx) {
  if (ctx == NULL || ctx->owner == NULL) {
    return;
  }

  host_t *host = ctx->owner;

  ctx->system_fg_code = host->system_theme.foregroundColor;
  ctx->system_bg_code = host->system_theme.backgroundColor;
  ctx->system_highlight_code = host->system_theme.highlightColor;
  ctx->system_is_bold = host->system_theme.isBold;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", host->default_system_fg_name);
  snprintf(ctx->system_bg_name, sizeof(ctx->system_bg_name), "%s", host->default_system_bg_name);
  snprintf(ctx->system_highlight_name, sizeof(ctx->system_highlight_name), "%s", host->default_system_highlight_name);
  session_force_dark_mode_foreground(ctx);
}

static void session_force_dark_mode_foreground(session_ctx_t *ctx) {
  if (ctx == NULL) {
    return;
  }

  const bool has_name = ctx->system_fg_name[0] != '\0';
  const bool name_is_default = has_name && strcasecmp(ctx->system_fg_name, "default") == 0;
  const bool missing_name = !has_name;
  const bool code_is_default = ctx->system_fg_code == NULL || strcmp(ctx->system_fg_code, ANSI_DEFAULT) == 0;

  if (!missing_name && !name_is_default && !code_is_default) {
    return;
  }

  ctx->system_fg_code = ANSI_WHITE;
  snprintf(ctx->system_fg_name, sizeof(ctx->system_fg_name), "%s", "white");
}

static user_preference_t *host_find_preference_locked(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return NULL;
  }

  for (size_t idx = 0; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    user_preference_t *pref = &host->preferences[idx];
    if (!pref->in_use) {
      continue;
    }

    if (strncmp(pref->username, username, SSH_CHATTER_USERNAME_LEN) == 0) {
      return pref;
    }
  }

  return NULL;
}

static user_preference_t *host_ensure_preference_locked(host_t *host, const char *username) {
  if (host == NULL || username == NULL || username[0] == '\0') {
    return NULL;
  }

  user_preference_t *existing = host_find_preference_locked(host, username);
  if (existing != NULL) {
    return existing;
  }

  for (size_t idx = 0; idx < SSH_CHATTER_MAX_PREFERENCES; ++idx) {
    user_preference_t *pref = &host->preferences[idx];
    if (pref->in_use) {
      continue;
    }

    memset(pref, 0, sizeof(*pref));
    pref->in_use = true;
    pref->last_poll_choice = -1;
    snprintf(pref->username, sizeof(pref->username), "%s", username);
    if (host->preference_count < SSH_CHATTER_MAX_PREFERENCES) {
      ++host->preference_count;
    }
    return pref;
  }

  return NULL;
}

static void host_store_user_theme(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_user_theme = true;
    snprintf(pref->user_color_name, sizeof(pref->user_color_name), "%s", ctx->user_color_name);
    snprintf(pref->user_highlight_name, sizeof(pref->user_highlight_name), "%s", ctx->user_highlight_name);
    pref->user_is_bold = ctx->user_is_bold;
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_system_theme(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_system_theme = true;
    snprintf(pref->system_fg_name, sizeof(pref->system_fg_name), "%s", ctx->system_fg_name);
    snprintf(pref->system_bg_name, sizeof(pref->system_bg_name), "%s", ctx->system_bg_name);
    snprintf(pref->system_highlight_name, sizeof(pref->system_highlight_name), "%s", ctx->system_highlight_name);
    pref->system_is_bold = ctx->system_is_bold;
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_user_os(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    snprintf(pref->os_name, sizeof(pref->os_name), "%s", ctx->os_name);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_birthday(host_t *host, const session_ctx_t *ctx, const char *birthday) {
  if (host == NULL || ctx == NULL || birthday == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->has_birthday = true;
    snprintf(pref->birthday, sizeof(pref->birthday), "%s", birthday);
  }
  host_state_save_locked(host);
  host_refresh_motd_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_chat_spacing(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    if (ctx->translation_caption_spacing > UINT8_MAX) {
      pref->translation_caption_spacing = UINT8_MAX;
    } else {
      pref->translation_caption_spacing = (uint8_t)ctx->translation_caption_spacing;
    }
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_translation_preferences(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    pref->translation_master_enabled = ctx->translation_enabled;
    pref->translation_master_explicit = true;
    pref->output_translation_enabled = ctx->output_translation_enabled;
    pref->input_translation_enabled = ctx->input_translation_enabled;
    snprintf(pref->output_translation_language, sizeof(pref->output_translation_language), "%s",
             ctx->output_translation_language);
    snprintf(pref->input_translation_language, sizeof(pref->input_translation_language), "%s",
             ctx->input_translation_language);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static void host_store_ui_language(host_t *host, const session_ctx_t *ctx) {
  if (host == NULL || ctx == NULL) {
    return;
  }

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_ensure_preference_locked(host, ctx->user.name);
  if (pref != NULL) {
    const char *code = session_ui_language_code(ctx->ui_language);
    snprintf(pref->ui_language, sizeof(pref->ui_language), "%s", code);
  }
  host_state_save_locked(host);
  pthread_mutex_unlock(&host->lock);
}

static bool host_ip_has_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < host->operator_grant_count; ++idx) {
    if (strncmp(host->operator_grants[idx].ip, ip, SSH_CHATTER_IP_LEN) == 0) {
      return true;
    }
  }

  return false;
}

static bool host_add_operator_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  if (host_ip_has_grant_locked(host, ip)) {
    return true;
  }

  if (host->operator_grant_count >= SSH_CHATTER_MAX_GRANTS) {
    return false;
  }

  snprintf(host->operator_grants[host->operator_grant_count].ip,
           sizeof(host->operator_grants[host->operator_grant_count].ip), "%s", ip);
  ++host->operator_grant_count;
  return true;
}

static bool host_ip_has_grant(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  bool result = false;
  pthread_mutex_lock(&host->lock);
  result = host_ip_has_grant_locked(host, ip);
  pthread_mutex_unlock(&host->lock);
  return result;
}

static void host_apply_grant_to_ip(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return;
  }

  session_ctx_t **matches = NULL;
  size_t match_count = 0U;

  pthread_mutex_lock(&host->room.lock);
  if (host->room.member_count > 0U) {
    matches = GC_CALLOC(host->room.member_count, sizeof(*matches));
    if (matches != NULL) {
      for (size_t idx = 0U; idx < host->room.member_count; ++idx) {
        session_ctx_t *member = host->room.members[idx];
        if (member == NULL) {
          continue;
        }
        if (strncmp(member->client_ip, ip, SSH_CHATTER_IP_LEN) != 0) {
          continue;
        }
        member->user.is_operator = true;
        member->auth.is_operator = true;
        matches[match_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&host->room.lock);

  if (matches == NULL) {
    return;
  }

  for (size_t idx = 0U; idx < match_count; ++idx) {
    session_ctx_t *member = matches[idx];
    session_send_system_line(member, "Operator privileges granted for your IP address.");
  }
}

static bool host_remove_operator_grant_locked(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return false;
  }

  for (size_t idx = 0U; idx < host->operator_grant_count; ++idx) {
    if (strncmp(host->operator_grants[idx].ip, ip, SSH_CHATTER_IP_LEN) != 0) {
      continue;
    }

    for (size_t shift = idx; shift + 1U < host->operator_grant_count; ++shift) {
      host->operator_grants[shift] = host->operator_grants[shift + 1U];
    }
    memset(&host->operator_grants[host->operator_grant_count - 1U], 0,
           sizeof(host->operator_grants[host->operator_grant_count - 1U]));
    --host->operator_grant_count;
    return true;
  }

  return false;
}

static void host_revoke_grant_from_ip(host_t *host, const char *ip) {
  if (host == NULL || ip == NULL || ip[0] == '\0') {
    return;
  }

  session_ctx_t **matches = NULL;
  size_t match_count = 0U;

  pthread_mutex_lock(&host->room.lock);
  if (host->room.member_count > 0U) {
    session_ctx_t **allocated = GC_CALLOC(host->room.member_count, sizeof(*allocated));
    if (allocated != NULL) {
      matches = allocated;
    }

    for (size_t idx = 0U; idx < host->room.member_count; ++idx) {
      session_ctx_t *member = host->room.members[idx];
      if (member == NULL) {
        continue;
      }
      if (strncmp(member->client_ip, ip, SSH_CHATTER_IP_LEN) != 0) {
        continue;
      }
      if (member->user.is_lan_operator) {
        continue;
      }

      member->user.is_operator = false;
      member->auth.is_operator = false;

      if (matches != NULL) {
        matches[match_count++] = member;
      }
    }
  }
  pthread_mutex_unlock(&host->room.lock);

  if (matches == NULL) {
    return;
  }

  for (size_t idx = 0U; idx < match_count; ++idx) {
    session_ctx_t *member = matches[idx];
    if (member == NULL) {
      continue;
    }
    session_send_system_line(member, "Operator privileges revoked for your IP address.");
  }

}

static bool host_lookup_user_os(host_t *host, const char *username, char *buffer, size_t length) {
  if (host == NULL || username == NULL || buffer == NULL || length == 0U) {
    return false;
  }

  bool found = false;

  pthread_mutex_lock(&host->lock);
  user_preference_t *pref = host_find_preference_locked(host, username);
  if (pref != NULL && pref->os_name[0] != '\0') {
    snprintf(buffer, length, "%s", pref->os_name);
    found = true;
  }
  pthread_mutex_unlock(&host->lock);

  if (found) {
    return true;
  }

  session_ctx_t *session = chat_room_find_user(&host->room, username);
  if (session != NULL && session->os_name[0] != '\0') {
    snprintf(buffer, length, "%s", session->os_name);
    return true;
  }

  return false;
}

static void host_history_normalize_entry(host_t *host, chat_history_entry_t *entry) {
  if (host == NULL || entry == NULL) {
    return;
  }

  if (!entry->is_user_message) {
    entry->user_color_code = NULL;
    entry->user_highlight_code = NULL;
    entry->user_is_bold = false;
    entry->user_color_name[0] = '\0';
    entry->user_highlight_name[0] = '\0';
    return;
  }

  const char *color_code = lookup_color_code(USER_COLOR_MAP, sizeof(USER_COLOR_MAP) / sizeof(USER_COLOR_MAP[0]),
                                             entry->user_color_name);
  if (color_code == NULL) {
    color_code = host->user_theme.userColor;
    snprintf(entry->user_color_name, sizeof(entry->user_color_name), "%s", host->default_user_color_name);
  }

  const char *highlight_code = lookup_color_code(HIGHLIGHT_COLOR_MAP,
                                                sizeof(HIGHLIGHT_COLOR_MAP) / sizeof(HIGHLIGHT_COLOR_MAP[0]),
                                                entry->user_highlight_name);
  if (highlight_code == NULL) {
    highlight_code = host->user_theme.highlight;
    snprintf(entry->user_highlight_name, sizeof(entry->user_highlight_name), "%s",
             host->default_user_highlight_name);
  }

  entry->user_color_code = color_code;
  entry->user_highlight_code = highlight_code;
}

static void host_security_configure(host_t *host) {
  if (host == NULL) {
    return;
  }

  atomic_store(&host->security_filter_enabled, false);
  atomic_store(&host->security_filter_failure_logged, false);
  atomic_store(&host->security_ai_enabled, false);
  atomic_store(&host->security_clamav_enabled, false);
  atomic_store(&host->security_clamav_failure_logged, false);
  host->security_clamav_command[0] = '\0';

  const char *toggle = getenv("CHATTER_SECURITY_FILTER");
  if (toggle != NULL && toggle[0] != '\0') {
    if (strcasecmp(toggle, "0") == 0 || strcasecmp(toggle, "false") == 0 || strcasecmp(toggle, "off") == 0) {
      return;
    }
  }

  bool pipeline_enabled = false;

  const char *clamav_toggle = getenv("CHATTER_CLAMAV");
  bool clamav_disabled = false;
  if (clamav_toggle != NULL && clamav_toggle[0] != '\0') {
    if (strcasecmp(clamav_toggle, "0") == 0 || strcasecmp(clamav_toggle, "false") == 0 ||
        strcasecmp(clamav_toggle, "off") == 0) {
      clamav_disabled = true;
    }
  }

  if (!clamav_disabled) {
    const char *command = getenv("CHATTER_CLAMAV_COMMAND");
    if (command == NULL || command[0] == '\0') {
      command = "clamscan --no-summary --stdout .";
    }

    size_t command_length = strlen(command);
    if (command_length < sizeof(host->security_clamav_command)) {
      snprintf(host->security_clamav_command, sizeof(host->security_clamav_command), "%s", command);
      atomic_store(&host->security_clamav_enabled, true);
      pipeline_enabled = true;
    }
  }

  bool ai_requested = false;
  const char *ai_toggle = getenv("CHATTER_SECURITY_AI");
  if (ai_toggle != NULL && ai_toggle[0] != '\0') {
    if (!(strcasecmp(ai_toggle, "0") == 0 || strcasecmp(ai_toggle, "false") == 0 ||
          strcasecmp(ai_toggle, "off") == 0)) {
      ai_requested = true;
    }
  }

  if (ai_requested) {
    bool has_gemini = false;
    const char *gemini_key = getenv("GEMINI_API_KEY");
    if (gemini_key != NULL && gemini_key[0] != '\0') {
      has_gemini = true;
    }

    atomic_store(&host->security_ai_enabled, true);
    pipeline_enabled = true;

    const char *message = has_gemini ?
                             "[security] AI payload moderation enabled (Gemini primary, Ollama fallback)" :
                             "[security] AI payload moderation enabled (Ollama fallback only)";

    printf("%s\n", message);
  } else {
    printf("[security] AI payload moderation disabled (set CHATTER_SECURITY_AI=on to enable)\n");
  }

  if (pipeline_enabled) {
    atomic_store(&host->security_filter_enabled, true);
  }
}

static void host_security_disable_filter(host_t *host, const char *reason) {
  if (host == NULL) {
    return;
  }

  if (!atomic_exchange(&host->security_ai_enabled, false)) {
    return;
  }

  if (reason == NULL || reason[0] == '\0') {
    reason = "moderation failure";
  }

  if (!atomic_exchange(&host->security_filter_failure_logged, true)) {
    printf("[security] disabling payload moderation: %s\n", reason);
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    atomic_store(&host->security_filter_enabled, false);
  }
}

static void host_security_disable_clamav(host_t *host, const char *reason) {
  if (host == NULL) {
    return;
  }

  if (!atomic_exchange(&host->security_clamav_enabled, false)) {
    return;
  }

  if (reason == NULL || reason[0] == '\0') {
    reason = "ClamAV failure";
  }

  if (!atomic_exchange(&host->security_clamav_failure_logged, true)) {
    printf("[security] disabling ClamAV scanning: %s\n", reason);
  }

  if (!atomic_load(&host->security_ai_enabled)) {
    atomic_store(&host->security_filter_enabled, false);
  }
}

static void host_security_compact_whitespace(char *text) {
  if (text == NULL) {
    return;
  }

  size_t read_index = 0U;
  size_t write_index = 0U;
  bool previous_was_space = false;

  while (text[read_index] != '\0') {
    unsigned char ch = (unsigned char)text[read_index++];
    if (ch == '\r' || ch == '\n' || ch == '\t') {
      ch = ' ';
    } else if (ch < 0x20U || ch == 0x7FU) {
      ch = ' ';
    }

    if (ch == ' ') {
      if (previous_was_space) {
        continue;
      }
      previous_was_space = true;
      text[write_index++] = ' ';
    } else {
      previous_was_space = false;
      text[write_index++] = (char)ch;
    }
  }

  if (write_index > 0U && text[write_index - 1U] == ' ') {
    --write_index;
  }

  text[write_index] = '\0';
}


static double host_elapsed_seconds(const struct timespec *start,
                                 const struct timespec *end) {
  double sec = (double)end->tv_sec - (double)start->tv_sec;
  double nsec_to_sec = ((double)end->tv_nsec - (double)start->tv_nsec) / 1000000000.0;

  return sec + nsec_to_sec;
}


static bool host_security_execute_clamav_backend(host_t *host, char *notice, size_t notice_length) {
  if (notice != NULL && notice_length > 0U) {
    notice[0] = '\0';
  }

  if (host == NULL || notice == NULL || notice_length == 0U) {
    return false;
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    return false;
  }

  if (host->security_clamav_command[0] == '\0') {
    return false;
  }

  struct timespec start = {0, 0};
  if (clock_gettime(CLOCK_MONOTONIC, &start) != 0) {
    start.tv_sec = 0;
    start.tv_nsec = 0;
  }

  int pipefd[2];
  if (pipe(pipefd) == -1) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed to create pipe (%s).", reason);
    host_security_disable_clamav(host, reason);
    return true;
  }

  pid_t pid = fork();
  if (pid == -1) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan fork() failed (%s).", reason);
    host_security_disable_clamav(host, reason);
    int saved_errno = errno;
    int close_result = 0;
    do {
      close_result = close(pipefd[0]);
    } while (close_result != 0 && errno == EINTR);
    if (close_result != 0) {
      errno = saved_errno;
    }
    saved_errno = errno;
    do {
      close_result = close(pipefd[1]);
    } while (close_result != 0 && errno == EINTR);
    if (close_result != 0) {
      errno = saved_errno;
    }
    return true;
  }

  if (pid == 0) {
    // child process: redirect stdout/stderr to pipe
    int saved_errno = errno;
    int close_result = 0;
    do {
      close_result = close(pipefd[0]);
    } while (close_result != 0 && errno == EINTR);
    if (close_result != 0) {
      fprintf(stderr, "[security] close() failed in child: %s\n", strerror(errno));
      _exit(126);
    }
    errno = saved_errno;

    if (dup2(pipefd[1], STDOUT_FILENO) == -1) {
      fprintf(stderr, "[security] dup2() to STDOUT failed: %s\n", strerror(errno));
      _exit(126);
    }
    if (dup2(pipefd[1], STDERR_FILENO) == -1) {
      fprintf(stderr, "[security] dup2() to STDERR failed: %s\n", strerror(errno));
      _exit(126);
    }

    do {
      close_result = close(pipefd[1]);
    } while (close_result != 0 && errno == EINTR);
    if (close_result != 0) {
      fprintf(stderr, "[security] close() on pipe failed: %s\n", strerror(errno));
      _exit(126);
    }

    // execute clamscan without shell parsing issues
    const char *argv[] = {"sh", "-c", host->security_clamav_command, NULL};
    execvp(argv[0], (char *const *)argv);

    // only runs if exec failed
    fprintf(stderr, "[security] execvp() failed: %s\n", strerror(errno));
    _exit(127);
  }

  // parent process: turn pipefd[0] into a FILE* for compatibility
  int saved_errno = errno;
  int close_result = 0;
  do {
    close_result = close(pipefd[1]);
  } while (close_result != 0 && errno == EINTR);
  if (close_result != 0) {
    int error_code = errno;
    errno = saved_errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan close() failed (%s).", reason);
    host_security_disable_clamav(host, reason);
    do {
      close_result = close(pipefd[0]);
    } while (close_result != 0 && errno == EINTR);
    return true;
  }
  errno = saved_errno;
  FILE *pipe = fdopen(pipefd[0], "r");
  if (!pipe) {
    int error_code = errno;
    char reason[128];
    snprintf(reason, sizeof(reason), "%s", strerror(error_code));
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan fdopen() failed (%s).", reason);
    host_security_disable_clamav(host, reason);
    close(pipefd[0]);
    return true;
  }

  char output[SSH_CHATTER_CLAMAV_OUTPUT_LIMIT];
  output[0] = '\0';
  size_t output_length = 0U;

  char buffer[256];
  while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
    size_t chunk = strlen(buffer);
    if (chunk == 0U) {
      continue;
    }
    if (output_length + chunk >= sizeof(output)) {
      chunk = sizeof(output) - output_length - 1U;
    }
    if (chunk == 0U) {
      break;
    }
    memcpy(output + output_length, buffer, chunk);
    output_length += chunk;
    output[output_length] = '\0';
  }

  int status = -1;
  do {
    errno = 0;
    status = pclose(pipe);
  } while (status == -1 && errno == EINTR);
  struct timespec end = {0, 0};
  if (clock_gettime(CLOCK_MONOTONIC, &end) != 0) {
    end.tv_sec = 0;
    end.tv_nsec = 0;
  }
  host->security_clamav_last_run = end;
  struct timespec elapsed = timespec_diff(&end, &start);
  double seconds = (double)elapsed.tv_sec + (double)elapsed.tv_nsec / 1000000000.0;

  host_security_compact_whitespace(output);

  if (status == -1) {
    int error_code = errno;
    if (error_code != 0) {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan failed (unable to retrieve status: %s).",
               strerror(error_code));
    } else {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan failed (unable to retrieve status).");
    }
    host_security_disable_clamav(host, "unable to retrieve scheduled ClamAV status");
    return true;
  }

  if (!WIFEXITED(status)) {
    snprintf(notice, notice_length, "* [security] Scheduled ClamAV scan terminated unexpectedly.");
    host_security_disable_clamav(host, "scheduled ClamAV scan terminated unexpectedly");
    return true;
  }

  int exit_code = WEXITSTATUS(status);
  if (exit_code == 0) {
    return true;
  }

  if (exit_code == 1) {
    if (output[0] != '\0') {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan finished in %.1fs (issues found): %s", seconds, output);
    } else {
      snprintf(notice, notice_length,
               "* [security] Scheduled ClamAV scan finished in %.1fs (issues found).", seconds);
    }
    return true;
  }

  if (output[0] != '\0') {
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed in %.1fs (exit code %d): %s", seconds, exit_code, output);
  } else {
    snprintf(notice, notice_length,
             "* [security] Scheduled ClamAV scan failed in %.1fs (exit code %d).", seconds, exit_code);
  }
  host_security_disable_clamav(host, "scheduled ClamAV scan returned an error");
  return true;
}

static void *host_security_clamav_backend(void *arg) {
  host_t *host = (host_t *)arg;
  if (host == NULL) {
    return NULL;
  }

  atomic_store(&host->security_clamav_thread_running, true);
  printf("[security] scheduled ClamAV backend thread started (interval: %u seconds)\n",
         (unsigned int)SSH_CHATTER_CLAMAV_SCAN_INTERVAL_SECONDS);

  while (!atomic_load(&host->security_clamav_thread_stop)) {
    if (atomic_load(&host->security_clamav_enabled) && host->security_clamav_command[0] != '\0') {
      char notice[SSH_CHATTER_MESSAGE_LIMIT];
      if (host_security_execute_clamav_backend(host, notice, sizeof(notice)) && notice[0] != '\0') {
        printf("%s\n", notice);
        host_history_record_system(host, notice);
        chat_room_broadcast(&host->room, notice, NULL);
      }
    }

    unsigned int remaining = SSH_CHATTER_CLAMAV_SCAN_INTERVAL_SECONDS;
    while (remaining > 0U && !atomic_load(&host->security_clamav_thread_stop)) {
      unsigned int chunk =
          remaining > SSH_CHATTER_CLAMAV_SLEEP_CHUNK_SECONDS ? SSH_CHATTER_CLAMAV_SLEEP_CHUNK_SECONDS : remaining;
      struct timespec pause_duration = {
          .tv_sec = (time_t)chunk,
          .tv_nsec = 0,
      };
      host_sleep_uninterruptible(&pause_duration);
      if (remaining < chunk) {
        remaining = 0U;
      } else {
        remaining -= chunk;
      }
    }
  }

  atomic_store(&host->security_clamav_thread_running, false);
  printf("[security] scheduled ClamAV backend thread stopped\n");
  return NULL;
}

static void host_security_start_clamav_backend(host_t *host) {
  if (host == NULL) {
    return;
  }

  if (host->security_clamav_thread_initialized) {
    return;
  }

  if (!atomic_load(&host->security_clamav_enabled)) {
    return;
  }

  if (host->security_clamav_command[0] == '\0') {
    return;
  }

  atomic_store(&host->security_clamav_thread_stop, false);
  atomic_store(&host->security_clamav_thread_running, false);

  int error = pthread_create(&host->security_clamav_thread, NULL, host_security_clamav_backend, host);
  if (error != 0) {
    printf("[security] failed to start ClamAV backend thread: %s\n", strerror(error));
    return;
  }

  host->security_clamav_thread_initialized = true;
}

static bool host_ensure_private_data_path(host_t *host, const char *path, bool create_directories) {
  (void)host;
  if (path == NULL || path[0] == '\0') {
    return false;
  }

  char parent_buffer[PATH_MAX];
  snprintf(parent_buffer, sizeof(parent_buffer), "%s", path);
  char *parent_dir = dirname(parent_buffer);
  if (parent_dir == NULL || parent_dir[0] == '\0') {
    parent_dir = ".";
  }

  char parent_path[PATH_MAX];
  snprintf(parent_path, sizeof(parent_path), "%s", parent_dir);

  struct stat dir_stat;
  if (stat(parent_path, &dir_stat) != 0) {
    if (!(create_directories && errno == ENOENT)) {
      humanized_log_error("host", "failed to inspect data directory", errno != 0 ? errno : EIO);
      return false;
    }

    if (mkdir(parent_path, 0750) != 0 && errno != EEXIST) {
      humanized_log_error("host", "failed to create data directory", errno != 0 ? errno : EIO);
      return false;
    }

    if (stat(parent_path, &dir_stat) != 0) {
      humanized_log_error("host", "failed to inspect data directory", errno != 0 ? errno : EIO);
      return false;
    }
  }

  if (!S_ISDIR(dir_stat.st_mode)) {
    humanized_log_error("host", "data path parent is not a directory", ENOTDIR);
    return false;
  }

  mode_t insecure_bits = dir_stat.st_mode & (S_IWOTH | S_IWGRP);
  bool is_dot = strcmp(parent_path, ".") == 0;
  bool is_root = strcmp(parent_path, "/") == 0;
  if (insecure_bits != 0U) {
    if (!is_dot && !is_root) {
      mode_t tightened = dir_stat.st_mode & (mode_t)~(S_IWOTH | S_IWGRP);
      if (chmod(parent_path, tightened) != 0) {
        humanized_log_error("host", "failed to tighten data directory permissions", errno != 0 ? errno : EACCES);
        return false;
      }
    } else {
      humanized_log_error("host", "data directory permissions are too loose", EACCES);
      return false;
    }
  }

  struct stat file_stat;
  if (lstat(path, &file_stat) == 0) {
    if (!S_ISREG(file_stat.st_mode)) {
      humanized_log_error("host", "bbs state path does not reference a regular file", EINVAL);
      return false;
    }

    if ((file_stat.st_mode & (S_IWOTH | S_IWGRP)) != 0U) {
      if (chmod(path, S_IRUSR | S_IWUSR) != 0) {
        humanized_log_error("host", "failed to tighten bbs state permissions", errno != 0 ? errno : EACCES);
        return false;
      }
    }

    if (file_stat.st_uid != geteuid()) {
      humanized_log_error("host", "bbs state file ownership mismatch", EPERM);
      return false;
    }
  } else if (errno != ENOENT) {
    humanized_log_error("host", "failed to inspect bbs state path", errno != 0 ? errno : EIO);
    return false;
  }

  return true;
}
