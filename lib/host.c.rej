--- lib/host.c
+++ lib/host.c
@@ -7,50 +7,51 @@
 #endif
 
 // change with your IP
 #define  HOST_IP "59.23.169.247"
 #include "host.h"
 #include <libssh/libssh.h>
 #include <libssh/server.h>
 #include "client.h"
 #include "webssh_client.h"
 #include "matrix_client.h"
 #include "translator.h"
 #include "translation_helpers.h"
 
 #include <curl/curl.h>
 #include <gc/gc.h>
 #include <iconv.h>
 #include <ctype.h>
 #include <dirent.h>
 #include <dlfcn.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <math.h>
 #include <libgen.h>
 #include <limits.h>
+#include <signal.h>
 #include <wchar.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <netdb.h>
 #include <poll.h>
 #include <pthread.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <strings.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
 
 #include "humanized/humanized.h"
 
 #ifndef NI_MAXHOST
 #define NI_MAXHOST 1025
 #endif
@@ -233,50 +234,52 @@ static void host_load_lan_operator_credentials(host_t *host) {
       snprintf(existing->nickname, sizeof(existing->nickname), "%s", username);
       snprintf(existing->password, sizeof(existing->password), "%s", password);
       continue;
     }
 
     if (host->lan_ops.count >= SSH_CHATTER_MAX_LAN_OPERATORS) {
       continue;
     }
 
     lan_operator_credential_t *credential = &host->lan_ops.entries[host->lan_ops.count++];
     memset(credential, 0, sizeof(*credential));
     credential->active = true;
     snprintf(credential->nickname, sizeof(credential->nickname), "%s", username);
     snprintf(credential->password, sizeof(credential->password), "%s", password);
   }
 }
 
 typedef enum host_join_attempt_result {
   HOST_JOIN_ATTEMPT_OK = 0,
   HOST_JOIN_ATTEMPT_KICK,
   HOST_JOIN_ATTEMPT_BAN,
 } host_join_attempt_result_t;
 #define HOST_MODERATION_CATEGORY_LEN 64U
 #define HOST_MODERATION_SNIPPET_LEN 1024U
 #define HOST_MODERATION_WORKER_EXIT_CODE 0
+#define HOST_MODERATION_WORKER_STABLE_SECONDS 30.0
+#define HOST_MODERATION_MAX_RESTART_ATTEMPTS 5U
 
 typedef struct host_moderation_task {
   struct host_moderation_task *next;
   uint64_t task_id;
   char username[SSH_CHATTER_USERNAME_LEN];
   char client_ip[SSH_CHATTER_IP_LEN];
   char category[HOST_MODERATION_CATEGORY_LEN];
   char snippet[HOST_MODERATION_SNIPPET_LEN];
   size_t snippet_length;
   char message[SSH_CHATTER_MESSAGE_LIMIT];
   bool post_send;
 } host_moderation_task_t;
 
 typedef struct {
   uint64_t task_id;
   uint32_t category_length;
   uint32_t content_length;
 } host_moderation_ipc_request_t;
 
 typedef struct {
   uint64_t task_id;
   int32_t result;
   uint32_t message_length;
   uint32_t disable_filter;
 } host_moderation_ipc_response_t;
@@ -4019,63 +4022,68 @@ static size_t host_eliza_memory_collect_context(host_t *host, const char *prompt
 static void host_eliza_history_normalize_line(char *text);
 static size_t host_eliza_history_collect_context(host_t *host, char *context, size_t context_length);
 static void host_eliza_prepare_preview(const char *source, char *dest, size_t dest_length);
 static size_t host_eliza_bbs_collect_context(host_t *host, char *context, size_t context_length);
 static size_t host_eliza_memory_collect_tokens(const char *prompt, char tokens[][32], size_t max_tokens);
 static void host_bbs_resolve_path(host_t *host);
 static void host_bbs_state_load(host_t *host);
 static void host_bbs_state_save_locked(host_t *host);
 static void host_bbs_start_watchdog(host_t *host);
 static void *host_bbs_watchdog_thread(void *arg);
 static void host_bbs_watchdog_scan(host_t *host);
 static void host_security_configure(host_t *host);
 static bool host_ensure_private_data_path(host_t *host, const char *path, bool create_directories);
 static void host_security_compact_whitespace(char *text);
 static bool host_security_execute_clamav_backend(host_t *host, char *notice, size_t notice_length);
 static void *host_security_clamav_backend(void *arg);
 static void host_security_start_clamav_backend(host_t *host);
 static void host_security_disable_filter(host_t *host, const char *reason);
 static void host_security_disable_clamav(host_t *host, const char *reason);
 static host_security_scan_result_t host_security_scan_payload(host_t *host, const char *category, const char *payload,
                                                               size_t length, char *diagnostic, size_t diagnostic_length);
 static void host_security_process_blocked(host_t *host, const char *category, const char *diagnostic,
                                          const char *username, const char *ip, session_ctx_t *session,
                                          bool post_send, const char *content);
 static void host_security_process_error(host_t *host, const char *category, const char *diagnostic,
-                                       const char *username, const char *ip, session_ctx_t *session,
-                                       bool post_send);
+                                         const char *username, const char *ip, session_ctx_t *session,
+                                         bool post_send);
 static bool host_moderation_init(host_t *host);
 static void host_moderation_shutdown(host_t *host);
+static void host_moderation_backoff(unsigned int attempts);
+static bool host_moderation_spawn_worker(host_t *host);
+static void host_moderation_close_worker(host_t *host);
+static bool host_moderation_recover_worker(host_t *host, const char *diagnostic);
 static bool host_moderation_queue_chat(session_ctx_t *ctx, const char *message, size_t length);
 static void *host_moderation_thread(void *arg);
 static bool host_moderation_write_all(int fd, const void *buffer, size_t length);
 static bool host_moderation_read_all(int fd, void *buffer, size_t length);
 static void host_moderation_worker_loop(int request_fd, int response_fd);
 static void host_moderation_handle_failure(host_t *host, host_moderation_task_t *task, const char *diagnostic);
 static void host_moderation_apply_result(host_t *host, host_moderation_task_t *task,
-                                        const host_moderation_ipc_response_t *response, const char *message);
+                                         const host_moderation_ipc_response_t *response, const char *message);
 static void host_moderation_flush_pending(host_t *host, const char *diagnostic);
+static double host_elapsed_seconds(const struct timespec *start, const struct timespec *end);
 static bool host_eliza_enable(host_t *host);
 static bool host_eliza_disable(host_t *host);
 static void host_eliza_announce_join(host_t *host);
 static void host_eliza_announce_depart(host_t *host);
 static void host_eliza_say(host_t *host, const char *message);
 static void host_eliza_handle_private_message(session_ctx_t *ctx, const char *message);
 static void host_eliza_prepare_private_reply(const char *message, char *reply, size_t reply_length);
 static bool host_eliza_content_is_severe(const char *text);
 static bool host_eliza_worker_init(host_t *host);
 static void host_eliza_worker_shutdown(host_t *host);
 static bool host_eliza_worker_enqueue(host_t *host, host_eliza_intervene_task_t *task);
 static void *host_eliza_worker_thread(void *arg);
 static bool host_eliza_intervene(session_ctx_t *ctx, const char *content, const char *reason, bool from_filter);
 static void host_eliza_intervene_execute(session_ctx_t *ctx, const char *reason, bool from_filter);
 static host_security_scan_result_t session_security_check_text(session_ctx_t *ctx, const char *category,
                                                                const char *content, size_t length, bool post_send);
 static void host_vote_resolve_path(host_t *host);
 static void host_vote_state_load(host_t *host);
 static void host_vote_state_save_locked(host_t *host);
 static bool host_try_load_motd_from_path(host_t *host, const char *path);
 static bool username_contains(const char *username, const char *needle);
 static void host_apply_palette_descriptor(host_t *host, const palette_descriptor_t *descriptor);
 static bool host_lookup_user_os(host_t *host, const char *username, char *buffer, size_t length);
 static void session_send_poll_summary(session_ctx_t *ctx);
 static void session_send_poll_summary_generic(session_ctx_t *ctx, const poll_state_t *poll, const char *label);
@@ -7268,50 +7276,193 @@ static void host_moderation_worker_loop(int request_fd, int response_fd) {
       if (reason[0] != '\0') {
         message_length = strnlen(reason, sizeof(message) - 1U);
         memcpy(message, reason, message_length);
         message[message_length] = '\0';
       }
     } else {
       response.result = HOST_SECURITY_SCAN_CLEAN;
     }
 
     response.message_length = (uint32_t)message_length;
 
     if (!host_moderation_write_all(response_fd, &response, sizeof(response))) {
       break;
     }
 
     if (message_length > 0U) {
       if (!host_moderation_write_all(response_fd, message, message_length)) {
         break;
       }
     }
   }
 
   _exit(HOST_MODERATION_WORKER_EXIT_CODE);
 }
 
+static void host_moderation_backoff(unsigned int attempts) {
+  struct timespec delay = {
+      .tv_sec = (attempts < 3U) ? 1L : ((attempts < 6U) ? 5L : 30L),
+      .tv_nsec = 0L,
+  };
+  nanosleep(&delay, NULL);
+}
+
+static void host_moderation_close_worker(host_t *host) {
+  if (host == NULL) {
+    return;
+  }
+
+  if (host->moderation.request_fd >= 0) {
+    close(host->moderation.request_fd);
+    host->moderation.request_fd = -1;
+  }
+  if (host->moderation.response_fd >= 0) {
+    close(host->moderation.response_fd);
+    host->moderation.response_fd = -1;
+  }
+
+  if (host->moderation.worker_pid > 0) {
+    int status = 0;
+    pid_t result = waitpid(host->moderation.worker_pid, &status, WNOHANG);
+    if (result == 0) {
+      (void)kill(host->moderation.worker_pid, SIGTERM);
+      (void)waitpid(host->moderation.worker_pid, &status, 0);
+    }
+    host->moderation.worker_pid = -1;
+  }
+}
+
+static bool host_moderation_spawn_worker(host_t *host) {
+  if (host == NULL) {
+    return false;
+  }
+
+  int request_pipe[2] = {-1, -1};
+  int response_pipe[2] = {-1, -1};
+
+  if (pipe(request_pipe) != 0) {
+    return false;
+  }
+  if (pipe(response_pipe) != 0) {
+    close(request_pipe[0]);
+    close(request_pipe[1]);
+    return false;
+  }
+
+  pid_t pid = fork();
+  if (pid < 0) {
+    close(request_pipe[0]);
+    close(request_pipe[1]);
+    close(response_pipe[0]);
+    close(response_pipe[1]);
+    return false;
+  }
+
+  if (pid == 0) {
+    close(request_pipe[1]);
+    close(response_pipe[0]);
+    host_moderation_worker_loop(request_pipe[0], response_pipe[1]);
+  }
+
+  close(request_pipe[0]);
+  close(response_pipe[1]);
+
+  host->moderation.worker_pid = pid;
+  host->moderation.request_fd = request_pipe[1];
+  host->moderation.response_fd = response_pipe[0];
+
+  if (clock_gettime(CLOCK_MONOTONIC, &host->moderation.worker_start_time) != 0) {
+    host->moderation.worker_start_time.tv_sec = 0;
+    host->moderation.worker_start_time.tv_nsec = 0;
+  }
+
+  return true;
+}
+
+static bool host_moderation_recover_worker(host_t *host, const char *diagnostic) {
+  if (host == NULL) {
+    return false;
+  }
+
+  const char *reason = (diagnostic != NULL && diagnostic[0] != '\0') ? diagnostic : "moderation worker failure";
+
+  struct timespec now;
+  if (clock_gettime(CLOCK_MONOTONIC, &now) == 0) {
+    double runtime = host_elapsed_seconds(&host->moderation.worker_start_time, &now);
+    if (runtime >= HOST_MODERATION_WORKER_STABLE_SECONDS && host->moderation.restart_attempts > 0U) {
+      host->moderation.restart_attempts = 0U;
+    }
+  } else {
+    host->moderation.restart_attempts = 0U;
+  }
+
+  unsigned int attempt = host->moderation.restart_attempts + 1U;
+
+  char detail[256];
+  snprintf(detail, sizeof(detail), "moderation worker panic (%s)", reason);
+  humanized_log_error("moderation", detail, EIO);
+  printf("[moderation] worker panic (%s); scheduling restart attempt %u\n", reason, attempt);
+
+  host_moderation_close_worker(host);
+  host_moderation_flush_pending(host, reason);
+
+  if (attempt > HOST_MODERATION_MAX_RESTART_ATTEMPTS) {
+    humanized_log_error("moderation", "too many moderation worker panics; disabling moderation filter", EIO);
+    pthread_mutex_lock(&host->moderation.mutex);
+    host->moderation.active = false;
+    host->moderation.stop = true;
+    pthread_cond_broadcast(&host->moderation.cond);
+    pthread_mutex_unlock(&host->moderation.mutex);
+    atomic_store(&host->security_filter_enabled, false);
+    return false;
+  }
+
+  host_moderation_backoff(attempt);
+
+  if (!host_moderation_spawn_worker(host)) {
+    humanized_log_error("moderation", "failed to restart moderation worker", EIO);
+    pthread_mutex_lock(&host->moderation.mutex);
+    host->moderation.active = false;
+    host->moderation.stop = true;
+    pthread_cond_broadcast(&host->moderation.cond);
+    pthread_mutex_unlock(&host->moderation.mutex);
+    atomic_store(&host->security_filter_enabled, false);
+    return false;
+  }
+
+  host->moderation.restart_attempts = attempt;
+
+  pthread_mutex_lock(&host->moderation.mutex);
+  host->moderation.active = true;
+  host->moderation.stop = false;
+  pthread_cond_broadcast(&host->moderation.cond);
+  pthread_mutex_unlock(&host->moderation.mutex);
+
+  printf("[moderation] worker recovered after panic (attempt %u)\n", attempt);
+  return true;
+}
+
 static void host_moderation_apply_result(host_t *host, host_moderation_task_t *task,
                                         const host_moderation_ipc_response_t *response, const char *message) {
   if (host == NULL || task == NULL || response == NULL) {
     return;
   }
 
   session_ctx_t *session = chat_room_find_user(&host->room, task->username);
 
   if (response->disable_filter != 0U) {
     const char *reason = (message != NULL && message[0] != '\0') ? message : "moderation pipeline unavailable";
     host_security_disable_filter(host, reason);
   }
 
   switch (response->result) {
     case HOST_SECURITY_SCAN_CLEAN:
       break;
     case HOST_SECURITY_SCAN_BLOCKED:
       host_security_process_blocked(host, task->category, message, task->username, task->client_ip, session,
                                     task->post_send, task->message);
       break;
     case HOST_SECURITY_SCAN_ERROR:
     default:
       host_security_process_error(host, task->category, message, task->username, task->client_ip, session,
                                   task->post_send);
       break;
@@ -7332,50 +7483,51 @@ static void host_moderation_handle_failure(host_t *host, host_moderation_task_t
                               task->post_send);
 }
 
 static void host_moderation_flush_pending(host_t *host, const char *diagnostic) {
   if (host == NULL) {
     return;
   }
 
   host_moderation_task_t *task = NULL;
 
   if (host->moderation.mutex_initialized) {
     pthread_mutex_lock(&host->moderation.mutex);
     task = host->moderation.head;
     host->moderation.head = NULL;
     host->moderation.tail = NULL;
     pthread_mutex_unlock(&host->moderation.mutex);
   }
 
   const char *message = (diagnostic != NULL && diagnostic[0] != '\0') ? diagnostic : "moderation unavailable";
 
   while (task != NULL) {
     host_moderation_task_t *next = task->next;
     session_ctx_t *session = chat_room_find_user(&host->room, task->username);
     host_security_process_error(host, task->category, message, task->username, task->client_ip, session,
                                 task->post_send);
+    GC_FREE(task);
     task = next;
   }
 }
 
 static void *host_moderation_thread(void *arg) {
   host_t *host = (host_t *)arg;
   if (host == NULL) {
     return NULL;
   }
 
   const char *failure_reason = NULL;
 
   while (true) {
     pthread_mutex_lock(&host->moderation.mutex);
     while (!host->moderation.stop && host->moderation.head == NULL && host->moderation.active) {
       pthread_cond_wait(&host->moderation.cond, &host->moderation.mutex);
     }
 
     if (!host->moderation.active ||
         (host->moderation.stop && host->moderation.head == NULL)) {
       pthread_mutex_unlock(&host->moderation.mutex);
       break;
     }
 
     host_moderation_task_t *task = host->moderation.head;
@@ -7387,277 +7539,253 @@ static void *host_moderation_thread(void *arg) {
     }
     pthread_mutex_unlock(&host->moderation.mutex);
 
     if (task == NULL) {
       continue;
     }
 
     host_moderation_ipc_request_t request;
     memset(&request, 0, sizeof(request));
     request.task_id = task->task_id;
     request.category_length = (uint32_t)strnlen(task->category, HOST_MODERATION_CATEGORY_LEN - 1U);
     request.content_length = (uint32_t)task->snippet_length;
 
     bool success = true;
     if (!host_moderation_write_all(host->moderation.request_fd, &request, sizeof(request)) ||
         (request.category_length > 0U &&
          !host_moderation_write_all(host->moderation.request_fd, task->category, request.category_length)) ||
         (request.content_length > 0U &&
          !host_moderation_write_all(host->moderation.request_fd, task->snippet, request.content_length))) {
       success = false;
     }
 
     if (!success) {
       failure_reason = "moderation worker unavailable";
       host_moderation_handle_failure(host, task, failure_reason);
-      pthread_mutex_lock(&host->moderation.mutex);
-      host->moderation.active = false;
-      host->moderation.stop = true;
-      pthread_cond_broadcast(&host->moderation.cond);
-      pthread_mutex_unlock(&host->moderation.mutex);
-      break;
+      bool recovered = host_moderation_recover_worker(host, failure_reason);
+      GC_FREE(task);
+      if (!recovered) {
+        break;
+      }
+      failure_reason = NULL;
+      continue;
     }
 
     host_moderation_ipc_response_t response;
     if (!host_moderation_read_all(host->moderation.response_fd, &response, sizeof(response))) {
       failure_reason = "moderation worker unavailable";
       host_moderation_handle_failure(host, task, failure_reason);
-      pthread_mutex_lock(&host->moderation.mutex);
-      host->moderation.active = false;
-      host->moderation.stop = true;
-      pthread_cond_broadcast(&host->moderation.cond);
-      pthread_mutex_unlock(&host->moderation.mutex);
-      break;
+      bool recovered = host_moderation_recover_worker(host, failure_reason);
+      GC_FREE(task);
+      if (!recovered) {
+        break;
+      }
+      failure_reason = NULL;
+      continue;
     }
 
     size_t message_length = response.message_length;
     char *message = NULL;
 
     if (message_length > 0U) {
-      message = (char *)malloc(message_length + 1U);
+      message = (char *)GC_MALLOC(message_length + 1U);
       if (message == NULL) {
-        char *discard = (char *)malloc(message_length);
+        char *discard = (char *)GC_MALLOC(message_length);
         if (discard != NULL) {
           (void)host_moderation_read_all(host->moderation.response_fd, discard, message_length);
+          GC_FREE(discard);
         }
         failure_reason = "moderation worker unavailable";
         host_moderation_handle_failure(host, task, failure_reason);
-        pthread_mutex_lock(&host->moderation.mutex);
-        host->moderation.active = false;
-        host->moderation.stop = true;
-        pthread_cond_broadcast(&host->moderation.cond);
-        pthread_mutex_unlock(&host->moderation.mutex);
-        break;
+        bool recovered = host_moderation_recover_worker(host, failure_reason);
+        GC_FREE(task);
+        if (!recovered) {
+          break;
+        }
+        failure_reason = NULL;
+        continue;
       }
 
       if (!host_moderation_read_all(host->moderation.response_fd, message, message_length)) {
         failure_reason = "moderation worker unavailable";
         host_moderation_handle_failure(host, task, failure_reason);
-        pthread_mutex_lock(&host->moderation.mutex);
-        host->moderation.active = false;
-        host->moderation.stop = true;
-        pthread_cond_broadcast(&host->moderation.cond);
-        pthread_mutex_unlock(&host->moderation.mutex);
-        break;
+        bool recovered = host_moderation_recover_worker(host, failure_reason);
+        GC_FREE(message);
+        GC_FREE(task);
+        if (!recovered) {
+          break;
+        }
+        failure_reason = NULL;
+        continue;
       }
       message[message_length] = '\0';
     }
 
     const char *message_text = (message != NULL) ? message : "";
     host_moderation_apply_result(host, task, &response, message_text);
+    if (message != NULL) {
+      GC_FREE(message);
+    }
+    GC_FREE(task);
+    failure_reason = NULL;
   }
 
   host_moderation_flush_pending(host, failure_reason);
   return NULL;
 }
 
 static bool host_moderation_init(host_t *host) {
   if (host == NULL) {
     return false;
   }
 
   host->moderation.active = false;
   host->moderation.stop = false;
   host->moderation.head = NULL;
   host->moderation.tail = NULL;
   host->moderation.next_task_id = 1U;
   host->moderation.request_fd = -1;
   host->moderation.response_fd = -1;
   host->moderation.worker_pid = -1;
   host->moderation.thread_started = false;
   host->moderation.mutex_initialized = false;
   host->moderation.cond_initialized = false;
 
   if (pthread_mutex_init(&host->moderation.mutex, NULL) != 0) {
     return false;
   }
   host->moderation.mutex_initialized = true;
 
   if (pthread_cond_init(&host->moderation.cond, NULL) != 0) {
     pthread_mutex_destroy(&host->moderation.mutex);
     host->moderation.mutex_initialized = false;
     return false;
   }
   host->moderation.cond_initialized = true;
 
-  int request_pipe[2];
-  int response_pipe[2];
-  if (pipe(request_pipe) != 0) {
-    host_moderation_shutdown(host);
-    return false;
-  }
-  if (pipe(response_pipe) != 0) {
-    close(request_pipe[0]);
-    close(request_pipe[1]);
-    host_moderation_shutdown(host);
-    return false;
-  }
+  host->moderation.restart_attempts = 0U;
+  host->moderation.worker_start_time.tv_sec = 0;
+  host->moderation.worker_start_time.tv_nsec = 0;
 
-  pid_t pid = fork();
-  if (pid < 0) {
-    close(request_pipe[0]);
-    close(request_pipe[1]);
-    close(response_pipe[0]);
-    close(response_pipe[1]);
+  if (!host_moderation_spawn_worker(host)) {
     host_moderation_shutdown(host);
     return false;
   }
 
-  if (pid == 0) {
-    close(request_pipe[1]);
-    close(response_pipe[0]);
-    host_moderation_worker_loop(request_pipe[0], response_pipe[1]);
-  }
-
-  host->moderation.worker_pid = pid;
-  host->moderation.request_fd = request_pipe[1];
-  host->moderation.response_fd = response_pipe[0];
-  close(request_pipe[0]);
-  close(response_pipe[1]);
-
   host->moderation.active = true;
   host->moderation.stop = false;
 
   if (pthread_create(&host->moderation.thread, NULL, host_moderation_thread, host) != 0) {
     host->moderation.active = false;
     host->moderation.stop = true;
     host_moderation_shutdown(host);
     return false;
   }
 
   host->moderation.thread_started = true;
   return true;
 }
 
 static void host_moderation_shutdown(host_t *host) {
   if (host == NULL) {
     return;
   }
 
   if (!host->moderation.active && !host->moderation.thread_started) {
     if (host->moderation.mutex_initialized) {
       pthread_mutex_destroy(&host->moderation.mutex);
       host->moderation.mutex_initialized = false;
     }
     if (host->moderation.cond_initialized) {
       pthread_cond_destroy(&host->moderation.cond);
       host->moderation.cond_initialized = false;
     }
     return;
   }
 
   if (host->moderation.mutex_initialized) {
     pthread_mutex_lock(&host->moderation.mutex);
     host->moderation.stop = true;
     pthread_cond_broadcast(&host->moderation.cond);
     pthread_mutex_unlock(&host->moderation.mutex);
   }
 
   if (host->moderation.thread_started) {
     pthread_join(host->moderation.thread, NULL);
     host->moderation.thread_started = false;
   }
 
-  if (host->moderation.request_fd >= 0) {
-    close(host->moderation.request_fd);
-    host->moderation.request_fd = -1;
-  }
-  if (host->moderation.response_fd >= 0) {
-    close(host->moderation.response_fd);
-    host->moderation.response_fd = -1;
-  }
-
-  if (host->moderation.worker_pid > 0) {
-    int status = 0;
-    (void)waitpid(host->moderation.worker_pid, &status, 0);
-    host->moderation.worker_pid = -1;
-  }
+  host_moderation_close_worker(host);
+  host->moderation.restart_attempts = 0U;
+  host->moderation.worker_start_time.tv_sec = 0;
+  host->moderation.worker_start_time.tv_nsec = 0;
 
   host_moderation_flush_pending(host, NULL);
 
   if (host->moderation.mutex_initialized) {
     pthread_mutex_destroy(&host->moderation.mutex);
     host->moderation.mutex_initialized = false;
   }
   if (host->moderation.cond_initialized) {
     pthread_cond_destroy(&host->moderation.cond);
     host->moderation.cond_initialized = false;
   }
 
   host->moderation.active = false;
 }
 
 static bool host_moderation_queue_chat(session_ctx_t *ctx, const char *message, size_t length) {
   if (ctx == NULL || ctx->owner == NULL || message == NULL || length == 0U) {
     return false;
   }
 
   host_t *host = ctx->owner;
   if (!host->moderation.active || host->moderation.request_fd < 0 || host->moderation.response_fd < 0) {
     return false;
   }
 
   if (!atomic_load(&host->security_filter_enabled)) {
     return false;
   }
 
   bool clamav_active = atomic_load(&host->security_clamav_enabled);
   bool ai_active = atomic_load(&host->security_ai_enabled);
   if (!clamav_active && !ai_active) {
     atomic_store(&host->security_filter_enabled, false);
     return false;
   }
 
   if (!ai_active) {
     return false;
   }
 
   if (!atomic_load(&host->eliza_enabled)) {
     return false;
   }
 
-  host_moderation_task_t *task = (host_moderation_task_t *)malloc(sizeof(*task));
+  host_moderation_task_t *task =
+      (host_moderation_task_t *)GC_MALLOC(sizeof(*task));
   if (task == NULL) {
     return false;
   }
 
   memset(task, 0, sizeof(*task));
   snprintf(task->username, sizeof(task->username), "%s", ctx->user.name);
   snprintf(task->client_ip, sizeof(task->client_ip), "%s", ctx->client_ip);
   snprintf(task->category, sizeof(task->category), "%s", "chat message");
 
   size_t effective_length = strnlen(message, SSH_CHATTER_MESSAGE_LIMIT - 1U);
   if (effective_length > length) {
     effective_length = length;
   }
 
   task->snippet_length = effective_length;
   if (task->snippet_length >= HOST_MODERATION_SNIPPET_LEN) {
     task->snippet_length = HOST_MODERATION_SNIPPET_LEN - 1U;
   }
   memcpy(task->snippet, message, task->snippet_length);
   for (size_t idx = 0U; idx < task->snippet_length; ++idx) {
     unsigned char ch = (unsigned char)task->snippet[idx];
     if (ch == '\0') {
       task->snippet_length = idx;
       break;
     }
